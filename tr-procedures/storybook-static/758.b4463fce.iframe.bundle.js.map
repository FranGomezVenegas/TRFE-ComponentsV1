{"version":3,"file":"758.b4463fce.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4DA;;AC08BA;AACA;AACA;;AAAA;ADjyBA;;;AAIA;;;;AElOA;;AAAA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;;;AAOA;;;;AAKA;;;;AAKA;;AAGA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;AAGA;;AAGA;;AAGA;;;;;;AAOA;;;AAIA;;AAGA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;AAKA;;;;;AAMA;;;;;AAMA;;;;;AAMA;;;;;AAMA;;;;;AClQA;;;AAGA;;;AAGA;;;AAGA;;;AAGA;;;AAGA;;;AAGA;;;;AAIA;;;;AAIA;;;AAGA;;;AAGA;;;AAGA;;;AAGA;;AA6HA;;;AAvHA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;AAGA;;;AAGA;;;;AAIA;;;;AAIA;;;;AAIA;;AAGA;;AAEA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;;;;;;AASA;;;;;;;;AAQA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;AAGA;;AAEA;;;;;AAKA;;;;AAIA;;;;AAIA;;;;AAIA;;;;;AAKA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;AAGA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjIA;;;;;;AASA;;;ACwLA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6NA;AC7bA;AAEA;AA4BA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AASA;AAEA;ACpFA;;;AAGA;AAEA;;ACpCA;;AAGA;;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAKA;ACkBA;AACA;AACA;AACA;;AAMA;AAGA;AAYA;;AAGA;;;AAMA;;AAKA;AAEA;;;;;;;AAaA;;;ACGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;AAMA;AAGA;;AClGA;AACA;AACA;AACA;AACA;AACA;AAEA;;ACUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;;ACKA;;;AAGA;AACA;;AAEA;AACA;;;;;AAKA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBA;;AAEA;;AAEA;;;;AAQA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAmBA;;AAOA;AACA;;AAEA;AAPA;;AAgBA;AACA;AALA;AAmBA;AAEA;;AAWA;AACA;;;ACrNA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;;;;;;AAOA;AACA;AACA;;AAGA;;AAaA;AACA;;AAEA;AACA;;;AAIA;;;;AAQA;;;;AAQA;;;;AAOA;;;;AAUA;;;;AAQA;AC3FA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;;AAWA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxEA;;;;AAiHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC+CA;;;;;;;;;;;;;;;;;;;;;AC7HA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzDA;;;;;;;;;;;;;;;;;;;;ACJA;;;;;;;;;;;;;;;;;;ACnCA;;;;;;;;;;;;;;;;;;;;;;;;;AC0MA;;;;;;;;;;;;;;;AChLA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC+DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACsPA;;;;AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnFA;;;;;;;;;;;;;;;;;;;ACwBA;;;;;;;;;;;;;ACtPA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6GA;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/BA;;;;;;;;;;;;;;;ACnDA;;;;;;;;;;;;;;;;;;;;;;;ACQA;;;;;;;;;;;;;;;;;;ACLA;;;;;;;;;;;;;;;;;;;;ACEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACmCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACkPA","sources":["webpack://@trazit/tr-procedures/../node_modules/@cicciosgamino/qr-code-element/qr-code-element.js","webpack://@trazit/tr-procedures/../node_modules/@cicciosgamino/qr-code-element/qr-code.js","webpack://@trazit/tr-procedures/./node_modules/@collaborne/lit-flexbox-literals/dist/Literals/index.js","webpack://@trazit/tr-procedures/./node_modules/@collaborne/lit-flexbox-literals/dist/Classes/index.js","webpack://@trazit/tr-procedures/./node_modules/@doubletrade/lit-datatable/lit-datatable.js","webpack://@trazit/tr-procedures/./node_modules/@google-web-components/google-chart/google-chart.js","webpack://@trazit/tr-procedures/./node_modules/@material/mwc-checkbox/mwc-checkbox-base.js","webpack://@trazit/tr-procedures/./node_modules/@material/mwc-formfield/mwc-formfield-base.js","webpack://@trazit/tr-procedures/./node_modules/@material/mwc-icon-button/mwc-icon-button-base.js","webpack://@trazit/tr-procedures/./node_modules/@material/mwc-list/mwc-list-item-base.js","webpack://@trazit/tr-procedures/./node_modules/@material/mwc-list/mwc-list-base.js","webpack://@trazit/tr-procedures/./node_modules/@material/mwc-menu/mwc-menu-surface-base.js","webpack://@trazit/tr-procedures/./node_modules/@material/mwc-menu/mwc-menu-base.js","webpack://@trazit/tr-procedures/./node_modules/@material/mwc-select/mwc-select-base.js","webpack://@trazit/tr-procedures/./node_modules/@material/mwc-switch/mwc-switch-base.js","webpack://@trazit/tr-procedures/./node_modules/@material/mwc-textarea/mwc-textarea-base.js","webpack://@trazit/tr-procedures/./node_modules/@spectrum-web-components/tooltip/src/Tooltip.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-checkbox/src/vaadin-checkbox.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox-styles.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-context-menu/theme/lumo/vaadin-context-menu-styles.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-list-box/theme/lumo/vaadin-list-box-styles.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-list-box/src/vaadin-list-box.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-context-menu/src/vaadin-context-menu-overlay.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-context-menu/src/vaadin-context-menu.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-grid/src/vaadin-grid-filter.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-grid/theme/lumo/vaadin-grid-sorter-styles.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-grid/src/vaadin-grid-sorter.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-grid/theme/lumo/vaadin-grid-styles.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-grid/src/vaadin-grid-styles.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-grid/src/vaadin-grid.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-item/src/vaadin-item.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-item/theme/lumo/vaadin-item-styles.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-lumo-styles/color.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-lumo-styles/mixins/field-button.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-lumo-styles/mixins/menu-overlay.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-lumo-styles/mixins/overlay.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-lumo-styles/sizing.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-lumo-styles/spacing.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-lumo-styles/style.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-lumo-styles/typography.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-overlay/src/vaadin-overlay.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-text-field/src/vaadin-text-field-mixin.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-text-field/src/vaadin-text-field.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-lumo-styles/mixins/required-field.js","webpack://@trazit/tr-procedures/./node_modules/@vaadin/vaadin-text-field/theme/lumo/vaadin-text-field-styles.js"],"sourcesContent":["import { LitElement, css, html, svg } from 'lit'\n\nimport {\n\tQrCode,\n\tQrSegment,\n\tEcc,\n\tcountUnicodeChars,\n\tdrawOnCanvas,\n\ttoSvgString\n} from './qr-code.js'\n\n/**\n * Lit WebCompoment use as a wrapper for Qr Code Projecy Nayuki Library\n * \n * https://www.nayuki.io/page/qr-code-generator-library\n * \n * Project Nayuki Library v1.8.0 \n * \n */\nclass QrCodeElement extends LitElement {\n\n\tstatic get styles () {\n\t\treturn css`\n\t\t\t:host {\n\t\t\t\t--size: var(--size, 11rem);\n\t\t\t\t--icon-size: var(--icon-size, calc(var(--size) * 0.15));\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: relative;\n\t\t\t}\n\n\t\t\t:host > svg {\n\t\t\t\tinline-size: var(--size);\n\t\t\t\tblock-size: var(--size);\n\t\t\t}\n\n\t\t\t::slotted(svg) {\n\t\t\t\tinline-size: var(--icon-size);\n\t\t\t\tblock-size: var(--icon-size);\n\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: calc((var(--size) - var(--icon-size)) / 2);\n\t\t\t\tleft: calc((var(--size) - var(--icon-size)) / 2);\n\n\t\t\t\tz-index: 10;\n\n\t\t\t\t/* border-radius: 50%; */\n\t\t\t\t/* background-color: whitesmoke; */\n\t\t\t}\n\n\t\t\tcanvas {\n\t\t\t\tinline-size: var(--size);\n\t\t\t\tblock-size: var(--size);\n\t\t\t}\n\n\t\t\tsvg {\n\t\t\t\tinline-size: var(--size);\n\t\t\t\tblock-size: var(--size);\n\t\t\t}\n\t\t`\n\t}\n\n\tstatic get properties () {\n\t\treturn {\n\t\t\ttext: String,\n\t\t\tgraphicElement: {\n\t\t\t\ttype: String,\n\t\t\t\tattribute: 'graphic-element',\n\t\t\t\tconverter: {\n\t\t\t\t\tfromAttribute: (value, type) => {\n\n\t\t\t\t\t\tswitch (value.toLowerCase()) {\n\t\t\t\t\t\t\tcase 'svg':\n\t\t\t\t\t\t\t\treturn 'svg'\n\t\t\t\t\t\t\tcase 'canvas':\n\t\t\t\t\t\t\t\treturn 'canvas'\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn 'svg'\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tscale: Number,\n\t\t\tborder: Number,\n\t\t\tmaskPattern: {\n\t\t\t\ttype: Number,\n\t\t\t\tattribute: 'mask-pattern',\n\t\t\t\tconverter: {\n\t\t\t\t\tfromAttribute: (value, type) => {\n\t\t\t\t\t\tif (value >= -1 && value < 8) {\n\t\t\t\t\t\t\treturn value\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn -1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tbkColor: {\n\t\t\t\ttype: String,\n\t\t\t\tattribute: 'bk-color',\n\t\t\t\tconverter: {\n\t\t\t\t\tfromAttribute: (value, type) => {\n\t\t\t\t\t\tconst s = new Option().style\n\t\t\t\t\t\ts.color = value\n\t\t\t\t\t\treturn s.color ? s.color : '#fff'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\ttileColor: {\n\t\t\t\ttype: String,\n\t\t\t\tattribute: 'tile-color',\n\t\t\t\tconverter: {\n\t\t\t\t\tfromAttribute: (value, type) => {\n\t\t\t\t\t\tconst s = new Option().style\n\t\t\t\t\t\ts.color = value\n\t\t\t\t\t\treturn s.color ? s.color : '#000'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\terrorCorrection: {\n\t\t\t\ttype: String,\n\t\t\t\tattribute: 'error-correction',\n\t\t\t\tconverter: {\n\t\t\t\t\tfromAttribute: (value, type) => {\n\n\t\t\t\t\t\tswitch (value.toLowerCase()) {\n\t\t\t\t\t\t\tcase 'low':\n\t\t\t\t\t\t\t\treturn Ecc.LOW\n\t\t\t\t\t\t\tcase 'medium':\n\t\t\t\t\t\t\t\treturn Ecc.MEDIUM\n\t\t\t\t\t\t\tcase 'quartile':\n\t\t\t\t\t\t\t\treturn Ecc.QUARTILE\n\t\t\t\t\t\t\tcase 'high':\n\t\t\t\t\t\t\t\treturn Ecc.HIGH\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn Ecc.MEDIUM\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tconstructor () {\n\t\tsuper()\n\n\t\t// default Qr settings\n\t\tthis.scale = 10\n\t\tthis.border =1\n\t\tthis.maskPatter = -1\n\t\tthis.errorCorrection = Ecc.MEDIUM\n\t\tthis.bkColor = '#fff'\n\t\tthis.tileColor = '#000'\n\n\t\tthis.graphicElement = 'svg'\n\t}\n\n\twillUpdate (changedProperties) {\n\n\t\t// listen for change in the attributes to compute new qr\n\t\tif (changedProperties.has('text') ||\n\t\t\tchangedProperties.has('graphicElement') ||\n\t\t\tchangedProperties.has('maskPattern') ||\n\t\t\tchangedProperties.has('errorCorrection') ||\n\t\t\tchangedProperties.has('bkColor') ||\n\t\t\tchangedProperties.has('tileColor') ||\n\t\t\tchangedProperties.has('scale') ||\n\t\t\tchangedProperties.has('border')\n\t\t\t) {\n\n\t\t\tconst qr = QrCode.encodeText(this.text, this.errorCorrection)\n\n\t\t\t// populate the svg element\n\t\t\tif (this.graphicElement === 'svg') {\n\n\t\t\t\tthis.svg = toSvgString(\n\t\t\t\t\tqr,\n\t\t\t\t\tthis.border,\n\t\t\t\t\tthis.bkColor,\n\t\t\t\t\tthis.tileColor\n\t\t\t\t)\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Show the QR Code symbol's statistics as a object\n\tgetStatistics () {\n\t\tconst qr = QrCode.encodeText(this.text, this.errorCorrection)\n\t\tconst segs = QrSegment.makeSegments(this.text)\n\n\t\tconst statistics = {\n\t\t\tqrVersion: qr.version,\n\t\t\tmaskPattern: qr.mask,\n\t\t\tcharacterCount: countUnicodeChars(this.text),\n\t\t\terrorCorrection: this.errorCorrection.ordinal,\n\t\t\tdataBits: Number(QrSegment.getTotalBits(segs, qr.version))\n\n\t\t}\n\n\t\treturn statistics\n\t}\n\n\trender () {\n\n\t\tif (this.graphicElement === 'canvas') {\n\n\t\t\tconst qr = QrCode.encodeText(this.text, this.errorCorrection)\n\n\t\t\tlet cvs = this.renderRoot.querySelector('canvas')\n\t\t\tif (!cvs) {\n\t\t\t\tcvs = document.createElement('canvas')\n\t\t\t\tthis.renderRoot.appendChild(cvs)\n\t\t\t}\n\t\t\t\n\t\t\tdrawOnCanvas(\n\t\t\t\tqr,\n\t\t\t\tthis.scale,\n\t\t\t\tthis.border,\n\t\t\t\tthis.bkColor,\n\t\t\t\tthis.tileColor,\n\t\t\t\tcvs\n\t\t\t)\n\n\t\t}\n\n\t\treturn html`\n\t\t\t${this.svg}\n\n\t\t\t<slot name=\"icon\"></slot>\n\t\t`\n\t}\n}\n\ncustomElements.define('qr-code-element', QrCodeElement)\n","/*\n * QR Code generator library Javascript v1.8.0 ES6\n *\n * Copyright (c) Project Nayuki. (MIT License)\n * https://www.nayuki.io/page/qr-code-generator-library\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided \"as is\", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\nimport { svg } from 'lit'\n\n/**\n * Returns the number of Unicode code points in the given UTF-16 string.\n * @param {String} str - Input string\n * @returns {Number}\n */\nconst countUnicodeChars = (str) => {\n\n    let result = 0\n    for (const ch of str) {\n        const cc = Number(ch.codePointAt(0))\n        if (0xD800 <= cc && cc < 0xE000)\n            throw new RangeError(\"Invalid UTF-16 string\")\n        result++\n    }\n\n    return result\n}\n\n/**\n * Appends the given number of low-order bits of the given value \n * to the given buffer. Requires 0 <= len <= 31 and 0 <= val < 2^len.\n * @param {*} val \n * @param {*} len\n * @param {*} bb \n */\nconst appendBits = (val, len, bb) => {\n    if (len < 0 || len > 31 || val >>> len != 0)\n        throw new RangeError(\"Value out of range\")\n    for (let i = len - 1; i >= 0; i--) // Append bit by bit\n        bb.push((val >>> i) & 1)\n}\n/**\n * Returns true iff the i'th bit of x is set to 1.\n * @param {*} x \n * @param {*} i \n * @returns \n */\nconst getBit = (x, i) => {\n    return ((x >>> i) & 1) != 0\n}\n/**\n * Throws an exception if the given condition is false.\n * @param {*} cond \n */\nconst assert = (cond) => {\n    if (!cond)\n        throw new Error(\"Assertion error\")\n}\n\n/* ---------------------------------- QrCode ------------------------------- */\nclass QrCode {\n    /**\n     * Constructor (low level) and fields.\n     * Creates new QR Code with the given version number, error correction\n     * level, data codeword bytes, and mask number. This is a low-level API\n     * t most users should not use directly. A mid-level API is encodeSegments()\n     * @param {number} version -    version number of this QR Code, between 1 and 40 (inclusive),\n     *                              This determines the size of this barcode.\n     * @param {*} errorCorrectionLevel - error correction level used in this QR Code.\n     * @param {*} dataCodewords \n     * @param {*} msk \n     */\n    constructor(\n    version, \n    errorCorrectionLevel, dataCodewords, msk) {\n        this.version = version\n        this.errorCorrectionLevel = errorCorrectionLevel\n\n        // The modules of this QR Code (false = light, true = dark).\n        // Immutable after constructor finishes. Accessed through getModule().\n        this.modules = []\n\n        // Indicates function modules that are not subjected to masking.\n        // Discarded when constructor finishes.\n        this.isFunction = []\n\n        // Check scalar arguments\n        if (version < QrCode.MIN_VERSION || version > QrCode.MAX_VERSION)\n            throw new RangeError(\"Version value out of range\")\n\n        if (msk < -1 || msk > 7)\n            throw new RangeError(\"Mask value out of range\")\n        \n        this.size = version * 4 + 17\n\n        // Initialize both grids to be size*size arrays of Boolean false\n        let row = []\n        for (let i = 0; i < this.size; i++)\n            row.push(false)\n        for (let i = 0; i < this.size; i++) {\n            this.modules.push(row.slice())   // Initially all light\n            this.isFunction.push(row.slice())\n        }\n        // Compute ECC, draw modules\n        this.drawFunctionPatterns()\n        const allCodewords = this.addEccAndInterleave(dataCodewords)\n        this.drawCodewords(allCodewords)\n        // Do masking\n        if (msk == -1) { // Automatically choose best mask\n            let minPenalty = 1000000000\n            for (let i = 0; i < 8; i++) {\n                this.applyMask(i)\n                this.drawFormatBits(i)\n                const penalty = this.getPenaltyScore()\n                if (penalty < minPenalty) {\n                    msk = i\n                    minPenalty = penalty\n                }\n                this.applyMask(i)    // Undoes the mask due to XOR\n            }\n        }\n        assert(0 <= msk && msk <= 7)\n        this.mask = msk\n        this.applyMask(msk)     // Apply the final choice of mask\n        this.drawFormatBits(msk)       // Overwrite old format bits\n        this.isFunction = []\n    }\n\n    /*-- Static factory functions (high level) --*/\n    // Returns a QR Code representing the given Unicode text string at the given error correction level.\n    // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer\n    // Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible\n    // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the\n    // ecl argument if it can be done without increasing the version.\n    static encodeText(text, ecl) {\n        const segs = QrSegment.makeSegments(text)\n        return QrCode.encodeSegments(segs, ecl)\n    }\n\n    // Returns a QR Code representing the given binary data at the given error correction level.\n    // This function always encodes using the binary segment mode, not any text mode. The maximum number of\n    // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.\n    // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.\n    static encodeBinary(data, ecl) {\n        const seg = QrSegment.makeBytes(data)\n        return QrCode.encodeSegments([seg], ecl)\n    }\n\n    /*-- Static factory functions (mid level) --*/\n    // Returns a QR Code representing the given segments with the given encoding parameters.\n    // The smallest possible QR Code version within the given range is automatically\n    // chosen for the output. Iff boostEcl is true, then the ECC level of the result\n    // may be higher than the ecl argument if it can be done without increasing the\n    // version. The mask number is either between 0 to 7 (inclusive) to force that\n    // mask, or -1 to automatically choose an appropriate mask (which may be slow).\n    // This function allows the user to create a custom sequence of segments that switches\n    // between modes (such as alphanumeric and byte) to encode text in less space.\n    // This is a mid-level API; the high-level API is encodeText() and encodeBinary().\n    static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {\n        if (!(QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode.MAX_VERSION)\n            || mask < -1 || mask > 7)\n            throw new RangeError(\"Invalid value\")\n\n        // Find the minimal version number to use\n        let version\n        let dataUsedBits\n        for (version = minVersion;; version++) {\n            const dataCapacityBits = QrCode.getNumDataCodewords(version, ecl) * 8   // Number of data bits available\n            const usedBits = QrSegment.getTotalBits(segs, version)\n            if (usedBits <= dataCapacityBits) {\n                dataUsedBits = usedBits\n                break   // This version number is found to be suitable\n            }\n            if (version >= maxVersion)  // All versions in the range could not fit the given data\n                throw new RangeError(\"Data too long\")\n        }\n\n        // Increase the error correction level while the data still fits in the current version number\n        for (const newEcl of [Ecc.MEDIUM, Ecc.QUARTILE, Ecc.HIGH]) {   // From low to high\n            if (boostEcl && dataUsedBits <= QrCode.getNumDataCodewords(version, newEcl) * 8)\n                ecl = newEcl\n        }\n\n        // Concatenate all segments to create the data bit string\n        let bb = []\n        for (const seg of segs) {\n            appendBits(seg.mode.modeBits, 4, bb)\n            appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb)\n            for (const b of seg.getData())\n                bb.push(b)\n        }\n\n        assert(bb.length == dataUsedBits)\n        // Add terminator and pad up to a byte if applicable\n        const dataCapacityBits = QrCode.getNumDataCodewords(version, ecl) * 8\n        assert(bb.length <= dataCapacityBits)\n        appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb)\n        appendBits(0, (8 - bb.length % 8) % 8, bb)\n        assert(bb.length % 8 == 0)\n\n        // Pad with alternating bytes until data capacity is reached\n        for (let padByte = 0xEC; bb.length < dataCapacityBits; padByte ^= 0xEC ^ 0x11)\n            appendBits(padByte, 8, bb)\n\n        // Pack bits into bytes in big endian\n        let dataCodewords = []\n        while (dataCodewords.length * 8 < bb.length)\n            dataCodewords.push(0)\n\n        bb.forEach((b, i) => dataCodewords[i >>> 3] |= b << (7 - (i & 7)))\n\n        // Create the QR Code object\n        return new QrCode(version, ecl, dataCodewords, mask)\n    }\n\n    /*-- Accessor methods --*/\n    // Returns the color of the module (pixel) at the given coordinates, which is false\n    // for light or true for dark. The top left corner has the coordinates (x=0, y=0).\n    // If the given coordinates are out of bounds, then false (light) is returned.\n    getModule(x, y) {\n        return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x]\n    }\n\n    /*-- Private helper methods for constructor: Drawing function modules --*/\n    // Reads this object's version field, and draws and marks all function modules.\n    drawFunctionPatterns() {\n        // Draw horizontal and vertical timing patterns\n        for (let i = 0; i < this.size; i++) {\n            this.setFunctionModule(6, i, i % 2 == 0)\n            this.setFunctionModule(i, 6, i % 2 == 0)\n        }\n\n        // Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)\n        this.drawFinderPattern(3, 3)\n        this.drawFinderPattern(this.size - 4, 3)\n        this.drawFinderPattern(3, this.size - 4)\n\n        // Draw numerous alignment patterns\n        const alignPatPos = this.getAlignmentPatternPositions()\n        const numAlign = alignPatPos.length\n\n        for (let i = 0; i < numAlign; i++) {\n            for (let j = 0; j < numAlign; j++) {\n                // Don't draw on the three finder corners\n                if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0))\n                    this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j])\n            }\n        }\n\n        // Draw configuration data\n        this.drawFormatBits(0)  // Dummy mask value; overwritten later in the constructor\n        this.drawVersion()\n    }\n\n    // Draws two copies of the format bits (with its own error correction code)\n    // based on the given mask and this object's error correction level field.\n    drawFormatBits(mask) {\n        // Calculate error correction code and pack bits\n        const data = this.errorCorrectionLevel.formatBits << 3 | mask   // errCorrLvl is uint2, mask is uint3\n        let rem = data\n\n        for (let i = 0; i < 10; i++)\n            rem = (rem << 1) ^ ((rem >>> 9) * 0x537)\n\n        const bits = (data << 10 | rem) ^ 0x5412    // uint15\n        assert(bits >>> 15 == 0)\n\n        // Draw first copy\n        for (let i = 0; i <= 5; i++)\n            this.setFunctionModule(8, i, getBit(bits, i))\n\n        this.setFunctionModule(8, 7, getBit(bits, 6))\n        this.setFunctionModule(8, 8, getBit(bits, 7))\n        this.setFunctionModule(7, 8, getBit(bits, 8))\n\n        for (let i = 9; i < 15; i++)\n            this.setFunctionModule(14 - i, 8, getBit(bits, i))\n\n        // Draw second copy\n        for (let i = 0; i < 8; i++)\n            this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i))\n\n        for (let i = 8; i < 15; i++)\n            this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i))\n\n        this.setFunctionModule(8, this.size - 8, true)  // Always dark\n    }\n\n    // Draws two copies of the version bits (with its own error correction code),\n    // based on this object's version field, iff 7 <= version <= 40.\n    drawVersion() {\n        if (this.version < 7)\n            return\n\n        // Calculate error correction code and pack bits\n        let rem = this.version  // version is uint6, in the range [7, 40]\n        for (let i = 0; i < 12; i++)\n            rem = (rem << 1) ^ ((rem >>> 11) * 0x1F25)\n\n        const bits = this.version << 12 | rem   // uint18\n        assert(bits >>> 18 == 0)\n\n        // Draw two copies\n        for (let i = 0; i < 18; i++) {\n            const color = getBit(bits, i)\n            const a = this.size - 11 + i % 3\n            const b = Math.floor(i / 3)\n\n            this.setFunctionModule(a, b, color)\n            this.setFunctionModule(b, a, color)\n        }\n    }\n\n    // Draws a 9*9 finder pattern including the border separator,\n    // with the center module at (x, y). Modules can be out of bounds.\n    drawFinderPattern(x, y) {\n        for (let dy = -4; dy <= 4; dy++) {\n            for (let dx = -4; dx <= 4; dx++) {\n                const dist = Math.max(Math.abs(dx), Math.abs(dy))   // Chebyshev/infinity norm\n                const xx = x + dx\n                const yy = y + dy\n                if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)\n                    this.setFunctionModule(xx, yy, dist != 2 && dist != 4)\n            }\n        }\n    }\n\n    // Draws a 5*5 alignment pattern, with the center module\n    // at (x, y). All modules must be in bounds.\n    drawAlignmentPattern(x, y) {\n        for (let dy = -2; dy <= 2; dy++) {\n            for (let dx = -2; dx <= 2; dx++)\n                this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1)\n        }\n    }\n\n    // Sets the color of a module and marks it as a function module.\n    // Only used by the constructor. Coordinates must be in bounds.\n    setFunctionModule(x, y, isDark) {\n        this.modules[y][x] = isDark\n        this.isFunction[y][x] = true\n    }\n\n    /*-- Private helper methods for constructor: Codewords and masking --*/\n    // Returns a new byte string representing the given data with the appropriate error correction\n    // codewords appended to it, based on this object's version and error correction level.\n    addEccAndInterleave(data) {\n        const ver = this.version\n        const ecl = this.errorCorrectionLevel\n        if (data.length != QrCode.getNumDataCodewords(ver, ecl))\n            throw new RangeError(\"Invalid argument\")\n\n        // Calculate parameter numbers\n        const numBlocks = QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver]\n        const blockEccLen = QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver]\n        const rawCodewords = Math.floor(QrCode.getNumRawDataModules(ver) / 8)\n        const numShortBlocks = numBlocks - rawCodewords % numBlocks\n        const shortBlockLen = Math.floor(rawCodewords / numBlocks)\n\n        // Split data into blocks and append ECC to each block\n        let blocks = []\n        const rsDiv = QrCode.reedSolomonComputeDivisor(blockEccLen)\n\n        for (let i = 0, k = 0; i < numBlocks; i++) {\n            let dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1))\n            k += dat.length\n            const ecc = QrCode.reedSolomonComputeRemainder(dat, rsDiv)\n\n            if (i < numShortBlocks)\n                dat.push(0)\n\n            blocks.push(dat.concat(ecc))\n        }\n\n        // Interleave (not concatenate) the bytes from every block into a single sequence\n        let result = []\n\n        for (let i = 0; i < blocks[0].length; i++) {\n            blocks.forEach((block, j) => {\n                // Skip the padding byte in short blocks\n                if (i != shortBlockLen - blockEccLen || j >= numShortBlocks)\n                    result.push(block[i])\n            })\n        }\n\n        assert(result.length == rawCodewords)\n        return result\n    }\n\n    // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire\n    // data area of this QR Code. Function modules need to be marked off before this is called.\n    drawCodewords(data) {\n        if (data.length != Math.floor(QrCode.getNumRawDataModules(this.version) / 8))\n            throw new RangeError(\"Invalid argument\")\n\n        let i = 0   // Bit index into the data\n\n        // Do the funny zigzag scan\n        for (let right = this.size - 1; right >= 1; right -= 2) { // Index of right column in each column pair\n            if (right == 6)\n                right = 5\n\n            for (let vert = 0; vert < this.size; vert++) { // Vertical counter\n                for (let j = 0; j < 2; j++) {\n\n                    const x = right - j // Actual x coordinate\n                    const upward = ((right + 1) & 2) == 0\n                    const y = upward ? this.size - 1 - vert : vert  // Actual y coordinate\n\n                    if (!this.isFunction[y][x] && i < data.length * 8) {\n                        this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7))\n                        i++\n                    }\n                    // If this QR Code has any remainder bits (0 to 7), they were assigned as\n                    // 0/false/light by the constructor and are left unchanged by this method\n                }\n            }\n        }\n        assert(i == data.length * 8)\n    }\n\n    // XORs the codeword modules in this QR Code with the given mask pattern.\n    // The function modules must be marked and the codeword bits must be drawn\n    // before masking. Due to the arithmetic of XOR, calling applyMask() with\n    // the same mask value a second time will undo the mask. A final well-formed\n    // QR Code needs exactly one (not zero, two, etc.) mask applied.\n    applyMask(mask) {\n        if (mask < 0 || mask > 7)\n            throw new RangeError(\"Mask value out of range\")\n        for (let y = 0; y < this.size; y++) {\n            for (let x = 0; x < this.size; x++) {\n                let invert\n                switch (mask) {\n                    case 0:\n                        invert = (x + y) % 2 == 0\n                        break\n                    case 1:\n                        invert = y % 2 == 0\n                        break\n                    case 2:\n                        invert = x % 3 == 0\n                        break\n                    case 3:\n                        invert = (x + y) % 3 == 0\n                        break\n                    case 4:\n                        invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0\n                        break\n                    case 5:\n                        invert = x * y % 2 + x * y % 3 == 0\n                        break\n                    case 6:\n                        invert = (x * y % 2 + x * y % 3) % 2 == 0\n                        break\n                    case 7:\n                        invert = ((x + y) % 2 + x * y % 3) % 2 == 0\n                        break\n                    default: throw new Error(\"Unreachable\")\n                }\n                if (!this.isFunction[y][x] && invert)\n                    this.modules[y][x] = !this.modules[y][x]\n            }\n        }\n    }\n\n    // Calculates and returns the penalty score based on state of this QR Code's current modules.\n    // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.\n    getPenaltyScore() {\n        let result = 0\n        // Adjacent modules in row having same color, and finder-like patterns\n        for (let y = 0; y < this.size; y++) {\n\n            let runColor = false\n            let runX = 0\n            let runHistory = [0, 0, 0, 0, 0, 0, 0]\n\n            for (let x = 0; x < this.size; x++) {\n                if (this.modules[y][x] == runColor) {\n                    runX++\n\n                    if (runX == 5)\n                        result += QrCode.PENALTY_N1\n                    else if (runX > 5)\n                        result++\n\n                } else {\n                    this.finderPenaltyAddHistory(runX, runHistory)\n\n                    if (!runColor)\n                        result += this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3\n\n                    runColor = this.modules[y][x]\n                    runX = 1\n                }\n            }\n\n            result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * QrCode.PENALTY_N3\n        }\n\n        // Adjacent modules in column having same color, and finder-like patterns\n        for (let x = 0; x < this.size; x++) {\n\n            let runColor = false\n            let runY = 0\n            let runHistory = [0, 0, 0, 0, 0, 0, 0]\n\n            for (let y = 0; y < this.size; y++) {\n                if (this.modules[y][x] == runColor) {\n                    runY++\n                    if (runY == 5)\n                        result += QrCode.PENALTY_N1\n                    else if (runY > 5)\n                        result++\n                } else {\n                    this.finderPenaltyAddHistory(runY, runHistory)\n                    if (!runColor)\n                        result += this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3\n                    runColor = this.modules[y][x]\n                    runY = 1\n                }\n            }\n\n            result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * QrCode.PENALTY_N3\n        }\n\n        // 2*2 blocks of modules having same color\n        for (let y = 0; y < this.size - 1; y++) {\n            for (let x = 0; x < this.size - 1; x++) {\n                const color = this.modules[y][x]\n                if (color == this.modules[y][x + 1] &&\n                    color == this.modules[y + 1][x] &&\n                    color == this.modules[y + 1][x + 1])\n                    result += QrCode.PENALTY_N2\n            }\n        }\n\n        // Balance of dark and light modules\n        let dark = 0\n        for (const row of this.modules)\n            dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark)\n        const total = this.size * this.size; // Note that size is odd, so dark/total != 1/2\n        // Compute the smallest integer k >= 0 such that (45-5k)% <= dark/total <= (55+5k)%\n        const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1\n        assert(0 <= k && k <= 9)\n        result += k * QrCode.PENALTY_N4\n        assert(0 <= result && result <= 2568888)    // Non-tight upper bound based on default values of PENALTY_N1, ..., N4\n        return result\n    }\n\n    /*-- Private helper functions --*/\n    // Returns an ascending list of positions of alignment patterns for this version number.\n    // Each position is in the range [0,177), and are used on both the x and y axes.\n    // This could be implemented as lookup table of 40 variable-length lists of integers.\n    getAlignmentPatternPositions() {\n        if (this.version == 1)\n            return []\n        else {\n            const numAlign = Math.floor(this.version / 7) + 2\n            const step = (this.version == 32) ? 26 :\n                Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2\n\n            let result = [6]\n\n            for (let pos = this.size - 7; result.length < numAlign; pos -= step)\n                result.splice(1, 0, pos)\n\n            return result\n        }\n    }\n\n    // Returns the number of data bits that can be stored in a QR Code of the given version number, after\n    // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.\n    // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.\n    static getNumRawDataModules(ver) {\n        if (ver < QrCode.MIN_VERSION || ver > QrCode.MAX_VERSION)\n            throw new RangeError(\"Version number out of range\")\n        let result = (16 * ver + 128) * ver + 64\n        if (ver >= 2) {\n            const numAlign = Math.floor(ver / 7) + 2\n            result -= (25 * numAlign - 10) * numAlign - 55\n            if (ver >= 7)\n                result -= 36\n        }\n        assert(208 <= result && result <= 29648)\n\n        return result\n    }\n\n    // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any\n    // QR Code of the given version number and error correction level, with remainder bits discarded.\n    // This stateless pure function could be implemented as a (40*4)-cell lookup table.\n    static getNumDataCodewords(ver, ecl) {\n        return Math.floor(QrCode.getNumRawDataModules(ver) / 8) -\n            QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] *\n                QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver]\n    }\n\n    // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be\n    // implemented as a lookup table over all possible parameter values, instead of as an algorithm.\n    static reedSolomonComputeDivisor(degree) {\n        if (degree < 1 || degree > 255)\n            throw new RangeError(\"Degree out of range\")\n        // Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.\n        // For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the uint8 array [255, 8, 93].\n        let result = []\n        for (let i = 0; i < degree - 1; i++)\n            result.push(0)\n        result.push(1)  // Start off with the monomial x^0\n\n        // Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),\n        // and drop the highest monomial term which is always 1x^degree.\n        // Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).\n        let root = 1\n\n        for (let i = 0; i < degree; i++) {\n            // Multiply the current product by (x - r^i)\n            for (let j = 0; j < result.length; j++) {\n                result[j] = QrCode.reedSolomonMultiply(result[j], root);\n                if (j + 1 < result.length)\n                    result[j] ^= result[j + 1]\n            }\n\n            root = QrCode.reedSolomonMultiply(root, 0x02)\n        }\n        return result\n    }\n\n    // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.\n    static reedSolomonComputeRemainder(data, divisor) {\n        let result = divisor.map(_ => 0)\n        for (const b of data) { // Polynomial division\n            const factor = b ^ result.shift()\n            result.push(0)\n            divisor.forEach((coef, i) => result[i] ^= QrCode.reedSolomonMultiply(coef, factor))\n        }\n        return result\n    }\n\n    // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result\n    // are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.\n    static reedSolomonMultiply(x, y) {\n        if (x >>> 8 != 0 || y >>> 8 != 0)\n            throw new RangeError(\"Byte out of range\")\n        // Russian peasant multiplication\n        let z = 0\n        for (let i = 7; i >= 0; i--) {\n            z = (z << 1) ^ ((z >>> 7) * 0x11D)\n            z ^= ((y >>> i) & 1) * x\n        }\n        assert(z >>> 8 == 0)\n        return z\n    }\n\n    // Can only be called immediately after a light run is added, and\n    // returns either 0, 1, or 2. A helper function for getPenaltyScore().\n    finderPenaltyCountPatterns(runHistory) {\n        const n = runHistory[1]\n        assert(n <= this.size * 3)\n        const core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n\n\n        return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0)\n            + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0)\n    }\n\n    // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().\n    finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {\n        if (currentRunColor) { // Terminate dark run\n            this.finderPenaltyAddHistory(currentRunLength, runHistory)\n            currentRunLength = 0\n        }\n\n        currentRunLength += this.size   // Add light border to final run\n        this.finderPenaltyAddHistory(currentRunLength, runHistory)\n        return this.finderPenaltyCountPatterns(runHistory)\n    }\n\n    // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().\n    finderPenaltyAddHistory(currentRunLength, runHistory) {\n        if (runHistory[0] == 0)\n            currentRunLength += this.size   // Add light border to initial run\n        runHistory.pop()\n        runHistory.unshift(currentRunLength)\n    }\n}\n\n/* ----------------------------- QrCode Constants -------------------------- */\n// The minimum version number supported in the QR Code Model 2 standard.\nQrCode.MIN_VERSION = 1\n// The maximum version number supported in the QR Code Model 2 standard.\nQrCode.MAX_VERSION = 40\n// For use in getPenaltyScore(), when evaluating which mask is best.\nQrCode.PENALTY_N1 = 3\nQrCode.PENALTY_N2 = 3\nQrCode.PENALTY_N3 = 40\nQrCode.PENALTY_N4 = 10\nQrCode.ECC_CODEWORDS_PER_BLOCK = [\n    // Version: (note that index 0 is for padding, and is set to an illegal value)\n    //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n    [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n    [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],\n    [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n    [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], // High\n]\nQrCode.NUM_ERROR_CORRECTION_BLOCKS = [\n    // Version: (note that index 0 is for padding, and is set to an illegal value)\n    //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n    [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],\n    [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],\n    [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],\n    [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81], // High\n]\n\n\n/* --------------------------------- QrSegment ----------------------------- */\n/*\n* A segment of character/binary/control data in a QR Code symbol.\n* Instances of this class are immutable.\n* The mid-level way to create a segment is to take the payload data\n* and call a static factory function such as QrSegment.makeNumeric().\n* The low-level way to create a segment is to custom-make the bit buffer\n* and call the QrSegment() constructor with appropriate values.\n* This segment class imposes no length restrictions, but QR Codes have restrictions.\n* Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.\n* Any segment longer than this is meaningless for the purpose of generating QR Codes.\n*/\nclass QrSegment {\n    /*-- Constructor (low level) and fields --*/\n    // Creates a new QR Code segment with the given attributes and data.\n    // The character count (numChars) must agree with the mode and the bit buffer length,\n    // but the constraint isn't checked. The given bit buffer is cloned and stored.\n    constructor(\n    // The mode indicator of this segment.\n    mode, \n    // The length of this segment's unencoded data. Measured in characters for\n    // numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.\n    // Always zero or positive. Not the same as the data's bit length.\n    numChars, \n    // The data bits of this segment. Accessed through getData().\n    bitData) {\n        this.mode = mode\n        this.numChars = numChars\n        this.bitData = bitData\n        if (numChars < 0)\n            throw new RangeError(\"Invalid argument\")\n        this.bitData = bitData.slice()  // Make defensive copy\n    }\n\n    /*-- Static factory functions (mid level) --*/\n    // Returns a segment representing the given binary data encoded in\n    // byte mode. All input byte arrays are acceptable. Any text string\n    // can be converted to UTF-8 bytes and encoded as a byte mode segment.\n    static makeBytes(data) {\n        let bb = []\n        for (const b of data)\n            appendBits(b, 8, bb)\n\n        return new QrSegment(Mode.BYTE, data.length, bb)\n    }\n\n    // Returns a segment representing the given string of decimal digits encoded in numeric mode.\n    static makeNumeric(digits) {\n        if (!QrSegment.isNumeric(digits))\n            throw new RangeError(\"String contains non-numeric characters\")\n\n        let bb = []\n\n        for (let i = 0; i < digits.length;) { // Consume up to 3 digits per iteration\n            const n = Math.min(digits.length - i, 3)\n            appendBits(parseInt(digits.substr(i, n), 10), n * 3 + 1, bb)\n            i += n\n        }\n\n        return new QrSegment(Mode.NUMERIC, digits.length, bb)\n    }\n\n    // Returns a segment representing the given text string encoded in alphanumeric mode.\n    // The characters allowed are: 0 to 9, A to Z (uppercase only), space,\n    // dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n    static makeAlphanumeric(text) {\n        if (!QrSegment.isAlphanumeric(text))\n            throw new RangeError(\"String contains unencodable characters in alphanumeric mode\")\n\n        let bb = []\n        let i\n\n        for (i = 0; i + 2 <= text.length; i += 2) { // Process groups of 2\n            let temp = QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45\n            temp += QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1))\n            appendBits(temp, 11, bb)\n        }\n\n        if (i < text.length) // 1 character remaining\n            appendBits(QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb)\n        return new QrSegment(Mode.ALPHANUMERIC, text.length, bb)\n    }\n\n    // Returns a new mutable list of zero or more segments to represent the given Unicode text string.\n    // The result may use various segment modes and switch modes to optimize the length of the bit stream.\n    static makeSegments(text) {\n        // Select the most efficient segment encoding automatically\n        if (text == \"\")\n            return []\n        else if (QrSegment.isNumeric(text))\n            return [QrSegment.makeNumeric(text)]\n        else if (QrSegment.isAlphanumeric(text))\n            return [QrSegment.makeAlphanumeric(text)]\n        else\n            return [QrSegment.makeBytes(QrSegment.toUtf8ByteArray(text))]\n    }\n\n    // Returns a segment representing an Extended Channel Interpretation\n    // (ECI) designator with the given assignment value.\n    static makeEci(assignVal) {\n        let bb = [];\n        if (assignVal < 0)\n            throw new RangeError(\"ECI assignment value out of range\")\n        else if (assignVal < (1 << 7))\n            appendBits(assignVal, 8, bb)\n        else if (assignVal < (1 << 14)) {\n            appendBits(0b10, 2, bb)\n            appendBits(assignVal, 14, bb)\n        }\n        else if (assignVal < 1000000) {\n            appendBits(0b110, 3, bb)\n            appendBits(assignVal, 21, bb)\n        }\n        else\n            throw new RangeError(\"ECI assignment value out of range\")\n        return new QrSegment(QrSegment.Mode.ECI, 0, bb)\n    }\n\n    // Tests whether the given string can be encoded as a segment in numeric mode.\n    // A string is encodable iff each character is in the range 0 to 9.\n    static isNumeric(text) {\n        return QrSegment.NUMERIC_REGEX.test(text)\n    }\n\n    // Tests whether the given string can be encoded as a segment in alphanumeric mode.\n    // A string is encodable iff each character is in the following set: 0 to 9, A to Z\n    // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n    static isAlphanumeric(text) {\n        return QrSegment.ALPHANUMERIC_REGEX.test(text)\n    }\n\n    /*-- Methods --*/\n    // Returns a new copy of the data bits of this segment.\n    getData() {\n        return this.bitData.slice() // Make defensive copy\n    }\n\n    // (Package-private) Calculates and returns the number of bits needed to encode the given segments at\n    // the given version. The result is infinity if a segment has too many characters to fit its length field.\n    static getTotalBits(segs, version) {\n\n        let result = 0\n\n        for (const seg of segs) {\n            const ccbits = seg.mode.numCharCountBits(version)\n            if (seg.numChars >= (1 << ccbits))\n                return Infinity // The segment's length doesn't fit the field's bit width\n            result += 4 + ccbits + seg.bitData.length\n        }\n        return result\n    }\n\n    // Returns a new array of bytes representing the given string encoded in UTF-8.\n    static toUtf8ByteArray(str) {\n\n        str = encodeURI(str)\n        let result = []\n\n        for (let i = 0; i < str.length; i++) {\n            if (str.charAt(i) != \"%\")\n                result.push(str.charCodeAt(i))\n            else {\n                result.push(parseInt(str.substr(i + 1, 2), 16))\n                i += 2\n            }\n        }\n        return result\n    }\n\n}\n\n/* ---------------------------- QrSegment Constants ------------------------ */\n// Describes precisely all strings that are encodable in numeric mode.\nQrSegment.NUMERIC_REGEX = /^[0-9]*$/;\n// Describes precisely all strings that are encodable in alphanumeric mode.\nQrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\\/:-]*$/;\n// The set of all legal characters in alphanumeric mode,\n// where each character value maps to the index in the string.\nQrSegment.ALPHANUMERIC_CHARSET = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\"\n\n/* ---------------------------------- Ecc ---------------------------------- */\n/*\n* The error correction level in a QR Code symbol. Immutable.\n*/\nclass Ecc {\n    /*-- Constructor and fields --*/\n    constructor(\n    // In the range 0 to 3 (unsigned 2-bit integer).\n    ordinal, \n    // (Package-private) In the range 0 to 3 (unsigned 2-bit integer).\n    formatBits) {\n        this.ordinal = ordinal\n        this.formatBits = formatBits\n    }\n}\n\n/* ---------------------------- Ecc Constants ------------------------------ */\nEcc.LOW = new Ecc(0, 1) // The QR Code can tolerate about  7% erroneous codewords\nEcc.MEDIUM = new Ecc(1, 0)  // The QR Code can tolerate about 15% erroneous codewords\nEcc.QUARTILE = new Ecc(2, 3)    // The QR Code can tolerate about 25% erroneous codewords\nEcc.HIGH = new Ecc(3, 2)    // The QR Code can tolerate about 30% erroneous codewords\n\n/* --------------------------------- Mode ---------------------------------- */\n/*\n* Describes how a segment's data bits are interpreted. Immutable.\n*/\nclass Mode {\n    /*-- Constructor and fields --*/\n    constructor(\n    // The mode indicator bits, which is a uint4 value (range 0 to 15).\n    modeBits, \n    // Number of character count bits for three different version ranges.\n    numBitsCharCount) {\n        this.modeBits = modeBits\n        this.numBitsCharCount = numBitsCharCount\n    }\n    /*-- Method --*/\n    // (Package-private) Returns the bit width of the character count field for a segment in\n    // this mode in a QR Code at the given version number. The result is in the range [0, 16].\n    numCharCountBits(ver) {\n        return this.numBitsCharCount[Math.floor((ver + 7) / 17)]\n    }\n}\n\n/* -------------------------- Mode Constants ------------------------------- */\nMode.NUMERIC = new Mode(0x1, [10, 12, 14])\nMode.ALPHANUMERIC = new Mode(0x2, [9, 11, 13])\nMode.BYTE = new Mode(0x4, [8, 16, 16])\nMode.KANJI = new Mode(0x8, [8, 10, 12])\nMode.ECI = new Mode(0x7, [0, 0, 0])\n\n/**\n * \n * @param {QrCode} qr - QrCode object get from eg. QrCode.encodeText\n * @param {Number} scale - Number of the scale of qr, handling the size\n * @param {Number} border - Number >= 0, thickness of the border of Qr\n * @param {String} lightColor - Color for QrCode background\n * @param {String} darkColor - Color fot tiles of QrCode\n * @param {HTMLCanvasElement} canvas - The Canvas that will be draw with QrCode\n */\nconst drawOnCanvas = (\n    qr,\n    scale,\n    border,\n    lightColor,\n    darkColor,\n    canvas\n    ) => {\n\n    if (scale <= 0 || border < 0) {\n        throw new RangeError('@RangeError >> scale or border values')\n    }\n\n    const width = (qr.size + border * 2) * scale\n    canvas.width = width\n    canvas.height = width\n\n    const ctx = canvas.getContext('2d')\n\n    for(let y = -border; y < qr.size + border; y++) {\n        for (let x = -border; x < qr.size + border; x++) {\n        ctx.fillStyle = qr.getModule(x, y) ? darkColor : lightColor\n        ctx.fillRect((x + border) * scale, (y + border) * scale, scale, scale)\n        }\n    }\n\n}\n\n// Returns a string of SVG code for an image depicting the given QR Code, with the given number\n\t// of border modules. The string always uses Unix newlines (\\n), regardless of the platform.\n\n/**\n * \n * @param {QrCode} qr - QrCode Object get from eg. QrCode.encodeText\n * @param {Number} border - Number >= 0, thickness of the border of Qr\n * @param {String} lightColor - Color for QrCode background\n * @param {String} darkColor - Color for QrCode background\n * @returns {String} - String with the SVG code of the QrCode\n */\nconst toSvgString = (\n    qr,\n    border,\n    lightColor,\n    darkColor\n    ) => {\n\n    if (border < 0)\n        throw new RangeError('@BORDER >> must be non-negative')\n\n    let parts = []\n    for (let y = 0; y < qr.size; y++) {\n        for (let x = 0; x < qr.size; x++) {\n\n            if (qr.getModule(x, y)) {\n                parts.push(`M${x + border},${y + border}h1v1h-1z`)\n            }\n\n        }\n    }\n    \n    return svg`<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 ${qr.size + border * 2} ${qr.size + border * 2}\" stroke=\"none\">\n<rect width=\"100%\" height=\"100%\" fill=\"${lightColor}\"/>\n<path d=\"${parts.join(\" \")}\" fill=\"${darkColor}\"/>\n</svg>\n`\n}\n\nexport { QrCode, QrSegment, Ecc, countUnicodeChars, drawOnCanvas, toSvgString }","import { unsafeCSS } from 'lit-element';\nexport const displayFlex = unsafeCSS `\n  display: -ms-flexbox;\n  display: -webkit-flex;\n  display: flex;\n`;\nexport const borderBox = unsafeCSS `\n  box-sizing: border-box;\n`;\nexport const displayInlineFlex = unsafeCSS `\n  display: -ms-inline-flexbox;\n  display: -webkit-inline-flex;\n  display: inline-flex;\n`;\nexport const horizontal = unsafeCSS `\n  -ms-flex-direction: row;\n  -webkit-flex-direction: row;\n  flex-direction: row;\n`;\nexport const vertical = unsafeCSS `\n  -ms-flex-direction: column;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n`;\nexport const wrap = unsafeCSS `\n  -ms-flex-wrap: wrap;\n  -webkit-flex-wrap: wrap;\n  flex-wrap: wrap;\n`;\nexport const noWrap = unsafeCSS `\n  -ms-flex-wrap: nowrap;\n  -webkit-flex-wrap: nowrap;\n  flex-wrap: nowrap;\n`;\nexport const flexFactor = unsafeCSS `\n  -ms-flex: 1 1 0.000000001px;\n  -webkit-flex: 1;\n  flex: 1;\n  -webkit-flex-basis: 0.000000001px;\n  flex-basis: 0.000000001px;\n`;\nexport const flexFactorAuto = unsafeCSS `\n  -ms-flex: 1 1 auto;\n  -webkit-flex: 1 1 auto;\n  flex: 1 1 auto;\n`;\nexport const flexFactorNone = unsafeCSS `\n  -ms-flex: 1 1 auto;\n  -webkit-flex: 1 1 auto;\n  flex: 1 1 auto;\n`;\nexport const displayNone = unsafeCSS `\n  display: none !important;\n`;\nexport const flex2 = unsafeCSS `\n  -ms-flex: 2;\n  -webkit-flex: 2;\n  flex: 2;\n`;\nexport const flex3 = unsafeCSS `\n  -ms-flex: 3;\n  -webkit-flex: 3;\n  flex: 3;\n`;\nexport const flex4 = unsafeCSS `\n  -ms-flex: 4;\n  -webkit-flex: 4;\n  flex: 4;\n`;\nexport const flex5 = unsafeCSS `\n  -ms-flex: 5;\n  -webkit-flex: 5;\n  flex: 5;\n`;\nexport const flex6 = unsafeCSS `\n  -ms-flex: 6;\n  -webkit-flex: 6;\n  flex: 6;\n`;\nexport const flex7 = unsafeCSS `\n  -ms-flex: 7;\n  -webkit-flex: 7;\n  flex: 7;\n`;\nexport const flex8 = unsafeCSS `\n  -ms-flex: 8;\n  -webkit-flex: 8;\n  flex: 8;\n`;\nexport const flex9 = unsafeCSS `\n  -ms-flex: 9;\n  -webkit-flex: 9;\n  flex: 9;\n`;\nexport const flex10 = unsafeCSS `\n  -ms-flex: 10;\n  -webkit-flex: 10;\n  flex: 10;\n`;\nexport const flex11 = unsafeCSS `\n  -ms-flex: 11;\n  -webkit-flex: 11;\n  flex: 11;\n`;\nexport const flex12 = unsafeCSS `\n  -ms-flex: 12;\n  -webkit-flex: 12;\n  flex: 12;\n`;\nexport const horizontalReverse = unsafeCSS `\n  -ms-flex-direction: row-reverse;\n  -webkit-flex-direction: row-reverse;\n  flex-direction: row-reverse;\n`;\nexport const verticalReverse = unsafeCSS `\n  -ms-flex-direction: column-reverse;\n  -webkit-flex-direction: column-reverse;\n  flex-direction: column-reverse;\n`;\nexport const wrapReverse = unsafeCSS `\n  -ms-flex-wrap: wrap-reverse;\n  -webkit-flex-wrap: wrap-reverse;\n  flex-wrap: wrap-reverse;\n`;\nexport const displayBlock = unsafeCSS `\n  display: block;\n`;\nexport const invisible = unsafeCSS `\n  visibility: hidden !important;\n`;\nexport const relative = unsafeCSS `\n  position: relative;\n`;\nexport const fit = unsafeCSS `\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n`;\nexport const scroll = unsafeCSS `\n  -webkit-overflow-scrolling: touch;\n  overflow: auto;\n`;\nexport const fixed = unsafeCSS `\n  position: fixed;\n`;\nexport const fixedTop = unsafeCSS `\n  top: 0;\n  left: 0;\n  right: 0;\n`;\nexport const fixedRight = unsafeCSS `\n  top: 0;\n  right: 0;\n  bottom: 0;\n`;\nexport const fixedLeft = unsafeCSS `\n  top: 0;\n  bottom: 0;\n  left: 0;\n`;\nexport const fixedBottom = unsafeCSS `\n  right: 0;\n  bottom: 0;\n  left: 0;\n`;\nexport const startAligned = unsafeCSS `\n  -ms-flex-align: start;\n  -webkit-align-items: flex-start;\n  align-items: flex-start;\n`;\nexport const centerAligned = unsafeCSS `\n  -ms-flex-align: center;\n  -webkit-align-items: center;\n  align-items: center;\n`;\nexport const endAligned = unsafeCSS `\n  -ms-flex-align: end;\n  -webkit-align-items: flex-end;\n  align-items: flex-end;\n`;\nexport const baseline = unsafeCSS `\n  -ms-flex-align: baseline;\n  -webkit-align-items: baseline;\n  align-items: baseline;\n`;\nexport const startJustified = unsafeCSS `\n  -ms-flex-pack: start;\n  -webkit-justify-content: flex-start;\n  justify-content: flex-start;\n`;\nexport const centerJustified = unsafeCSS `\n  -ms-flex-pack: center;\n  -webkit-justify-content: center;\n  justify-content: center;\n`;\nexport const endJustified = unsafeCSS `\n  -ms-flex-pack: end;\n  -webkit-justify-content: flex-end;\n  justify-content: flex-end;\n`;\nexport const aroundJustified = unsafeCSS `\n  -ms-flex-pack: distribute;\n  -webkit-justify-content: space-around;\n  justify-content: space-around;\n`;\nexport const justified = unsafeCSS `\n  -ms-flex-pack: justify;\n  -webkit-justify-content: space-between;\n  justify-content: space-between;\n`;\nexport const selfStart = unsafeCSS `\n  -ms-align-self: flex-start;\n  -webkit-align-self: flex-start;\n  align-self: flex-start;\n`;\nexport const selfCenter = unsafeCSS `\n  -ms-align-self: center;\n  -webkit-align-self: center;\n  align-self: center;\n`;\nexport const selfEnd = unsafeCSS `\n  -ms-align-self: flex-end;\n  -webkit-align-self: flex-end;\n  align-self: flex-end;\n`;\nexport const selfStretch = unsafeCSS `\n  -ms-align-self: stretch;\n  -webkit-align-self: stretch;\n  align-self: stretch;\n`;\nexport const selfBaseline = unsafeCSS `\n  -ms-align-self: baseline;\n  -webkit-align-self: baseline;\n  align-self: baseline;\n`;\nexport const startAlignedContent = unsafeCSS `\n  -ms-flex-line-pack: start; /* IE10 */\n  -ms-align-content: flex-start;\n  -webkit-align-content: flex-start;\n  align-content: flex-start;\n`;\nexport const endAlignedContent = unsafeCSS `\n  -ms-flex-line-pack: end; /* IE10 */\n  -ms-align-content: flex-end;\n  -webkit-align-content: flex-end;\n  align-content: flex-end;\n`;\nexport const centerAlignedContent = unsafeCSS `\n  -ms-flex-line-pack: center; /* IE10 */\n  -ms-align-content: center;\n  -webkit-align-content: center;\n  align-content: center;\n`;\nexport const betweenAlignedContent = unsafeCSS `\n  -ms-flex-line-pack: justify; /* IE10 */\n  -ms-align-content: space-between;\n  -webkit-align-content: space-between;\n  align-content: space-between;\n`;\nexport const aroundAlignedContent = unsafeCSS `\n  -ms-flex-line-pack: distribute; /* IE10 */\n  -ms-align-content: space-around;\n  -webkit-align-content: space-around;\n  align-content: space-around;\n`;\n","import { css } from 'lit-element';\n// tslint:disable ordered-imports\nimport { displayFlex, displayInlineFlex, horizontal, vertical, wrap, noWrap, flexFactor, flexFactorAuto, flexFactorNone, displayNone, flex2, flex3, flex4, flex5, flex6, flex7, flex8, flex9, flex10, flex11, flex12, horizontalReverse, verticalReverse, wrapReverse, displayBlock, invisible, relative, fit, scroll, fixed, fixedBottom, fixedLeft, fixedRight, fixedTop, startAligned, centerAligned, endAligned, baseline, startJustified, centerJustified, aroundJustified, endJustified, justified, selfStart, selfBaseline, selfCenter, selfEnd, selfStretch, startAlignedContent, centerAlignedContent, aroundAlignedContent, betweenAlignedContent, endAlignedContent, } from '../Literals';\nexport const Layouts = css `\n\t.layout.horizontal,\n\t.layout.vertical {\n\t\t${displayFlex}\n\t}\n\t.layout.inline {\n\t\t${displayInlineFlex}\n\t}\n\t.layout.horizontal {\n\t\t${horizontal}\n\t}\n\t.layout.vertical {\n\t\t${vertical}\n\t}\n\t.layout.wrap {\n\t\t${wrap}\n\t}\n\t.layout.no-wrap {\n\t\t${noWrap}\n\t}\n\t.layout.center,\n\t.layout.center-center {\n\t\t${centerAligned}\n\t}\n\t.layout.center-justified,\n\t.layout.center-center {\n\t\t${centerJustified}\n\t}\n\t.flex {\n\t\t${flexFactor}\n\t}\n\t.flex-auto {\n\t\t${flexFactorAuto}\n\t}\n\t.flex-none {\n\t\t${flexFactorNone}\n\t}\n\t.none {\n\t\t${displayNone}\n\t}\n`;\nexport const Factors = css `\n\t.flex,\n\t.flex-1 {\n\t\t${flexFactorAuto}\n\t}\n\n\t.flex-2 {\n\t\t${flex2}\n\t}\n\n\t.flex-3 {\n\t\t${flex3}\n\t}\n\n\t.flex-4 {\n\t\t${flex4}\n\t}\n\n\t.flex-5 {\n\t\t${flex5}\n\t}\n\n\t.flex-6 {\n\t\t${flex6}\n\t}\n\n\t.flex-7 {\n\t\t${flex7}\n\t}\n\n\t.flex-8 {\n\t\t${flex8}\n\t}\n\n\t.flex-9 {\n\t\t${flex9}\n\t}\n\n\t.flex-10 {\n\t\t${flex10}\n\t}\n\n\t.flex-11 {\n\t\t${flex11}\n\t}\n\n\t.flex-12 {\n\t\t${flex12}\n\t}\n`;\nexport const ReverseLayouts = css `\n\t.layout.horizontal-reverse,\n\t.layout.vertical-reverse {\n\t\t${displayFlex}\n\t}\n\n\t.layout.horizontal-reverse {\n\t\t${horizontalReverse}\n\t}\n\n\t.layout.vertical-reverse {\n\t\t${verticalReverse}\n\t}\n\n\t.layout.wrap-reverse {\n\t\t${wrapReverse}\n\t}\n`;\nexport const Positioning = css `\n\t.block {\n\t\t${displayBlock}\n\t}\n\n\t[hidden] {\n\t\t${displayNone}\n\t}\n\n\t.invisible {\n\t\t${invisible}\n\t}\n\n\t.relative {\n\t\t${relative}\n\t}\n\n\t.fit {\n\t\t${fit}\n\t}\n\n\tbody.fullbleed {\n\t\tmargin: 0;\n\t\theight: 100vh;\n\t}\n\n\t.scroll {\n\t\t${scroll}\n\t}\n\n\t/* fixed position */\n\t.fixed-bottom,\n\t.fixed-left,\n\t.fixed-right,\n\t.fixed-top {\n\t\t${fixed}\n\t}\n\n\t.fixed-top {\n\t\t${fixedTop}\n\t}\n\n\t.fixed-right {\n\t\t${fixedRight}\n\t}\n\n\t.fixed-bottom {\n\t\t${fixedBottom}\n\t}\n\n\t.fixed-left {\n\t\t${fixedLeft}\n\t}\n`;\nexport const Alignment = css `\n\t.layout.start {\n\t\t${startAligned}\n\t}\n\n\t.layout.center,\n\t.layout.center-center {\n\t\t${centerAligned}\n\t}\n\n\t.layout.end {\n\t\t${endAligned}\n\t}\n\n\t.layout.baseline {\n\t\t${baseline}\n\t}\n\n\t.layout.start-justified {\n\t\t${startJustified}\n\t}\n\n\t.layout.center-justified,\n\t.layout.center-center {\n\t\t${centerJustified}\n\t}\n\n\t.layout.end-justified {\n\t\t${endJustified}\n\t}\n\n\t.layout.around-justified {\n\t\t${aroundJustified}\n\t}\n\n\t.layout.justified {\n\t\t${justified}\n\t}\n\n\t.self-start {\n\t ${selfStart}\n\n\t.self-center {\n\t ${selfCenter}\n\t}\n\n\t.self-end {\n\t\t${selfEnd}\n\t}\n\n\t.self-stretch {\n\t ${selfStretch}\n\t}\n\n\t.self-baseline {\n\t ${selfBaseline}\n\t}\n\n\t.layout.start-aligned {\n\t ${startAlignedContent}\n\t}\n\n\t.layout.end-aligned {\n\t\t${endAlignedContent}\n\t}\n\n\t.layout.center-aligned {\n\t ${centerAlignedContent}\n\t}\n\n\t.layout.between-aligned {\n\t\t${betweenAlignedContent}\n\t}\n\n\t.layout.around-aligned {\n\t\t${aroundAlignedContent}\n\t}\n`;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, css, html, render } from 'lit';\nimport { property, customElement } from 'lit/decorators.js';\nimport { deepEqual } from 'fast-equals';\nlet LitDatatable = class LitDatatable extends LitElement {\n    constructor() {\n        super(...arguments);\n        this.data = [];\n        this.conf = [];\n        this.table = [];\n        this.sort = '';\n        this.headers = [];\n        this.stickyHeader = false;\n        this.datatableColumns = new Map();\n        this.datatableHeaders = new Map();\n        this.lastConfSize = 0;\n        this.lastDataSize = 0;\n        this.debounceGenerate = 0;\n    }\n    static get styles() {\n        const mainStyle = css `\n      :host {\n        display: block;\n      }\n\n      slot {\n        display: none;\n      }\n\n      table {\n        width: 100%;\n        border-spacing: 0px;\n        border-collapse: seperate;\n      }\n\n      th {\n        background: var(--lit-datatable-th-background, white);\n        color: var(--lit-datatable-th-color, rgba(0, 0, 0, var(--dark-secondary-opacity)));\n        text-align: left;\n        white-space: nowrap;\n\n        font-weight: var(--lit-datatable-api-header-weight, 500);\n        font-size: var(--lit-datatable-api-header-font-size, 12px);\n        padding: var(--lit-datatable-api-header-padding, 6px 26px);\n\n        border-bottom: 1px solid;\n        border-color: var(--lit-datatable-divider-color, rgba(0, 0, 0, var(--dark-divider-opacity)))\n      }\n\n      th.sticky {\n        position: sticky;\n        background: var(--lit-datatable-th-background, white);\n        top: 0;\n        z-index: 1;\n      }\n\n      tbody td {\n        height: var(--lit-datatable-api-body-td-height, 43px);\n      }\n\n      tbody tr {\n        height: var(--lit-datatable-api-body-tr-height, 43px);\n      }\n\n      thead tr {\n        height: var(--lit-datatable-api-header-tr-height, 43px);\n      }\n\n      thead th {\n        height: var(--lit-datatable-api-header-th-height, 43px);\n      }\n\n      tbody tr:nth-child(even) {\n        background-color: var(--lit-datatable-api-tr-even-background-color, none);\n      }\n\n      tbody tr:nth-child(odd) {\n        background-color: var(--lit-datatable-api-tr-odd-background-color, none);\n      }\n\n      tbody tr:hover {\n        background: var(--lit-datatable-api-tr-hover-background-color, none);\n      }\n\n      tbody tr.is-currently-highlight {\n        background: var(--lit-datatable-api-tr-highlight-background-color, none);\n      }\n\n      tbody tr.selected {\n        background-color: var(--lit-datatable-api-tr-selected-background, var(--paper-grey-100));\n      }\n\n      td {\n        font-size: var(--lit-datatable-td-font-size, 13px);\n        font-weight: normal;\n        color: var(--lit-datatable-td-color, rgba(0, 0, 0, var(--dark-primary-opacity)));\n        padding: var(--lit-datatable-api-td-padding, 6px var(--lit-datatable-api-horizontal-padding, 26px));\n        cursor: var(--lit-datatable-api-td-cursor, inherit);\n        height: 36px;\n      }\n\n      tbody tr:not(:first-child) td {\n        border-top: var(--lit-datatable-api-td-border-top, 1px solid);\n        border-color: var(--lit-datatable-divider-color, rgba(0, 0, 0, var(--dark-divider-opacity)))\n      }\n      `;\n        return [mainStyle];\n    }\n    render() {\n        return html `\n      <slot></slot>\n      <table id=\"table\">\n        <thead></thead>\n        <tbody></tbody>\n      </table>\n    `;\n    }\n    updated(properties) {\n        // Data or conf change we have to generate the table\n        if ((properties.has('data') && !deepEqual(properties.get('data'), this.data))\n            || (properties.has('conf') && !deepEqual(properties.get('conf'), this.conf))) {\n            this.deleteAllEvents();\n            this.generateData();\n        }\n        if (properties.has('conf') || properties.has('stickyHeader')) {\n            const confs = [...this.conf].filter((c) => !c.hidden);\n            this.updateHeaders(confs);\n        }\n        if (properties.has('sort')) {\n            this.updateSortHeaders();\n        }\n    }\n    updateSortHeaders() {\n        if (this.sort !== undefined && this.sort !== null) {\n            this.datatableHeaders.forEach((d) => { d.sort = this.sort; });\n        }\n    }\n    firstUpdated() {\n        if (this.shadowRoot) {\n            const slot = this.shadowRoot.querySelector('slot');\n            if (slot) {\n                const assignedNodes = slot.assignedNodes();\n                this.datatableColumns = new Map(assignedNodes\n                    .filter((a) => a.tagName === 'LIT-DATATABLE-COLUMN' && a.column)\n                    .map((a) => [a.property, a]));\n                this.datatableHeaders = new Map(assignedNodes\n                    .filter((a) => a.tagName === 'LIT-DATATABLE-COLUMN' && a.header)\n                    .map((a) => [a.property, a]));\n            }\n        }\n    }\n    deleteAllEvents() {\n        this.datatableColumns.forEach((datatableColumn) => {\n            datatableColumn.eventsForDom.forEach((renderer) => {\n                datatableColumn.removeEventListener('html-changed', renderer);\n            });\n        });\n    }\n    renderCell(item, td, confProperty, event, litDatatableColumn) {\n        if (event) {\n            litDatatableColumn = event.currentTarget;\n        }\n        if (litDatatableColumn) {\n            const otherProperties = this.getOtherValues(litDatatableColumn, item);\n            if (litDatatableColumn === null || litDatatableColumn === void 0 ? void 0 : litDatatableColumn.html) {\n                render(litDatatableColumn.html(this.extractData(item, litDatatableColumn.property), otherProperties), td);\n            }\n            else if (litDatatableColumn) {\n                render(this.extractData(item, litDatatableColumn.property), td);\n            }\n        }\n        else if (confProperty) {\n            render(this.extractData(item, confProperty), td);\n        }\n    }\n    setEventListener(datatableColumn, lineIndex, renderer) {\n        if (datatableColumn) {\n            if (datatableColumn.eventsForDom[lineIndex]) {\n                datatableColumn.removeEventListener('html-changed', datatableColumn.eventsForDom[lineIndex]);\n            }\n            datatableColumn.eventsForDom[lineIndex] = renderer;\n            datatableColumn.addEventListener('html-changed', datatableColumn.eventsForDom[lineIndex]);\n        }\n    }\n    getOtherValues(datatableColumn, item) {\n        let otherProperties = {};\n        if (datatableColumn && datatableColumn.otherProperties) {\n            otherProperties = datatableColumn.otherProperties.reduce((obj, key) => {\n                obj[key] = item[key];\n                return obj;\n            }, {});\n        }\n        return otherProperties;\n    }\n    renderHtml(conf, lineIndex, item, td, tr) {\n        const p = conf.property;\n        const datatableColumn = this.datatableColumns.get(p);\n        if (datatableColumn) {\n            this.setEventListener(datatableColumn, lineIndex, this.renderCell.bind(this, item, td, p));\n        }\n        this.renderCell(item, td, p, undefined, datatableColumn);\n        tr.appendChild(td);\n    }\n    cleanEventsOfTr(item) {\n        item.events.forEach((event) => item.element.removeEventListener(event.type, event.event));\n    }\n    createEventsOfTr(tr, item) {\n        const trTapEvent = this.trTap.bind(this, item);\n        const trOverEvent = this.trHover.bind(this, item);\n        const trOutEvent = this.trOut.bind(this, item);\n        tr.addEventListener('tap', trTapEvent);\n        tr.addEventListener('mouseover', trOverEvent);\n        tr.addEventListener('mouseout', trOutEvent);\n        return [{ type: 'mouseover', event: trOverEvent }, { type: 'mouseout', event: trOutEvent }, { type: 'tap', event: trTapEvent }];\n    }\n    cleanTrElements() {\n        const splices = this.table.splice(this.data.length);\n        splices.forEach((line) => {\n            var _a;\n            this.cleanEventsOfTr(line);\n            if ((_a = line === null || line === void 0 ? void 0 : line.element) === null || _a === void 0 ? void 0 : _a.parentNode) {\n                line.element.parentNode.removeChild(line.element);\n            }\n        });\n    }\n    cleanTdElements(confs) {\n        [...this.table].forEach((line) => {\n            const splicedColumns = line.columns.splice(confs.length);\n            splicedColumns.forEach((column) => {\n                line.element.removeChild(column);\n            });\n        });\n    }\n    updateHeaders(confs) {\n        if (this.shadowRoot) {\n            let tr = this.shadowRoot.querySelector('table thead tr');\n            if (!tr) {\n                tr = document.createElement('tr');\n            }\n            if (this.lastConfSize > confs.length) {\n                [...this.headers].forEach((header, i) => {\n                    if (i <= (this.lastConfSize - 1)) {\n                        if (tr) {\n                            tr.removeChild(header);\n                        }\n                        this.headers.splice(i, 1);\n                    }\n                });\n            }\n            confs.forEach((conf, i) => {\n                const p = conf.property;\n                const datatableHeader = this.datatableHeaders.get(p);\n                let th;\n                if (this.headers[i]) {\n                    th = this.headers[i];\n                }\n                else {\n                    th = document.createElement('th');\n                    this.headers.push(th);\n                }\n                th.classList.toggle('sticky', this.stickyHeader);\n                if (datatableHeader && datatableHeader.columnStyle) {\n                    th.setAttribute('style', datatableHeader.columnStyle);\n                }\n                else {\n                    th.setAttribute('style', '');\n                }\n                if (this.stickyHeader) {\n                    th.style.zIndex = `${confs.length - i}`;\n                }\n                if (datatableHeader) {\n                    th.dataset.property = p;\n                    this.setEventListener(datatableHeader, 0, () => {\n                        if (th.dataset.property === datatableHeader.property) {\n                            render(datatableHeader.html ? datatableHeader.html(conf.header, datatableHeader.property) : null, th);\n                        }\n                    });\n                    if (datatableHeader.type === 'sort' || datatableHeader.type === 'filterSort') {\n                        if (datatableHeader.sortEvent) {\n                            datatableHeader.removeEventListener('sort', datatableHeader.sortEvent);\n                        }\n                        datatableHeader.sortEvent = this.dispatchCustomEvent.bind(this, 'sort');\n                        datatableHeader.addEventListener('sort', datatableHeader.sortEvent);\n                    }\n                    if (datatableHeader.type === 'filter' || datatableHeader.type === 'filterSort') {\n                        if (datatableHeader.filterEvent) {\n                            datatableHeader.removeEventListener('filter', datatableHeader.filterEvent);\n                        }\n                        datatableHeader.filterEvent = this.dispatchCustomEvent.bind(this, 'filter');\n                        datatableHeader.addEventListener('filter', datatableHeader.filterEvent);\n                    }\n                    if (datatableHeader.type === 'choices') {\n                        if (datatableHeader.choicesEvent) {\n                            datatableHeader.removeEventListener('choices', datatableHeader.choicesEvent);\n                        }\n                        datatableHeader.choicesEvent = this.dispatchCustomEvent.bind(this, 'choices');\n                        datatableHeader.addEventListener('choices', datatableHeader.choicesEvent);\n                    }\n                    if (datatableHeader.type === 'dateSort' || datatableHeader.type === 'dateSortNoRange') {\n                        if (datatableHeader.dateSortEvent) {\n                            datatableHeader.removeEventListener('dates', datatableHeader.dateSortEvent);\n                        }\n                        datatableHeader.dateSortEvent = this.dispatchCustomEvent.bind(this, 'dates');\n                        datatableHeader.addEventListener('dates', datatableHeader.dateSortEvent);\n                        if (datatableHeader.sortEvent) {\n                            datatableHeader.removeEventListener('sort', datatableHeader.sortEvent);\n                        }\n                        datatableHeader.sortEvent = this.dispatchCustomEvent.bind(this, 'sort');\n                        datatableHeader.addEventListener('sort', datatableHeader.sortEvent);\n                    }\n                }\n                if (datatableHeader && datatableHeader.html) {\n                    render(datatableHeader.html(conf.header, datatableHeader.property), th);\n                }\n                else {\n                    render(conf.header, th);\n                }\n                if (tr) {\n                    tr.appendChild(th);\n                }\n            });\n            if (this.shadowRoot) {\n                const thead = this.shadowRoot.querySelector('thead');\n                if (thead) {\n                    thead.appendChild(tr);\n                }\n            }\n        }\n    }\n    dispatchCustomEvent(key, { detail }) {\n        this.dispatchEvent(new CustomEvent(key, { detail }));\n    }\n    trCreated(tr, lineIndex, item) {\n        this.dispatchEvent(new CustomEvent('tr-create', { detail: { tr, lineIndex, item } }));\n    }\n    trTap(item) {\n        this.dispatchEvent(new CustomEvent('tap-tr', { detail: item }));\n    }\n    trHover(item) {\n        this.dispatchEvent(new CustomEvent('tr-mouseover', { detail: item }));\n    }\n    trOut(item) {\n        this.dispatchEvent(new CustomEvent('tr-mouseout', { detail: item }));\n    }\n    createTr(lineIndex, item) {\n        const tr = this.setKeyToTr(document.createElement('tr'), item);\n        if (!this.table[lineIndex]) {\n            this.table[lineIndex] = { element: tr, columns: [], events: this.createEventsOfTr(tr, item) };\n        }\n        return tr;\n    }\n    createTd(lineIndex) {\n        const td = document.createElement('td');\n        this.table[lineIndex].columns.push(td);\n        return td;\n    }\n    setKeyToTr(tr, item) {\n        if (this.key && Object.prototype.hasOwnProperty.call(item, this.key)) {\n            const data = this.extractData(item, this.key);\n            tr.classList.add(`key-${data}`);\n        }\n        return tr;\n    }\n    updateBody(confs) {\n        if (this.data !== undefined) {\n            if (this.lastConfSize > confs.length) {\n                this.cleanTdElements(confs);\n            }\n            if (this.lastDataSize > this.data.length) {\n                this.cleanTrElements();\n            }\n            this.data.forEach((item, lineIndex) => {\n                let tr;\n                if (this.table[lineIndex]) {\n                    this.cleanEventsOfTr(this.table[lineIndex]);\n                    tr = this.table[lineIndex].element;\n                    tr.className = '';\n                    tr = this.setKeyToTr(tr, item);\n                    this.table[lineIndex].events = this.createEventsOfTr(tr, item);\n                }\n                else {\n                    tr = this.createTr(lineIndex, item);\n                }\n                this.trCreated(tr, lineIndex, item);\n                confs.forEach((conf, columnIndex) => {\n                    let td;\n                    if (this.table[lineIndex].columns[columnIndex]) {\n                        td = this.table[lineIndex].columns[columnIndex];\n                    }\n                    else {\n                        td = this.createTd(lineIndex);\n                    }\n                    const datatableColumn = this.datatableColumns.get(conf.property);\n                    if (datatableColumn && datatableColumn.columnStyle) {\n                        td.setAttribute('style', datatableColumn.columnStyle);\n                    }\n                    else {\n                        td.setAttribute('style', '');\n                    }\n                    this.renderHtml(conf, lineIndex, item, td, tr);\n                });\n                if (this.shadowRoot) {\n                    const tbody = this.shadowRoot.querySelector('tbody');\n                    if (tbody) {\n                        tbody.appendChild(tr);\n                    }\n                }\n            });\n        }\n    }\n    setLoading(loading) {\n        this.dispatchEvent(new CustomEvent('loading', { detail: { value: loading } }));\n    }\n    async generateData() {\n        this.setLoading(true);\n        await this.updateComplete;\n        const confs = [...this.conf].filter((c) => !c.hidden);\n        this.updateBody(confs);\n        if (this.data !== undefined) {\n            this.lastDataSize = this.data.length;\n            this.lastConfSize = confs.length;\n        }\n        this.setLoading(false);\n    }\n    extractData(item, columnProperty) {\n        if (columnProperty) {\n            const splittedProperties = columnProperty.split('.');\n            if (splittedProperties.length > 1) {\n                return splittedProperties.reduce((prevRow, p) => {\n                    if (typeof prevRow === 'string' && item[prevRow] !== undefined && item[prevRow][p] !== undefined) {\n                        return item[prevRow][p];\n                    }\n                    return prevRow[p] || '';\n                });\n            }\n            return item[columnProperty];\n        }\n        return null;\n    }\n    /**\n      * Scroll to a tr with the key\n      * The key property have to be set\n      *\n     */\n    async scrollOnTr(key) {\n        if (this.shadowRoot && key) {\n            await this.updateComplete;\n            const classPrimaryDisplayed = 'is-currently-highlight';\n            this.shadowRoot.querySelectorAll(`.${classPrimaryDisplayed}`).forEach((tr) => {\n                tr.classList.remove(classPrimaryDisplayed);\n            });\n            const trToScroll = this.shadowRoot.querySelector(`tr.key-${key}`);\n            if (trToScroll) {\n                trToScroll.scrollIntoView({ block: 'center', inline: 'nearest' });\n                trToScroll.classList.add(classPrimaryDisplayed);\n            }\n        }\n    }\n};\n__decorate([\n    property({ type: Array })\n], LitDatatable.prototype, \"data\", void 0);\n__decorate([\n    property({ type: Array })\n], LitDatatable.prototype, \"conf\", void 0);\n__decorate([\n    property({ type: Array })\n], LitDatatable.prototype, \"table\", void 0);\n__decorate([\n    property({ type: String })\n], LitDatatable.prototype, \"sort\", void 0);\n__decorate([\n    property({ type: Array })\n], LitDatatable.prototype, \"headers\", void 0);\n__decorate([\n    property({ type: Boolean, attribute: 'sticky-header' })\n], LitDatatable.prototype, \"stickyHeader\", void 0);\n__decorate([\n    property({ type: Object })\n], LitDatatable.prototype, \"datatableColumns\", void 0);\n__decorate([\n    property({ type: Object })\n], LitDatatable.prototype, \"datatableHeaders\", void 0);\n__decorate([\n    property({ type: Number })\n], LitDatatable.prototype, \"lastConfSize\", void 0);\n__decorate([\n    property({ type: Number })\n], LitDatatable.prototype, \"lastDataSize\", void 0);\n__decorate([\n    property({ type: String })\n], LitDatatable.prototype, \"key\", void 0);\nLitDatatable = __decorate([\n    customElement('lit-datatable')\n], LitDatatable);\nexport { LitDatatable };\n//# sourceMappingURL=lit-datatable.js.map","/**\n * @license\n * Copyright 2014-2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { html, css, LitElement } from 'lit';\nimport { property } from 'lit/decorators.js';\nimport { createChartWrapper, dataTable } from './loader.js';\nconst DEFAULT_EVENTS = ['ready', 'select'];\n/**\n * Constructor names for supported chart types.\n *\n * `ChartWrapper` expects a constructor name and assumes `google.visualization`\n *  as the default namespace.\n */\nconst CHART_TYPES = {\n    'area': 'AreaChart',\n    'bar': 'BarChart',\n    'md-bar': 'google.charts.Bar',\n    'bubble': 'BubbleChart',\n    'calendar': 'Calendar',\n    'candlestick': 'CandlestickChart',\n    'column': 'ColumnChart',\n    'combo': 'ComboChart',\n    'gantt': 'Gantt',\n    'gauge': 'Gauge',\n    'geo': 'GeoChart',\n    'histogram': 'Histogram',\n    'line': 'LineChart',\n    'md-line': 'google.charts.Line',\n    'org': 'OrgChart',\n    'pie': 'PieChart',\n    'sankey': 'Sankey',\n    'scatter': 'ScatterChart',\n    'md-scatter': 'google.charts.Scatter',\n    'stepped-area': 'SteppedAreaChart',\n    'table': 'Table',\n    'timeline': 'Timeline',\n    'treemap': 'TreeMap',\n    'wordtree': 'WordTree',\n};\n/**\n * `google-chart` encapsulates Google Charts as a web component, allowing you to\n * easily visualize data. From simple line charts to complex hierarchical tree\n * maps, the chart element provides a number of ready-to-use chart types.\n *\n * ```html\n * <google-chart\n *     type='pie'\n *     options='{\"title\": \"Distribution of days in 2001Q1\"}'\n *     cols='[{\"label\":\"Month\", \"type\":\"string\"}, {\"label\":\"Days\",\n *         \"type\":\"number\"}]' rows='[[\"Jan\", 31],[\"Feb\", 28],[\"Mar\", 31]]'>\n *   </google-chart>\n * ```\n *\n * Note: if you're passing JSON as attributes, single quotes are necessary to be\n * valid JSON. See\n * https://www.polymer-project.org/1.0/docs/devguide/properties#configuring-object-and-array-properties.\n *\n * Height and width are specified as style attributes:\n * ```css\n * google-chart {\n *   height: 300px;\n *   width: 50em;\n * }\n * ```\n *\n * Data can be provided in one of three ways:\n *\n * - Via the `cols` and `rows` attributes:\n *   ```\n *   cols='[{\"label\":\"Mth\", \"type\":\"string\"},{\"label\":\"Days\", \"type\":\"number\"}]'\n *   rows='[[\"Jan\", 31],[\"Feb\", 28],[\"Mar\", 31]]'\n *   ```\n *\n * - Via the `data` attribute, passing in the data directly:\n *   ```\n *   data='[[\"Month\", \"Days\"], [\"Jan\", 31], [\"Feb\", 28], [\"Mar\", 31]]'\n *   ```\n *\n * - Via the `data` attribute, passing in the URL to a resource containing the\n *   data, in JSON format:\n *   ```\n *   data='http://example.com/chart-data.json'\n *   ```\n *\n * - Via the `data` attribute, passing in a Google DataTable object:\n *   ```\n *   data='{{dataTable}}'\n *   ```\n *\n * - Via the `view` attribute, passing in a Google DataView object:\n *   ```\n *   view='{{dataView}}'\n *   ```\n *\n * You can display the charts in locales other than \"en\" by setting the `lang`\n * attribute on the `html` tag of your document:\n * ```\n * <html lang=\"ja\">\n * ```\n *\n * @demo demo/index.html\n */\nexport class GoogleChart extends LitElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * Fired after a chart type is rendered and ready for interaction.\n         *\n         * @event google-chart-ready\n         * @param {{chart: !Object}} detail The raw chart object.\n         */\n        /**\n         * Fired when the user makes a selection in the chart.\n         *\n         * @event google-chart-select\n         * @param {{chart: !Object}} detail The raw chart object.\n         */\n        /**\n         * Type of the chart.\n         *\n         * Should be one of:\n         * - `area`\n         * - `(md-)bar`\n         * - `bubble`\n         * - `calendar`\n         * - `candlestick`\n         * - `column`\n         * - `combo`\n         * - `gantt`\n         * - `gauge`\n         * - `geo`\n         * - `histogram`\n         * - `(md-)line`\n         * - `org`\n         * - `pie`\n         * - `sankey`\n         * - `(md-)scatter`\n         * - `stepped-area`\n         * - `table`\n         * - `timeline`\n         * - `treemap`\n         * - `wordtree`\n         *\n         * See <a\n         * href=\"https://google-developers.appspot.com/chart/interactive/docs/gallery\">Google\n         * Visualization API reference (Chart Gallery)</a> for details.\n         */\n        this.type = 'column';\n        /**\n         * Enumerates the chart events that should be fired.\n         *\n         * Charts support a variety of events. By default, this element only\n         * fires on `ready` and `select`. If you would like to be notified of\n         * other chart events, use this property to list them.\n         * Events `ready` and `select` are always fired.\n         *\n         * Changes to this property are _not_ observed. Events are attached only\n         * at chart construction time.\n         */\n        this.events = [];\n        /**\n         * Sets the options for the chart.\n         *\n         * Example:\n         * ```\n         * {\n         *   title: \"Chart title goes here\",\n         *   hAxis: {title: \"Categories\"},\n         *   vAxis: {title: \"Values\", minValue: 0, maxValue: 2},\n         *   legend: \"none\"\n         * }\n         * ```\n         * See <a\n         * href=\"https://google-developers.appspot.com/chart/interactive/docs/gallery\">Google\n         * Visualization API reference (Chart Gallery)</a> for the options available\n         * to each chart type.\n         *\n         * Setting this property always redraws the chart. If you would like to make\n         * changes to a sub-property, be sure to reassign the property:\n         * ```\n         * const options = googleChart.options;\n         * options.vAxis.logScale = true;\n         * googleChart.options = options;\n         * ```\n         * (Note: Missing parent properties are not automatically created.)\n         */\n        this.options = undefined;\n        /**\n         * Sets the data columns for this object.\n         *\n         * When specifying data with `cols` you must also specify `rows`, and\n         * not specify `data`.\n         *\n         * Example:\n         * <pre>[{label: \"Categories\", type: \"string\"},\n         *  {label: \"Value\", type: \"number\"}]</pre>\n         * See <a\n         * href=\"https://google-developers.appspot.com/chart/interactive/docs/reference#DataTable_addColumn\">Google\n         * Visualization API reference (addColumn)</a> for column definition format.\n         */\n        this.cols = undefined;\n        /**\n         * Sets the data rows for this object.\n         *\n         * When specifying data with `rows` you must also specify `cols`, and\n         * not specify `data`.\n         *\n         * Example:\n         * <pre>[[\"Category 1\", 1.0],\n         *  [\"Category 2\", 1.1]]</pre>\n         * See <a\n         * href=\"https://google-developers.appspot.com/chart/interactive/docs/reference#addrow\">Google\n         * Visualization API reference (addRow)</a> for row format.\n         */\n        this.rows = undefined;\n        /**\n         * Sets the entire dataset for this object.\n         * Can be used to provide the data directly, or to provide a URL from\n         * which to request the data.\n         *\n         * The data format can be a two-dimensional array or the DataTable format\n         * expected by Google Charts.\n         * See <a\n         * href=\"https://google-developers.appspot.com/chart/interactive/docs/reference#DataTable\">Google\n         * Visualization API reference (DataTable constructor)</a> for data table\n         * format details.\n         *\n         * When specifying data with `data` you must not specify `cols` or `rows`.\n         *\n         * Example:\n         * ```\n         * [[\"Categories\", \"Value\"],\n         *  [\"Category 1\", 1.0],\n         *  [\"Category 2\", 1.1]]\n         * ```\n         */\n        // Note: type: String, because it is parsed manually in the observer.\n        this.data = undefined;\n        /**\n         * Sets the entire dataset for this object to a Google DataView.\n         *\n         * See <a\n         * href=\"https://google-developers.appspot.com/chart/interactive/docs/reference#dataview-class\">Google\n         * Visualization API reference (DataView)</a> for details.\n         *\n         * When specifying data with `view` you must not specify `data`, `cols` or\n         * `rows`.\n         */\n        this.view = undefined;\n        /**\n         * Selected datapoint(s) in the chart.\n         *\n         * An array of objects, each with a numeric row and/or column property.\n         * `row` and `column` are the zero-based row or column number of an item\n         * in the data table to select.\n         *\n         * To select a whole column, set row to null;\n         * to select a whole row, set column to null.\n         *\n         * Example:\n         * ```\n         * [{row:0,column:1}, {row:1, column:null}]\n         * ```\n         */\n        this.selection = undefined;\n        /**\n         * Whether the chart is currently rendered.\n         * @export\n         */\n        this.drawn = false;\n        /**\n         * Internal data displayed on the chart.\n         */\n        // tslint:disable-next-line:enforce-name-casing\n        this._data = undefined;\n        /**\n         * Internal chart object.\n         */\n        this.chartWrapper = null;\n        this.redrawTimeoutId = undefined;\n    }\n    render() {\n        return html `\n      <div id=\"styles\"></div>\n      <div id=\"chartdiv\"></div>\n    `;\n    }\n    firstUpdated() {\n        createChartWrapper(this.shadowRoot.getElementById('chartdiv'))\n            .then(chartWrapper => {\n            this.chartWrapper = chartWrapper;\n            this.typeChanged();\n            google.visualization.events.addListener(chartWrapper, 'ready', () => {\n                this.drawn = true;\n                if (this.selection) {\n                    this.selectionChanged();\n                }\n            });\n            google.visualization.events.addListener(chartWrapper, 'select', () => {\n                this.selection = chartWrapper.getChart().getSelection();\n            });\n            this.propagateEvents(DEFAULT_EVENTS, chartWrapper);\n        });\n    }\n    updated(changedProperties) {\n        if (changedProperties.has('type'))\n            this.typeChanged();\n        if (changedProperties.has('rows') || changedProperties.has('cols')) {\n            this.rowsOrColumnsChanged();\n        }\n        if (changedProperties.has('data'))\n            this.dataChanged();\n        if (changedProperties.has('view'))\n            this.viewChanged();\n        if (changedProperties.has('_data') ||\n            changedProperties.has('options'))\n            this.redraw();\n        if (changedProperties.has('selection'))\n            this.selectionChanged();\n    }\n    /** Reacts to chart type change. */\n    typeChanged() {\n        if (this.chartWrapper == null)\n            return;\n        this.chartWrapper.setChartType(CHART_TYPES[this.type] || this.type);\n        const lastChart = this.chartWrapper.getChart();\n        google.visualization.events.addOneTimeListener(this.chartWrapper, 'ready', () => {\n            // Ready event fires after `chartWrapper` is initialized.\n            const chart = this.chartWrapper.getChart();\n            if (chart !== lastChart) {\n                this.propagateEvents(this.events.filter((eventName) => !DEFAULT_EVENTS.includes(eventName)), chart);\n            }\n            const stylesDiv = this.shadowRoot.getElementById('styles');\n            if (!stylesDiv.children.length) {\n                this.localizeGlobalStylesheets(stylesDiv);\n            }\n        });\n        this.redraw();\n    }\n    /**\n     * Adds listeners to propagate events from the chart.\n     */\n    propagateEvents(events, eventTarget) {\n        for (const eventName of events) {\n            google.visualization.events.addListener(eventTarget, eventName, (event) => {\n                this.dispatchEvent(new CustomEvent(`google-chart-${eventName}`, {\n                    bubbles: true,\n                    composed: true,\n                    detail: {\n                        // Events fire after `chartWrapper` is initialized.\n                        chart: this.chartWrapper.getChart(),\n                        data: event,\n                    }\n                }));\n            });\n        }\n    }\n    /** Sets the selectiton on the chart. */\n    selectionChanged() {\n        if (this.chartWrapper == null)\n            return;\n        const chart = this.chartWrapper.getChart();\n        if (chart == null)\n            return;\n        if (chart.setSelection) {\n            // Workaround for timeline chart which emits select event on setSelection.\n            // See issue #256.\n            if (this.type === 'timeline') {\n                const oldSelection = JSON.stringify(chart.getSelection());\n                const newSelection = JSON.stringify(this.selection);\n                if (newSelection === oldSelection)\n                    return;\n            }\n            chart.setSelection(this.selection);\n        }\n    }\n    /**\n     * Redraws the chart.\n     *\n     * Called automatically when data/type/selection attributes change.\n     * Call manually to handle view updates, page resizes, etc.\n     */\n    redraw() {\n        if (this.chartWrapper == null || this._data == null)\n            return;\n        // `ChartWrapper` can be initialized with `DataView` instead of `DataTable`.\n        this.chartWrapper.setDataTable(this._data);\n        this.chartWrapper.setOptions(this.options || {});\n        this.drawn = false;\n        if (this.redrawTimeoutId !== undefined)\n            clearTimeout(this.redrawTimeoutId);\n        this.redrawTimeoutId = window.setTimeout(() => {\n            // Drawing happens after `chartWrapper` is initialized.\n            this.chartWrapper.draw();\n        }, 5);\n    }\n    /**\n     * Returns the chart serialized as an image URI.\n     *\n     * Call this after the chart is drawn (`google-chart-ready` event).\n     */\n    get imageURI() {\n        if (this.chartWrapper == null)\n            return null;\n        const chart = this.chartWrapper.getChart();\n        return chart && chart.getImageURI();\n    }\n    /** Handles changes to the `view` attribute. */\n    viewChanged() {\n        if (!this.view)\n            return;\n        this._data = this.view;\n    }\n    /** Handles changes to the rows & columns attributes. */\n    async rowsOrColumnsChanged() {\n        const { rows, cols } = this;\n        if (!rows || !cols)\n            return;\n        try {\n            const dt = await dataTable({ cols });\n            dt.addRows(rows);\n            this._data = dt;\n        }\n        catch (reason) {\n            this.shadowRoot.getElementById('chartdiv').textContent = String(reason);\n        }\n    }\n    /**\n     * Handles changes to the `data` attribute.\n     */\n    dataChanged() {\n        let data = this.data;\n        let dataPromise;\n        if (!data) {\n            return;\n        }\n        let isString = false;\n        // Polymer 2 will not call observer if type:Object is set and fails, so\n        // we must parse the string ourselves.\n        try {\n            // Try to deserialize the value of the `data` property which might be a\n            // serialized array.\n            data = JSON.parse(data);\n        }\n        catch (e) {\n            isString = typeof data === 'string' || data instanceof String;\n        }\n        if (isString) {\n            // Load data asynchronously, from external URL.\n            dataPromise = fetch(data).then(response => response.json());\n        }\n        else {\n            // Data is all ready to be processed.\n            dataPromise = Promise.resolve(data);\n        }\n        dataPromise.then(dataTable).then(data => {\n            this._data = data;\n        });\n    }\n    /**\n     * Queries global document head for Google Charts `link#load-css-*` and clones\n     * them into the local root's `div#styles` element for shadow dom support.\n     */\n    localizeGlobalStylesheets(stylesDiv) {\n        // Get all Google Charts stylesheets.\n        const stylesheets = Array.from(document.head.querySelectorAll('link[rel=\"stylesheet\"][type=\"text/css\"][id^=\"load-css-\"]'));\n        for (const stylesheet of stylesheets) {\n            // Clone necessary stylesheet attributes.\n            const clonedStylesheet = document.createElement('link');\n            clonedStylesheet.setAttribute('rel', 'stylesheet');\n            clonedStylesheet.setAttribute('type', 'text/css');\n            // `href` is always present.\n            clonedStylesheet.setAttribute('href', stylesheet.getAttribute('href'));\n            stylesDiv.appendChild(clonedStylesheet);\n        }\n    }\n}\n/** @nocollapse */\nGoogleChart.styles = css `\n    :host {\n      display: -webkit-flex;\n      display: -ms-flex;\n      display: flex;\n      margin: 0;\n      padding: 0;\n      width: 400px;\n      height: 300px;\n    }\n\n    :host([hidden]) {\n      display: none;\n    }\n\n    :host([type=\"gauge\"]) {\n      width: 300px;\n      height: 300px;\n    }\n\n    #chartdiv {\n      width: 100%;\n    }\n\n    /* Workaround for slow initial ready event for tables. */\n    .google-visualization-table-loadtest {\n      padding-left: 6px;\n    }\n  `;\n__decorate([\n    property({ type: String, reflect: true })\n], GoogleChart.prototype, \"type\", void 0);\n__decorate([\n    property({ type: Array })\n], GoogleChart.prototype, \"events\", void 0);\n__decorate([\n    property({ type: Object, hasChanged: () => true })\n], GoogleChart.prototype, \"options\", void 0);\n__decorate([\n    property({ type: Array })\n], GoogleChart.prototype, \"cols\", void 0);\n__decorate([\n    property({ type: Array })\n], GoogleChart.prototype, \"rows\", void 0);\n__decorate([\n    property({ type: String })\n], GoogleChart.prototype, \"data\", void 0);\n__decorate([\n    property({ type: Object })\n], GoogleChart.prototype, \"view\", void 0);\n__decorate([\n    property({ type: Array })\n], GoogleChart.prototype, \"selection\", void 0);\n__decorate([\n    property({ type: Object })\n], GoogleChart.prototype, \"_data\", void 0);\ncustomElements.define('google-chart', GoogleChart);\n//# sourceMappingURL=google-chart.js.map","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-ripple/mwc-ripple.js';\nimport { ariaProperty } from '@material/mwc-base/aria-property.js';\nimport { FormElement } from '@material/mwc-base/form-element.js';\nimport { RippleHandlers } from '@material/mwc-ripple/ripple-handlers.js';\nimport { html } from 'lit';\nimport { eventOptions, property, query, queryAsync, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\n/** @soyCompatible */\nexport class CheckboxBase extends FormElement {\n    constructor() {\n        super(...arguments);\n        this.checked = false;\n        this.indeterminate = false;\n        this.disabled = false;\n        this.name = '';\n        this.value = 'on';\n        /**\n         * Touch target extends beyond visual boundary of a component by default.\n         * Set to `true` to remove touch target added to the component.\n         * @see https://material.io/design/usability/accessibility.html\n         */\n        this.reducedTouchTarget = false;\n        this.animationClass = '';\n        this.shouldRenderRipple = false;\n        this.focused = false;\n        // MDC Foundation is unused\n        this.mdcFoundationClass = undefined;\n        this.mdcFoundation = undefined;\n        this.rippleElement = null;\n        this.rippleHandlers = new RippleHandlers(() => {\n            this.shouldRenderRipple = true;\n            this.ripple.then((v) => this.rippleElement = v);\n            return this.ripple;\n        });\n    }\n    createAdapter() {\n        return {};\n    }\n    update(changedProperties) {\n        const oldIndeterminate = changedProperties.get('indeterminate');\n        const oldChecked = changedProperties.get('checked');\n        const oldDisabled = changedProperties.get('disabled');\n        if (oldIndeterminate !== undefined || oldChecked !== undefined ||\n            oldDisabled !== undefined) {\n            const oldState = this.calculateAnimationStateName(!!oldChecked, !!oldIndeterminate, !!oldDisabled);\n            const newState = this.calculateAnimationStateName(this.checked, this.indeterminate, this.disabled);\n            this.animationClass = `${oldState}-${newState}`;\n        }\n        super.update(changedProperties);\n    }\n    calculateAnimationStateName(checked, indeterminate, disabled) {\n        if (disabled) {\n            return 'disabled';\n        }\n        else if (indeterminate) {\n            return 'indeterminate';\n        }\n        else if (checked) {\n            return 'checked';\n        }\n        else {\n            return 'unchecked';\n        }\n    }\n    // TODO(dfreedm): Make this use selected as a param after Polymer/internal#739\n    /** @soyTemplate */\n    renderRipple() {\n        return this.shouldRenderRipple ? this.renderRippleTemplate() : '';\n    }\n    /** @soyTemplate */\n    renderRippleTemplate() {\n        return html `<mwc-ripple\n        .disabled=\"${this.disabled}\"\n        unbounded></mwc-ripple>`;\n    }\n    /**\n     * @soyTemplate\n     * @soyAttributes checkboxAttributes: input\n     * @soyClasses checkboxClasses: .mdc-checkbox\n     */\n    render() {\n        const selected = this.indeterminate || this.checked;\n        /* eslint-disable eqeqeq */\n        // tslint:disable:triple-equals\n        /** @classMap */\n        const classes = {\n            'mdc-checkbox--disabled': this.disabled,\n            'mdc-checkbox--selected': selected,\n            'mdc-checkbox--touch': !this.reducedTouchTarget,\n            'mdc-ripple-upgraded--background-focused': this.focused,\n            // transition animiation classes\n            'mdc-checkbox--anim-checked-indeterminate': this.animationClass == 'checked-indeterminate',\n            'mdc-checkbox--anim-checked-unchecked': this.animationClass == 'checked-unchecked',\n            'mdc-checkbox--anim-indeterminate-checked': this.animationClass == 'indeterminate-checked',\n            'mdc-checkbox--anim-indeterminate-unchecked': this.animationClass == 'indeterminate-unchecked',\n            'mdc-checkbox--anim-unchecked-checked': this.animationClass == 'unchecked-checked',\n            'mdc-checkbox--anim-unchecked-indeterminate': this.animationClass == 'unchecked-indeterminate',\n        };\n        // tslint:enable:triple-equals\n        /* eslint-enable eqeqeq */\n        const ariaChecked = this.indeterminate ? 'mixed' : undefined;\n        return html `\n      <div class=\"mdc-checkbox mdc-checkbox--upgraded ${classMap(classes)}\">\n        <input type=\"checkbox\"\n              class=\"mdc-checkbox__native-control\"\n              name=\"${ifDefined(this.name)}\"\n              aria-checked=\"${ifDefined(ariaChecked)}\"\n              aria-label=\"${ifDefined(this.ariaLabel)}\"\n              aria-labelledby=\"${ifDefined(this.ariaLabelledBy)}\"\n              aria-describedby=\"${ifDefined(this.ariaDescribedBy)}\"\n              data-indeterminate=\"${this.indeterminate ? 'true' : 'false'}\"\n              ?disabled=\"${this.disabled}\"\n              .indeterminate=\"${this.indeterminate}\"\n              .checked=\"${this.checked}\"\n              .value=\"${this.value}\"\n              @change=\"${this.handleChange}\"\n              @focus=\"${this.handleFocus}\"\n              @blur=\"${this.handleBlur}\"\n              @mousedown=\"${this.handleRippleMouseDown}\"\n              @mouseenter=\"${this.handleRippleMouseEnter}\"\n              @mouseleave=\"${this.handleRippleMouseLeave}\"\n              @touchstart=\"${this.handleRippleTouchStart}\"\n              @touchend=\"${this.handleRippleDeactivate}\"\n              @touchcancel=\"${this.handleRippleDeactivate}\">\n        <div class=\"mdc-checkbox__background\"\n          @animationend=\"${this.resetAnimationClass}\">\n          <svg class=\"mdc-checkbox__checkmark\"\n              viewBox=\"0 0 24 24\">\n            <path class=\"mdc-checkbox__checkmark-path\"\n                  fill=\"none\"\n                  d=\"M1.73,12.91 8.1,19.28 22.79,4.59\"></path>\n          </svg>\n          <div class=\"mdc-checkbox__mixedmark\"></div>\n        </div>\n        ${this.renderRipple()}\n      </div>`;\n    }\n    setFormData(formData) {\n        if (this.name && this.checked) {\n            formData.append(this.name, this.value);\n        }\n    }\n    handleFocus() {\n        this.focused = true;\n        this.handleRippleFocus();\n    }\n    handleBlur() {\n        this.focused = false;\n        this.handleRippleBlur();\n    }\n    handleRippleMouseDown(event) {\n        const onUp = () => {\n            window.removeEventListener('mouseup', onUp);\n            this.handleRippleDeactivate();\n        };\n        window.addEventListener('mouseup', onUp);\n        this.rippleHandlers.startPress(event);\n    }\n    handleRippleTouchStart(event) {\n        this.rippleHandlers.startPress(event);\n    }\n    handleRippleDeactivate() {\n        this.rippleHandlers.endPress();\n    }\n    handleRippleMouseEnter() {\n        this.rippleHandlers.startHover();\n    }\n    handleRippleMouseLeave() {\n        this.rippleHandlers.endHover();\n    }\n    handleRippleFocus() {\n        this.rippleHandlers.startFocus();\n    }\n    handleRippleBlur() {\n        this.rippleHandlers.endFocus();\n    }\n    handleChange() {\n        this.checked = this.formElement.checked;\n        this.indeterminate = this.formElement.indeterminate;\n    }\n    resetAnimationClass() {\n        this.animationClass = '';\n    }\n    get isRippleActive() {\n        var _a;\n        return ((_a = this.rippleElement) === null || _a === void 0 ? void 0 : _a.isActive) || false;\n    }\n}\n__decorate([\n    query('.mdc-checkbox')\n], CheckboxBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('input')\n], CheckboxBase.prototype, \"formElement\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], CheckboxBase.prototype, \"checked\", void 0);\n__decorate([\n    property({ type: Boolean })\n], CheckboxBase.prototype, \"indeterminate\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], CheckboxBase.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: String, reflect: true })\n], CheckboxBase.prototype, \"name\", void 0);\n__decorate([\n    property({ type: String })\n], CheckboxBase.prototype, \"value\", void 0);\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-label' })\n], CheckboxBase.prototype, \"ariaLabel\", void 0);\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-labelledby' })\n], CheckboxBase.prototype, \"ariaLabelledBy\", void 0);\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-describedby' })\n], CheckboxBase.prototype, \"ariaDescribedBy\", void 0);\n__decorate([\n    property({ type: Boolean })\n], CheckboxBase.prototype, \"reducedTouchTarget\", void 0);\n__decorate([\n    state()\n], CheckboxBase.prototype, \"animationClass\", void 0);\n__decorate([\n    state()\n], CheckboxBase.prototype, \"shouldRenderRipple\", void 0);\n__decorate([\n    state()\n], CheckboxBase.prototype, \"focused\", void 0);\n__decorate([\n    queryAsync('mwc-ripple')\n], CheckboxBase.prototype, \"ripple\", void 0);\n__decorate([\n    eventOptions({ passive: true })\n], CheckboxBase.prototype, \"handleRippleTouchStart\", null);\n//# sourceMappingURL=mwc-checkbox-base.js.map","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\nimport MDCFormFieldFoundation from '@material/form-field/foundation.js';\nimport { BaseElement } from '@material/mwc-base/base-element.js';\nimport { FormElement } from '@material/mwc-base/form-element.js';\nimport { observer } from '@material/mwc-base/observer.js';\nimport { html } from 'lit';\nimport { property, query, queryAssignedNodes } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nexport class FormfieldBase extends BaseElement {\n    constructor() {\n        super(...arguments);\n        this.alignEnd = false;\n        this.spaceBetween = false;\n        this.nowrap = false;\n        this.label = '';\n        this.mdcFoundationClass = MDCFormFieldFoundation;\n    }\n    createAdapter() {\n        return {\n            registerInteractionHandler: (type, handler) => {\n                this.labelEl.addEventListener(type, handler);\n            },\n            deregisterInteractionHandler: (type, handler) => {\n                this.labelEl.removeEventListener(type, handler);\n            },\n            activateInputRipple: async () => {\n                const input = this.input;\n                if (input instanceof FormElement) {\n                    const ripple = await input.ripple;\n                    if (ripple) {\n                        ripple.startPress();\n                    }\n                }\n            },\n            deactivateInputRipple: async () => {\n                const input = this.input;\n                if (input instanceof FormElement) {\n                    const ripple = await input.ripple;\n                    if (ripple) {\n                        ripple.endPress();\n                    }\n                }\n            },\n        };\n    }\n    get input() {\n        var _a, _b;\n        return (_b = (_a = this.slottedInputs) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n    }\n    render() {\n        const classes = {\n            'mdc-form-field--align-end': this.alignEnd,\n            'mdc-form-field--space-between': this.spaceBetween,\n            'mdc-form-field--nowrap': this.nowrap\n        };\n        return html `\n      <div class=\"mdc-form-field ${classMap(classes)}\">\n        <slot></slot>\n        <label class=\"mdc-label\"\n               @click=\"${this._labelClick}\">${this.label}</label>\n      </div>`;\n    }\n    click() {\n        this._labelClick();\n    }\n    _labelClick() {\n        const input = this.input;\n        if (input) {\n            input.focus();\n            input.click();\n        }\n    }\n}\n__decorate([\n    property({ type: Boolean })\n], FormfieldBase.prototype, \"alignEnd\", void 0);\n__decorate([\n    property({ type: Boolean })\n], FormfieldBase.prototype, \"spaceBetween\", void 0);\n__decorate([\n    property({ type: Boolean })\n], FormfieldBase.prototype, \"nowrap\", void 0);\n__decorate([\n    property({ type: String }),\n    observer(async function (label) {\n        var _a;\n        (_a = this.input) === null || _a === void 0 ? void 0 : _a.setAttribute('aria-label', label);\n    })\n], FormfieldBase.prototype, \"label\", void 0);\n__decorate([\n    query('.mdc-form-field')\n], FormfieldBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    queryAssignedNodes('', true, '*')\n], FormfieldBase.prototype, \"slottedInputs\", void 0);\n__decorate([\n    query('label')\n], FormfieldBase.prototype, \"labelEl\", void 0);\n//# sourceMappingURL=mwc-formfield-base.js.map","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-ripple/mwc-ripple.js';\nimport { ariaProperty } from '@material/mwc-base/aria-property.js';\nimport { RippleHandlers } from '@material/mwc-ripple/ripple-handlers.js';\nimport { html, LitElement } from 'lit';\nimport { eventOptions, property, query, queryAsync, state } from 'lit/decorators.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\n/** @soyCompatible */\nexport class IconButtonBase extends LitElement {\n    constructor() {\n        super(...arguments);\n        this.disabled = false;\n        this.icon = '';\n        this.shouldRenderRipple = false;\n        this.rippleHandlers = new RippleHandlers(() => {\n            this.shouldRenderRipple = true;\n            return this.ripple;\n        });\n    }\n    /** @soyTemplate */\n    renderRipple() {\n        return this.shouldRenderRipple ? html `\n            <mwc-ripple\n                .disabled=\"${this.disabled}\"\n                unbounded>\n            </mwc-ripple>` :\n            '';\n    }\n    focus() {\n        const buttonElement = this.buttonElement;\n        if (buttonElement) {\n            this.rippleHandlers.startFocus();\n            buttonElement.focus();\n        }\n    }\n    blur() {\n        const buttonElement = this.buttonElement;\n        if (buttonElement) {\n            this.rippleHandlers.endFocus();\n            buttonElement.blur();\n        }\n    }\n    /** @soyTemplate */\n    render() {\n        return html `<button\n        class=\"mdc-icon-button mdc-icon-button--display-flex\"\n        aria-label=\"${this.ariaLabel || this.icon}\"\n        aria-haspopup=\"${ifDefined(this.ariaHasPopup)}\"\n        ?disabled=\"${this.disabled}\"\n        @focus=\"${this.handleRippleFocus}\"\n        @blur=\"${this.handleRippleBlur}\"\n        @mousedown=\"${this.handleRippleMouseDown}\"\n        @mouseenter=\"${this.handleRippleMouseEnter}\"\n        @mouseleave=\"${this.handleRippleMouseLeave}\"\n        @touchstart=\"${this.handleRippleTouchStart}\"\n        @touchend=\"${this.handleRippleDeactivate}\"\n        @touchcancel=\"${this.handleRippleDeactivate}\"\n    >${this.renderRipple()}\n    ${this.icon ? html `<i class=\"material-icons\">${this.icon}</i>` : ''}\n    <span\n      ><slot></slot\n    ></span>\n  </button>`;\n    }\n    handleRippleMouseDown(event) {\n        const onUp = () => {\n            window.removeEventListener('mouseup', onUp);\n            this.handleRippleDeactivate();\n        };\n        window.addEventListener('mouseup', onUp);\n        this.rippleHandlers.startPress(event);\n    }\n    handleRippleTouchStart(event) {\n        this.rippleHandlers.startPress(event);\n    }\n    handleRippleDeactivate() {\n        this.rippleHandlers.endPress();\n    }\n    handleRippleMouseEnter() {\n        this.rippleHandlers.startHover();\n    }\n    handleRippleMouseLeave() {\n        this.rippleHandlers.endHover();\n    }\n    handleRippleFocus() {\n        this.rippleHandlers.startFocus();\n    }\n    handleRippleBlur() {\n        this.rippleHandlers.endFocus();\n    }\n}\n__decorate([\n    property({ type: Boolean, reflect: true })\n], IconButtonBase.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: String })\n], IconButtonBase.prototype, \"icon\", void 0);\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-label' })\n], IconButtonBase.prototype, \"ariaLabel\", void 0);\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-haspopup' })\n], IconButtonBase.prototype, \"ariaHasPopup\", void 0);\n__decorate([\n    query('button')\n], IconButtonBase.prototype, \"buttonElement\", void 0);\n__decorate([\n    queryAsync('mwc-ripple')\n], IconButtonBase.prototype, \"ripple\", void 0);\n__decorate([\n    state()\n], IconButtonBase.prototype, \"shouldRenderRipple\", void 0);\n__decorate([\n    eventOptions({ passive: true })\n], IconButtonBase.prototype, \"handleRippleMouseDown\", null);\n__decorate([\n    eventOptions({ passive: true })\n], IconButtonBase.prototype, \"handleRippleTouchStart\", null);\n//# sourceMappingURL=mwc-icon-button-base.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-ripple/mwc-ripple.js';\nimport { observer } from '@material/mwc-base/observer.js';\nimport { RippleHandlers } from '@material/mwc-ripple/ripple-handlers.js';\nimport { html, LitElement } from 'lit';\nimport { property, query, queryAsync, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\n/**\n * @fires request-selected {RequestSelectedDetail}\n * @fires list-item-rendered\n */\nexport class ListItemBase extends LitElement {\n    constructor() {\n        super(...arguments);\n        this.value = '';\n        this.group = null;\n        this.tabindex = -1;\n        this.disabled = false;\n        this.twoline = false;\n        this.activated = false;\n        this.graphic = null;\n        this.multipleGraphics = false;\n        this.hasMeta = false;\n        this.noninteractive = false;\n        this.selected = false;\n        this.shouldRenderRipple = false;\n        this._managingList = null;\n        this.boundOnClick = this.onClick.bind(this);\n        this._firstChanged = true;\n        this._skipPropRequest = false;\n        this.rippleHandlers = new RippleHandlers(() => {\n            this.shouldRenderRipple = true;\n            return this.ripple;\n        });\n        this.listeners = [\n            {\n                target: this,\n                eventNames: ['click'],\n                cb: () => {\n                    this.onClick();\n                },\n            },\n            {\n                target: this,\n                eventNames: ['mouseenter'],\n                cb: this.rippleHandlers.startHover,\n            },\n            {\n                target: this,\n                eventNames: ['mouseleave'],\n                cb: this.rippleHandlers.endHover,\n            },\n            {\n                target: this,\n                eventNames: ['focus'],\n                cb: this.rippleHandlers.startFocus,\n            },\n            {\n                target: this,\n                eventNames: ['blur'],\n                cb: this.rippleHandlers.endFocus,\n            },\n            {\n                target: this,\n                eventNames: ['mousedown', 'touchstart'],\n                cb: (e) => {\n                    const name = e.type;\n                    this.onDown(name === 'mousedown' ? 'mouseup' : 'touchend', e);\n                },\n            },\n        ];\n    }\n    get text() {\n        const textContent = this.textContent;\n        return textContent ? textContent.trim() : '';\n    }\n    render() {\n        const text = this.renderText();\n        const graphic = this.graphic ? this.renderGraphic() : html ``;\n        const meta = this.hasMeta ? this.renderMeta() : html ``;\n        return html `\n      ${this.renderRipple()}\n      ${graphic}\n      ${text}\n      ${meta}`;\n    }\n    renderRipple() {\n        if (this.shouldRenderRipple) {\n            return html `\n      <mwc-ripple\n        .activated=${this.activated}>\n      </mwc-ripple>`;\n        }\n        else if (this.activated) {\n            return html `<div class=\"fake-activated-ripple\"></div>`;\n        }\n        else {\n            return '';\n        }\n    }\n    renderGraphic() {\n        const graphicClasses = {\n            multi: this.multipleGraphics,\n        };\n        return html `\n      <span class=\"mdc-deprecated-list-item__graphic material-icons ${classMap(graphicClasses)}\">\n        <slot name=\"graphic\"></slot>\n      </span>`;\n    }\n    renderMeta() {\n        return html `\n      <span class=\"mdc-deprecated-list-item__meta material-icons\">\n        <slot name=\"meta\"></slot>\n      </span>`;\n    }\n    renderText() {\n        const inner = this.twoline ? this.renderTwoline() : this.renderSingleLine();\n        return html `\n      <span class=\"mdc-deprecated-list-item__text\">\n        ${inner}\n      </span>`;\n    }\n    renderSingleLine() {\n        return html `<slot></slot>`;\n    }\n    renderTwoline() {\n        return html `\n      <span class=\"mdc-deprecated-list-item__primary-text\">\n        <slot></slot>\n      </span>\n      <span class=\"mdc-deprecated-list-item__secondary-text\">\n        <slot name=\"secondary\"></slot>\n      </span>\n    `;\n    }\n    onClick() {\n        this.fireRequestSelected(!this.selected, 'interaction');\n    }\n    onDown(upName, evt) {\n        const onUp = () => {\n            window.removeEventListener(upName, onUp);\n            this.rippleHandlers.endPress();\n        };\n        window.addEventListener(upName, onUp);\n        this.rippleHandlers.startPress(evt);\n    }\n    fireRequestSelected(selected, source) {\n        if (this.noninteractive) {\n            return;\n        }\n        const customEv = new CustomEvent('request-selected', { bubbles: true, composed: true, detail: { source, selected } });\n        this.dispatchEvent(customEv);\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        if (!this.noninteractive) {\n            this.setAttribute('mwc-list-item', '');\n        }\n        for (const listener of this.listeners) {\n            for (const eventName of listener.eventNames) {\n                listener.target.addEventListener(eventName, listener.cb, { passive: true });\n            }\n        }\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        for (const listener of this.listeners) {\n            for (const eventName of listener.eventNames) {\n                listener.target.removeEventListener(eventName, listener.cb);\n            }\n        }\n        if (this._managingList) {\n            this._managingList.debouncedLayout ?\n                this._managingList.debouncedLayout(true) :\n                this._managingList.layout(true);\n        }\n    }\n    // composed flag, event fire through shadow root and up through composed tree\n    firstUpdated() {\n        const ev = new Event('list-item-rendered', { bubbles: true, composed: true });\n        this.dispatchEvent(ev);\n    }\n}\n__decorate([\n    query('slot')\n], ListItemBase.prototype, \"slotElement\", void 0);\n__decorate([\n    queryAsync('mwc-ripple')\n], ListItemBase.prototype, \"ripple\", void 0);\n__decorate([\n    property({ type: String })\n], ListItemBase.prototype, \"value\", void 0);\n__decorate([\n    property({ type: String, reflect: true })\n], ListItemBase.prototype, \"group\", void 0);\n__decorate([\n    property({ type: Number, reflect: true })\n], ListItemBase.prototype, \"tabindex\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true }),\n    observer(function (value) {\n        if (value) {\n            this.setAttribute('aria-disabled', 'true');\n        }\n        else {\n            this.setAttribute('aria-disabled', 'false');\n        }\n    })\n], ListItemBase.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], ListItemBase.prototype, \"twoline\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], ListItemBase.prototype, \"activated\", void 0);\n__decorate([\n    property({ type: String, reflect: true })\n], ListItemBase.prototype, \"graphic\", void 0);\n__decorate([\n    property({ type: Boolean })\n], ListItemBase.prototype, \"multipleGraphics\", void 0);\n__decorate([\n    property({ type: Boolean })\n], ListItemBase.prototype, \"hasMeta\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true }),\n    observer(function (value) {\n        if (value) {\n            this.removeAttribute('aria-checked');\n            this.removeAttribute('mwc-list-item');\n            this.selected = false;\n            this.activated = false;\n            this.tabIndex = -1;\n        }\n        else {\n            this.setAttribute('mwc-list-item', '');\n        }\n    })\n], ListItemBase.prototype, \"noninteractive\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true }),\n    observer(function (value) {\n        const role = this.getAttribute('role');\n        const isAriaSelectable = role === 'gridcell' || role === 'option' ||\n            role === 'row' || role === 'tab';\n        if (isAriaSelectable && value) {\n            this.setAttribute('aria-selected', 'true');\n        }\n        else if (isAriaSelectable) {\n            this.setAttribute('aria-selected', 'false');\n        }\n        if (this._firstChanged) {\n            this._firstChanged = false;\n            return;\n        }\n        if (this._skipPropRequest) {\n            return;\n        }\n        this.fireRequestSelected(value, 'property');\n    })\n], ListItemBase.prototype, \"selected\", void 0);\n__decorate([\n    state()\n], ListItemBase.prototype, \"shouldRenderRipple\", void 0);\n__decorate([\n    state()\n], ListItemBase.prototype, \"_managingList\", void 0);\n//# sourceMappingURL=mwc-list-item-base.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport './mwc-list-item.js';\nimport { BaseElement } from '@material/mwc-base/base-element.js';\nimport { observer } from '@material/mwc-base/observer.js';\nimport { deepActiveElementPath, doesElementContainFocus, isNodeElement } from '@material/mwc-base/utils.js';\nimport { html } from 'lit';\nimport { property, query, queryAssignedNodes } from 'lit/decorators.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport MDCListFoundation, { isIndexSet } from './mwc-list-foundation.js';\nexport { createSetFromIndex, isEventMulti, isIndexSet } from './mwc-list-foundation.js';\nfunction debounceLayout(callback, waitInMS = 50) {\n    let timeoutId;\n    // tslint:disable-next-line\n    return function (updateItems = true) {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() => {\n            callback(updateItems);\n        }, waitInMS);\n    };\n}\nconst isListItem = (element) => {\n    return element.hasAttribute('mwc-list-item');\n};\nfunction clearAndCreateItemsReadyPromise() {\n    const oldResolver = this.itemsReadyResolver;\n    this.itemsReady = new Promise((res) => {\n        // TODO(b/175626389): Type '(value: never[] | PromiseLike<never[]>) => void'\n        // is not assignable to type '(value?: never[] | PromiseLike<never[]> |\n        // undefined) => void'.\n        return this.itemsReadyResolver = res;\n    });\n    oldResolver();\n}\n/**\n * @fires selected {SelectedDetail}\n * @fires action {ActionDetail}\n * @fires items-updated\n */\nexport class ListBase extends BaseElement {\n    constructor() {\n        super();\n        this.mdcAdapter = null;\n        this.mdcFoundationClass = MDCListFoundation;\n        this.activatable = false;\n        this.multi = false;\n        this.wrapFocus = false;\n        this.itemRoles = null;\n        this.innerRole = null;\n        this.innerAriaLabel = null;\n        this.rootTabbable = false;\n        this.previousTabindex = null;\n        this.noninteractive = false;\n        this.itemsReadyResolver = (() => {\n            //\n        });\n        this.itemsReady = Promise.resolve([]);\n        // tslint:enable:ban-ts-ignore\n        this.items_ = [];\n        const debouncedFunction = debounceLayout(this.layout.bind(this));\n        this.debouncedLayout = (updateItems = true) => {\n            clearAndCreateItemsReadyPromise.call(this);\n            debouncedFunction(updateItems);\n        };\n    }\n    // tslint:disable:ban-ts-ignore\n    async getUpdateComplete() {\n        // @ts-ignore\n        const result = await super.getUpdateComplete();\n        await this.itemsReady;\n        return result;\n    }\n    get items() {\n        return this.items_;\n    }\n    updateItems() {\n        var _a;\n        const nodes = (_a = this.assignedElements) !== null && _a !== void 0 ? _a : [];\n        const listItems = [];\n        for (const node of nodes) {\n            if (isListItem(node)) {\n                listItems.push(node);\n                node._managingList = this;\n            }\n            if (node.hasAttribute('divider') && !node.hasAttribute('role')) {\n                node.setAttribute('role', 'separator');\n            }\n        }\n        this.items_ = listItems;\n        const selectedIndices = new Set();\n        this.items_.forEach((item, index) => {\n            if (this.itemRoles) {\n                item.setAttribute('role', this.itemRoles);\n            }\n            else {\n                item.removeAttribute('role');\n            }\n            if (item.selected) {\n                selectedIndices.add(index);\n            }\n        });\n        if (this.multi) {\n            this.select(selectedIndices);\n        }\n        else {\n            const index = selectedIndices.size ? selectedIndices.entries().next().value[1] : -1;\n            this.select(index);\n        }\n        const itemsUpdatedEv = new Event('items-updated', { bubbles: true, composed: true });\n        this.dispatchEvent(itemsUpdatedEv);\n    }\n    get selected() {\n        const index = this.index;\n        if (!isIndexSet(index)) {\n            if (index === -1) {\n                return null;\n            }\n            return this.items[index];\n        }\n        const selected = [];\n        for (const entry of index) {\n            selected.push(this.items[entry]);\n        }\n        return selected;\n    }\n    get index() {\n        if (this.mdcFoundation) {\n            return this.mdcFoundation.getSelectedIndex();\n        }\n        return -1;\n    }\n    render() {\n        const role = this.innerRole === null ? undefined : this.innerRole;\n        const ariaLabel = this.innerAriaLabel === null ? undefined : this.innerAriaLabel;\n        const tabindex = this.rootTabbable ? '0' : '-1';\n        return html `\n      <!-- @ts-ignore -->\n      <ul\n          tabindex=${tabindex}\n          role=\"${ifDefined(role)}\"\n          aria-label=\"${ifDefined(ariaLabel)}\"\n          class=\"mdc-deprecated-list\"\n          @keydown=${this.onKeydown}\n          @focusin=${this.onFocusIn}\n          @focusout=${this.onFocusOut}\n          @request-selected=${this.onRequestSelected}\n          @list-item-rendered=${this.onListItemConnected}>\n        <slot></slot>\n        ${this.renderPlaceholder()}\n      </ul>\n    `;\n    }\n    renderPlaceholder() {\n        var _a;\n        const nodes = (_a = this.assignedElements) !== null && _a !== void 0 ? _a : [];\n        if (this.emptyMessage !== undefined && nodes.length === 0) {\n            return html `\n        <mwc-list-item noninteractive>${this.emptyMessage}</mwc-list-item>\n      `;\n        }\n        return null;\n    }\n    firstUpdated() {\n        super.firstUpdated();\n        if (!this.items.length) {\n            // required because this is called before observers\n            this.mdcFoundation.setMulti(this.multi);\n            // for when children upgrade before list\n            this.layout();\n        }\n    }\n    onFocusIn(evt) {\n        if (this.mdcFoundation && this.mdcRoot) {\n            const index = this.getIndexOfTarget(evt);\n            this.mdcFoundation.handleFocusIn(evt, index);\n        }\n    }\n    onFocusOut(evt) {\n        if (this.mdcFoundation && this.mdcRoot) {\n            const index = this.getIndexOfTarget(evt);\n            this.mdcFoundation.handleFocusOut(evt, index);\n        }\n    }\n    onKeydown(evt) {\n        if (this.mdcFoundation && this.mdcRoot) {\n            const index = this.getIndexOfTarget(evt);\n            const target = evt.target;\n            const isRootListItem = isListItem(target);\n            this.mdcFoundation.handleKeydown(evt, isRootListItem, index);\n        }\n    }\n    onRequestSelected(evt) {\n        if (this.mdcFoundation) {\n            let index = this.getIndexOfTarget(evt);\n            // might happen in shady dom slowness. Recalc children\n            if (index === -1) {\n                this.layout();\n                index = this.getIndexOfTarget(evt);\n                // still not found; may not be mwc-list-item. Unsupported case.\n                if (index === -1) {\n                    return;\n                }\n            }\n            const element = this.items[index];\n            if (element.disabled) {\n                return;\n            }\n            const selected = evt.detail.selected;\n            const source = evt.detail.source;\n            this.mdcFoundation.handleSingleSelection(index, source === 'interaction', selected);\n            evt.stopPropagation();\n        }\n    }\n    getIndexOfTarget(evt) {\n        const elements = this.items;\n        const path = evt.composedPath();\n        for (const pathItem of path) {\n            let index = -1;\n            if (isNodeElement(pathItem) && isListItem(pathItem)) {\n                index = elements.indexOf(pathItem);\n            }\n            if (index !== -1) {\n                return index;\n            }\n        }\n        return -1;\n    }\n    createAdapter() {\n        this.mdcAdapter = {\n            getListItemCount: () => {\n                if (this.mdcRoot) {\n                    return this.items.length;\n                }\n                return 0;\n            },\n            getFocusedElementIndex: this.getFocusedItemIndex,\n            getAttributeForElementIndex: (index, attr) => {\n                const listElement = this.mdcRoot;\n                if (!listElement) {\n                    return '';\n                }\n                const element = this.items[index];\n                return element ? element.getAttribute(attr) : '';\n            },\n            setAttributeForElementIndex: (index, attr, val) => {\n                if (!this.mdcRoot) {\n                    return;\n                }\n                const element = this.items[index];\n                if (element) {\n                    element.setAttribute(attr, val);\n                }\n            },\n            focusItemAtIndex: (index) => {\n                const element = this.items[index];\n                if (element) {\n                    element.focus();\n                }\n            },\n            setTabIndexForElementIndex: (index, value) => {\n                const item = this.items[index];\n                if (item) {\n                    item.tabindex = value;\n                }\n            },\n            notifyAction: (index) => {\n                const init = { bubbles: true, composed: true };\n                init.detail = { index };\n                const ev = new CustomEvent('action', init);\n                this.dispatchEvent(ev);\n            },\n            notifySelected: (index, diff) => {\n                const init = { bubbles: true, composed: true };\n                init.detail = { index, diff };\n                const ev = new CustomEvent('selected', init);\n                this.dispatchEvent(ev);\n            },\n            isFocusInsideList: () => {\n                return doesElementContainFocus(this);\n            },\n            isRootFocused: () => {\n                const mdcRoot = this.mdcRoot;\n                const root = mdcRoot.getRootNode();\n                return root.activeElement === mdcRoot;\n            },\n            setDisabledStateForElementIndex: (index, value) => {\n                const item = this.items[index];\n                if (!item) {\n                    return;\n                }\n                item.disabled = value;\n            },\n            getDisabledStateForElementIndex: (index) => {\n                const item = this.items[index];\n                if (!item) {\n                    return false;\n                }\n                return item.disabled;\n            },\n            setSelectedStateForElementIndex: (index, value) => {\n                const item = this.items[index];\n                if (!item) {\n                    return;\n                }\n                item.selected = value;\n            },\n            getSelectedStateForElementIndex: (index) => {\n                const item = this.items[index];\n                if (!item) {\n                    return false;\n                }\n                return item.selected;\n            },\n            setActivatedStateForElementIndex: (index, value) => {\n                const item = this.items[index];\n                if (!item) {\n                    return;\n                }\n                item.activated = value;\n            },\n        };\n        return this.mdcAdapter;\n    }\n    selectUi(index, activate = false) {\n        const item = this.items[index];\n        if (item) {\n            item.selected = true;\n            item.activated = activate;\n        }\n    }\n    deselectUi(index) {\n        const item = this.items[index];\n        if (item) {\n            item.selected = false;\n            item.activated = false;\n        }\n    }\n    select(index) {\n        if (!this.mdcFoundation) {\n            return;\n        }\n        this.mdcFoundation.setSelectedIndex(index);\n    }\n    toggle(index, force) {\n        if (this.multi) {\n            this.mdcFoundation.toggleMultiAtIndex(index, force);\n        }\n    }\n    onListItemConnected(e) {\n        const target = e.target;\n        this.layout(this.items.indexOf(target) === -1);\n    }\n    layout(updateItems = true) {\n        if (updateItems) {\n            this.updateItems();\n        }\n        const first = this.items[0];\n        for (const item of this.items) {\n            item.tabindex = -1;\n        }\n        if (first) {\n            if (this.noninteractive) {\n                if (!this.previousTabindex) {\n                    this.previousTabindex = first;\n                }\n            }\n            else {\n                first.tabindex = 0;\n            }\n        }\n        this.itemsReadyResolver();\n    }\n    getFocusedItemIndex() {\n        if (!this.mdcRoot) {\n            return -1;\n        }\n        if (!this.items.length) {\n            return -1;\n        }\n        const activeElementPath = deepActiveElementPath();\n        if (!activeElementPath.length) {\n            return -1;\n        }\n        for (let i = activeElementPath.length - 1; i >= 0; i--) {\n            const activeItem = activeElementPath[i];\n            if (isListItem(activeItem)) {\n                return this.items.indexOf(activeItem);\n            }\n        }\n        return -1;\n    }\n    focusItemAtIndex(index) {\n        for (const item of this.items) {\n            if (item.tabindex === 0) {\n                item.tabindex = -1;\n                break;\n            }\n        }\n        this.items[index].tabindex = 0;\n        this.items[index].focus();\n    }\n    focus() {\n        const root = this.mdcRoot;\n        if (root) {\n            root.focus();\n        }\n    }\n    blur() {\n        const root = this.mdcRoot;\n        if (root) {\n            root.blur();\n        }\n    }\n}\n__decorate([\n    property({ type: String })\n], ListBase.prototype, \"emptyMessage\", void 0);\n__decorate([\n    query('.mdc-deprecated-list')\n], ListBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    queryAssignedNodes('', true, '*')\n], ListBase.prototype, \"assignedElements\", void 0);\n__decorate([\n    queryAssignedNodes('', true, '[tabindex=\"0\"]')\n], ListBase.prototype, \"tabbableElements\", void 0);\n__decorate([\n    property({ type: Boolean }),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.setUseActivatedClass(value);\n        }\n    })\n], ListBase.prototype, \"activatable\", void 0);\n__decorate([\n    property({ type: Boolean }),\n    observer(function (newValue, oldValue) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.setMulti(newValue);\n        }\n        if (oldValue !== undefined) {\n            this.layout();\n        }\n    })\n], ListBase.prototype, \"multi\", void 0);\n__decorate([\n    property({ type: Boolean }),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.setWrapFocus(value);\n        }\n    })\n], ListBase.prototype, \"wrapFocus\", void 0);\n__decorate([\n    property({ type: String }),\n    observer(function (_newValue, oldValue) {\n        if (oldValue !== undefined) {\n            this.updateItems();\n        }\n    })\n], ListBase.prototype, \"itemRoles\", void 0);\n__decorate([\n    property({ type: String })\n], ListBase.prototype, \"innerRole\", void 0);\n__decorate([\n    property({ type: String })\n], ListBase.prototype, \"innerAriaLabel\", void 0);\n__decorate([\n    property({ type: Boolean })\n], ListBase.prototype, \"rootTabbable\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true }),\n    observer(function (value) {\n        var _a, _b;\n        if (value) {\n            const tabbable = (_b = (_a = this.tabbableElements) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n            this.previousTabindex = tabbable;\n            if (tabbable) {\n                tabbable.setAttribute('tabindex', '-1');\n            }\n        }\n        else if (!value && this.previousTabindex) {\n            this.previousTabindex.setAttribute('tabindex', '0');\n            this.previousTabindex = null;\n        }\n    })\n], ListBase.prototype, \"noninteractive\", void 0);\n//# sourceMappingURL=mwc-list-base.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\nimport { Corner as CornerEnum, CornerBit } from '@material/menu-surface/constants.js';\nimport MDCMenuSurfaceFoundation from '@material/menu-surface/foundation.js';\nimport { addHasRemoveClass, BaseElement } from '@material/mwc-base/base-element.js';\nimport { observer } from '@material/mwc-base/observer.js';\nimport { deepActiveElementPath, doesElementContainFocus } from '@material/mwc-base/utils.js';\nimport { html } from 'lit';\nimport { property, query, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { styleMap } from 'lit/directives/style-map.js';\n// tslint:disable:no-bitwise\n// required for closure compiler\nconst stringToCorner = {\n    'TOP_LEFT': CornerEnum.TOP_LEFT,\n    'TOP_RIGHT': CornerEnum.TOP_RIGHT,\n    'BOTTOM_LEFT': CornerEnum.BOTTOM_LEFT,\n    'BOTTOM_RIGHT': CornerEnum.BOTTOM_RIGHT,\n    'TOP_START': CornerEnum.TOP_START,\n    'TOP_END': CornerEnum.TOP_END,\n    'BOTTOM_START': CornerEnum.BOTTOM_START,\n    'BOTTOM_END': CornerEnum.BOTTOM_END,\n};\n/**\n * @fires opened\n * @fires closed\n */\nexport class MenuSurfaceBase extends BaseElement {\n    constructor() {\n        super(...arguments);\n        this.mdcFoundationClass = MDCMenuSurfaceFoundation;\n        this.absolute = false;\n        this.fullwidth = false;\n        this.fixed = false;\n        this.x = null;\n        this.y = null;\n        // must be defined before open or else race condition in foundation occurs.\n        this.quick = false;\n        this.open = false;\n        this.stayOpenOnBodyClick = false;\n        this.bitwiseCorner = CornerEnum.TOP_START;\n        this.previousMenuCorner = null;\n        // must be defined before observer of anchor corner for initialization\n        this.menuCorner = 'START';\n        this.corner = 'TOP_START';\n        this.styleTop = '';\n        this.styleLeft = '';\n        this.styleRight = '';\n        this.styleBottom = '';\n        this.styleMaxHeight = '';\n        this.styleTransformOrigin = '';\n        this.anchor = null;\n        this.previouslyFocused = null;\n        this.previousAnchor = null;\n        this.onBodyClickBound = () => undefined;\n    }\n    render() {\n        return this.renderSurface();\n    }\n    renderSurface() {\n        const classes = this.getRootClasses();\n        const styles = this.getRootStyles();\n        return html `\n      <div\n          class=${classMap(classes)}\n          style=\"${styleMap(styles)}\"\n          @keydown=${this.onKeydown}\n          @opened=${this.registerBodyClick}\n          @closed=${this.deregisterBodyClick}>\n        ${this.renderContent()}\n      </div>`;\n    }\n    getRootClasses() {\n        return {\n            'mdc-menu-surface': true,\n            'mdc-menu-surface--fixed': this.fixed,\n            'mdc-menu-surface--fullwidth': this.fullwidth,\n        };\n    }\n    getRootStyles() {\n        return {\n            'top': this.styleTop,\n            'left': this.styleLeft,\n            'right': this.styleRight,\n            'bottom': this.styleBottom,\n            'max-height': this.styleMaxHeight,\n            'transform-origin': this.styleTransformOrigin,\n        };\n    }\n    renderContent() {\n        return html `<slot></slot>`;\n    }\n    createAdapter() {\n        return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), { hasAnchor: () => {\n                return !!this.anchor;\n            }, notifyClose: () => {\n                const init = { bubbles: true, composed: true };\n                const ev = new CustomEvent('closed', init);\n                this.open = false;\n                this.mdcRoot.dispatchEvent(ev);\n            }, notifyClosing: () => {\n                const init = { bubbles: true, composed: true };\n                const ev = new CustomEvent('closing', init);\n                this.mdcRoot.dispatchEvent(ev);\n            }, notifyOpen: () => {\n                const init = { bubbles: true, composed: true };\n                const ev = new CustomEvent('opened', init);\n                this.open = true;\n                this.mdcRoot.dispatchEvent(ev);\n            }, notifyOpening: () => {\n                const init = { bubbles: true, composed: true };\n                const ev = new CustomEvent('opening', init);\n                this.mdcRoot.dispatchEvent(ev);\n            }, isElementInContainer: () => false, isRtl: () => {\n                if (this.mdcRoot) {\n                    return getComputedStyle(this.mdcRoot).direction === 'rtl';\n                }\n                return false;\n            }, setTransformOrigin: (origin) => {\n                const root = this.mdcRoot;\n                if (!root) {\n                    return;\n                }\n                this.styleTransformOrigin = origin;\n            }, isFocused: () => {\n                return doesElementContainFocus(this);\n            }, saveFocus: () => {\n                const activeElementPath = deepActiveElementPath();\n                const pathLength = activeElementPath.length;\n                if (!pathLength) {\n                    this.previouslyFocused = null;\n                }\n                this.previouslyFocused = activeElementPath[pathLength - 1];\n            }, restoreFocus: () => {\n                if (!this.previouslyFocused) {\n                    return;\n                }\n                if ('focus' in this.previouslyFocused) {\n                    this.previouslyFocused.focus();\n                }\n            }, getInnerDimensions: () => {\n                const mdcRoot = this.mdcRoot;\n                if (!mdcRoot) {\n                    return { width: 0, height: 0 };\n                }\n                return { width: mdcRoot.offsetWidth, height: mdcRoot.offsetHeight };\n            }, getAnchorDimensions: () => {\n                const anchorElement = this.anchor;\n                return anchorElement ? anchorElement.getBoundingClientRect() : null;\n            }, getBodyDimensions: () => {\n                return {\n                    width: document.body.clientWidth,\n                    height: document.body.clientHeight,\n                };\n            }, getWindowDimensions: () => {\n                return {\n                    width: window.innerWidth,\n                    height: window.innerHeight,\n                };\n            }, getWindowScroll: () => {\n                return {\n                    x: window.pageXOffset,\n                    y: window.pageYOffset,\n                };\n            }, setPosition: (position) => {\n                const mdcRoot = this.mdcRoot;\n                if (!mdcRoot) {\n                    return;\n                }\n                this.styleLeft = 'left' in position ? `${position.left}px` : '';\n                this.styleRight = 'right' in position ? `${position.right}px` : '';\n                this.styleTop = 'top' in position ? `${position.top}px` : '';\n                this.styleBottom = 'bottom' in position ? `${position.bottom}px` : '';\n            }, setMaxHeight: async (height) => {\n                const mdcRoot = this.mdcRoot;\n                if (!mdcRoot) {\n                    return;\n                }\n                // must set both for IE support as IE will not set a var\n                this.styleMaxHeight = height;\n                await this.updateComplete;\n                this.styleMaxHeight = `var(--mdc-menu-max-height, ${height})`;\n            } });\n    }\n    onKeydown(evt) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.handleKeydown(evt);\n        }\n    }\n    onBodyClick(evt) {\n        if (this.stayOpenOnBodyClick) {\n            return;\n        }\n        const path = evt.composedPath();\n        if (path.indexOf(this) === -1) {\n            this.close();\n        }\n    }\n    registerBodyClick() {\n        this.onBodyClickBound = this.onBodyClick.bind(this);\n        // capture otherwise listener closes menu after quick menu opens\n        document.body.addEventListener('click', this.onBodyClickBound, { passive: true, capture: true });\n    }\n    deregisterBodyClick() {\n        document.body.removeEventListener('click', this.onBodyClickBound, { capture: true });\n    }\n    onOpenChanged(isOpen, wasOpen) {\n        if (this.mdcFoundation) {\n            if (isOpen) {\n                this.mdcFoundation.open();\n                // wasOpen helps with first render (when it is `undefined`) perf\n            }\n            else if (wasOpen !== undefined) {\n                this.mdcFoundation.close();\n            }\n        }\n    }\n    close() {\n        this.open = false;\n    }\n    show() {\n        this.open = true;\n    }\n}\n__decorate([\n    query('.mdc-menu-surface')\n], MenuSurfaceBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('slot')\n], MenuSurfaceBase.prototype, \"slotElement\", void 0);\n__decorate([\n    property({ type: Boolean }),\n    observer(function (isAbsolute) {\n        if (this.mdcFoundation && !this.fixed) {\n            this.mdcFoundation.setIsHoisted(isAbsolute);\n        }\n    })\n], MenuSurfaceBase.prototype, \"absolute\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuSurfaceBase.prototype, \"fullwidth\", void 0);\n__decorate([\n    property({ type: Boolean }),\n    observer(function (isFixed) {\n        if (this.mdcFoundation && !this.absolute) {\n            this.mdcFoundation.setFixedPosition(isFixed);\n        }\n    })\n], MenuSurfaceBase.prototype, \"fixed\", void 0);\n__decorate([\n    property({ type: Number }),\n    observer(function (value) {\n        if (this.mdcFoundation && this.y !== null && value !== null) {\n            this.mdcFoundation.setAbsolutePosition(value, this.y);\n            this.mdcFoundation.setAnchorMargin({ left: value, top: this.y, right: -value, bottom: this.y });\n        }\n    })\n], MenuSurfaceBase.prototype, \"x\", void 0);\n__decorate([\n    property({ type: Number }),\n    observer(function (value) {\n        if (this.mdcFoundation && this.x !== null && value !== null) {\n            this.mdcFoundation.setAbsolutePosition(this.x, value);\n            this.mdcFoundation.setAnchorMargin({ left: this.x, top: value, right: -this.x, bottom: value });\n        }\n    })\n], MenuSurfaceBase.prototype, \"y\", void 0);\n__decorate([\n    property({ type: Boolean }),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.setQuickOpen(value);\n        }\n    })\n], MenuSurfaceBase.prototype, \"quick\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true }),\n    observer(function (isOpen, wasOpen) {\n        this.onOpenChanged(isOpen, wasOpen);\n    })\n], MenuSurfaceBase.prototype, \"open\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuSurfaceBase.prototype, \"stayOpenOnBodyClick\", void 0);\n__decorate([\n    state(),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            if (value) {\n                this.mdcFoundation.setAnchorCorner(value);\n            }\n            else {\n                this.mdcFoundation.setAnchorCorner(value);\n            }\n        }\n    })\n], MenuSurfaceBase.prototype, \"bitwiseCorner\", void 0);\n__decorate([\n    property({ type: String }),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            const isValidValue = value === 'START' || value === 'END';\n            const isFirstTimeSet = this.previousMenuCorner === null;\n            const cornerChanged = !isFirstTimeSet && value !== this.previousMenuCorner;\n            const initiallySetToEnd = isFirstTimeSet && value === 'END';\n            if (isValidValue && (cornerChanged || initiallySetToEnd)) {\n                this.bitwiseCorner = this.bitwiseCorner ^ CornerBit.RIGHT;\n                this.mdcFoundation.flipCornerHorizontally();\n                this.previousMenuCorner = value;\n            }\n        }\n    })\n], MenuSurfaceBase.prototype, \"menuCorner\", void 0);\n__decorate([\n    property({ type: String }),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            if (value) {\n                let newCorner = stringToCorner[value];\n                if (this.menuCorner === 'END') {\n                    newCorner = newCorner ^ CornerBit.RIGHT;\n                }\n                this.bitwiseCorner = newCorner;\n            }\n        }\n    })\n], MenuSurfaceBase.prototype, \"corner\", void 0);\n__decorate([\n    state()\n], MenuSurfaceBase.prototype, \"styleTop\", void 0);\n__decorate([\n    state()\n], MenuSurfaceBase.prototype, \"styleLeft\", void 0);\n__decorate([\n    state()\n], MenuSurfaceBase.prototype, \"styleRight\", void 0);\n__decorate([\n    state()\n], MenuSurfaceBase.prototype, \"styleBottom\", void 0);\n__decorate([\n    state()\n], MenuSurfaceBase.prototype, \"styleMaxHeight\", void 0);\n__decorate([\n    state()\n], MenuSurfaceBase.prototype, \"styleTransformOrigin\", void 0);\n//# sourceMappingURL=mwc-menu-surface-base.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-list/mwc-list.js';\nimport './mwc-menu-surface.js';\nimport { DefaultFocusState as DefaultFocusStateEnum } from '@material/menu/constants.js';\nimport MDCMenuFoundation from '@material/menu/foundation.js';\nimport { BaseElement } from '@material/mwc-base/base-element.js';\nimport { observer } from '@material/mwc-base/observer.js';\nimport { html } from 'lit';\nimport { property, query } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nexport { createSetFromIndex, isEventMulti, isIndexSet } from '@material/mwc-list/mwc-list-foundation.js';\n/**\n * @fires selected {SelectedDetail}\n * @fires action {ActionDetail}\n * @fires items-updated\n * @fires opened\n * @fires closed\n */\nexport class MenuBase extends BaseElement {\n    constructor() {\n        super(...arguments);\n        this.mdcFoundationClass = MDCMenuFoundation;\n        this.listElement_ = null;\n        this.anchor = null;\n        this.open = false;\n        this.quick = false;\n        this.wrapFocus = false;\n        this.innerRole = 'menu';\n        this.innerAriaLabel = null;\n        this.corner = 'TOP_START';\n        this.x = null;\n        this.y = null;\n        this.absolute = false;\n        this.multi = false;\n        this.activatable = false;\n        this.fixed = false;\n        this.forceGroupSelection = false;\n        this.fullwidth = false;\n        this.menuCorner = 'START';\n        this.stayOpenOnBodyClick = false;\n        this.defaultFocus = 'LIST_ROOT';\n        this._listUpdateComplete = null;\n    }\n    get listElement() {\n        if (!this.listElement_) {\n            this.listElement_ = this.renderRoot.querySelector('mwc-list');\n            return this.listElement_;\n        }\n        return this.listElement_;\n    }\n    get items() {\n        const listElement = this.listElement;\n        if (listElement) {\n            return listElement.items;\n        }\n        return [];\n    }\n    get index() {\n        const listElement = this.listElement;\n        if (listElement) {\n            return listElement.index;\n        }\n        return -1;\n    }\n    get selected() {\n        const listElement = this.listElement;\n        if (listElement) {\n            return listElement.selected;\n        }\n        return null;\n    }\n    render() {\n        return this.renderSurface();\n    }\n    renderSurface() {\n        const classes = this.getSurfaceClasses();\n        return html `\n      <mwc-menu-surface\n        ?hidden=${!this.open}\n        .anchor=${this.anchor}\n        .open=${this.open}\n        .quick=${this.quick}\n        .corner=${this.corner}\n        .x=${this.x}\n        .y=${this.y}\n        .absolute=${this.absolute}\n        .fixed=${this.fixed}\n        .fullwidth=${this.fullwidth}\n        .menuCorner=${this.menuCorner}\n        ?stayOpenOnBodyClick=${this.stayOpenOnBodyClick}\n        class=${classMap(classes)}\n        @closed=${this.onClosed}\n        @opened=${this.onOpened}\n        @keydown=${this.onKeydown}>\n      ${this.renderList()}\n    </mwc-menu-surface>`;\n    }\n    getSurfaceClasses() {\n        return {\n            'mdc-menu': true,\n            'mdc-menu-surface': true,\n        };\n    }\n    renderList() {\n        const itemRoles = this.innerRole === 'menu' ? 'menuitem' : 'option';\n        const classes = this.renderListClasses();\n        return html `\n      <mwc-list\n          rootTabbable\n          .innerAriaLabel=${this.innerAriaLabel}\n          .innerRole=${this.innerRole}\n          .multi=${this.multi}\n          class=${classMap(classes)}\n          .itemRoles=${itemRoles}\n          .wrapFocus=${this.wrapFocus}\n          .activatable=${this.activatable}\n          @action=${this.onAction}>\n        <slot></slot>\n      </mwc-list>`;\n    }\n    renderListClasses() {\n        return {\n            'mdc-deprecated-list': true,\n        };\n    }\n    createAdapter() {\n        return {\n            addClassToElementAtIndex: (index, className) => {\n                const listElement = this.listElement;\n                if (!listElement) {\n                    return;\n                }\n                const element = listElement.items[index];\n                if (!element) {\n                    return;\n                }\n                if (className === 'mdc-menu-item--selected') {\n                    if (this.forceGroupSelection && !element.selected) {\n                        listElement.toggle(index, true);\n                    }\n                }\n                else {\n                    element.classList.add(className);\n                }\n            },\n            removeClassFromElementAtIndex: (index, className) => {\n                const listElement = this.listElement;\n                if (!listElement) {\n                    return;\n                }\n                const element = listElement.items[index];\n                if (!element) {\n                    return;\n                }\n                if (className === 'mdc-menu-item--selected') {\n                    if (element.selected) {\n                        listElement.toggle(index, false);\n                    }\n                }\n                else {\n                    element.classList.remove(className);\n                }\n            },\n            addAttributeToElementAtIndex: (index, attr, value) => {\n                const listElement = this.listElement;\n                if (!listElement) {\n                    return;\n                }\n                const element = listElement.items[index];\n                if (!element) {\n                    return;\n                }\n                element.setAttribute(attr, value);\n            },\n            removeAttributeFromElementAtIndex: (index, attr) => {\n                const listElement = this.listElement;\n                if (!listElement) {\n                    return;\n                }\n                const element = listElement.items[index];\n                if (!element) {\n                    return;\n                }\n                element.removeAttribute(attr);\n            },\n            getAttributeFromElementAtIndex: (index, attr) => {\n                const listElement = this.listElement;\n                if (!listElement) {\n                    return null;\n                }\n                const element = listElement.items[index];\n                if (!element) {\n                    return null;\n                }\n                return element.getAttribute(attr);\n            },\n            elementContainsClass: (element, className) => element.classList.contains(className),\n            closeSurface: () => {\n                this.open = false;\n            },\n            getElementIndex: (element) => {\n                const listElement = this.listElement;\n                if (listElement) {\n                    return listElement.items.indexOf(element);\n                }\n                return -1;\n            },\n            notifySelected: () => { },\n            getMenuItemCount: () => {\n                const listElement = this.listElement;\n                if (!listElement) {\n                    return 0;\n                }\n                return listElement.items.length;\n            },\n            focusItemAtIndex: (index) => {\n                const listElement = this.listElement;\n                if (!listElement) {\n                    return;\n                }\n                const element = listElement.items[index];\n                if (element) {\n                    element.focus();\n                }\n            },\n            focusListRoot: () => {\n                if (this.listElement) {\n                    this.listElement.focus();\n                }\n            },\n            getSelectedSiblingOfItemAtIndex: (index) => {\n                const listElement = this.listElement;\n                if (!listElement) {\n                    return -1;\n                }\n                const elementAtIndex = listElement.items[index];\n                if (!elementAtIndex || !elementAtIndex.group) {\n                    return -1;\n                }\n                for (let i = 0; i < listElement.items.length; i++) {\n                    if (i === index) {\n                        continue;\n                    }\n                    const current = listElement.items[i];\n                    if (current.selected && current.group === elementAtIndex.group) {\n                        return i;\n                    }\n                }\n                return -1;\n            },\n            isSelectableItemAtIndex: (index) => {\n                const listElement = this.listElement;\n                if (!listElement) {\n                    return false;\n                }\n                const elementAtIndex = listElement.items[index];\n                if (!elementAtIndex) {\n                    return false;\n                }\n                return elementAtIndex.hasAttribute('group');\n            },\n        };\n    }\n    onKeydown(evt) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.handleKeydown(evt);\n        }\n    }\n    onAction(evt) {\n        const listElement = this.listElement;\n        if (this.mdcFoundation && listElement) {\n            const index = evt.detail.index;\n            const el = listElement.items[index];\n            if (el) {\n                this.mdcFoundation.handleItemAction(el);\n            }\n        }\n    }\n    onOpened() {\n        this.open = true;\n        if (this.mdcFoundation) {\n            this.mdcFoundation.handleMenuSurfaceOpened();\n        }\n    }\n    onClosed() {\n        this.open = false;\n    }\n    // tslint:disable:ban-ts-ignore\n    async getUpdateComplete() {\n        await this._listUpdateComplete;\n        // @ts-ignore\n        const result = await super.getUpdateComplete();\n        return result;\n    }\n    // tslint:enable:ban-ts-ignore\n    async firstUpdated() {\n        super.firstUpdated();\n        const listElement = this.listElement;\n        if (listElement) {\n            this._listUpdateComplete = listElement.updateComplete;\n            await this._listUpdateComplete;\n        }\n    }\n    select(index) {\n        const listElement = this.listElement;\n        if (listElement) {\n            listElement.select(index);\n        }\n    }\n    close() {\n        this.open = false;\n    }\n    show() {\n        this.open = true;\n    }\n    getFocusedItemIndex() {\n        const listElement = this.listElement;\n        if (listElement) {\n            return listElement.getFocusedItemIndex();\n        }\n        return -1;\n    }\n    focusItemAtIndex(index) {\n        const listElement = this.listElement;\n        if (listElement) {\n            listElement.focusItemAtIndex(index);\n        }\n    }\n    layout(updateItems = true) {\n        const listElement = this.listElement;\n        if (listElement) {\n            listElement.layout(updateItems);\n        }\n    }\n}\n__decorate([\n    query('.mdc-menu')\n], MenuBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('slot')\n], MenuBase.prototype, \"slotElement\", void 0);\n__decorate([\n    property({ type: Object })\n], MenuBase.prototype, \"anchor\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], MenuBase.prototype, \"open\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuBase.prototype, \"quick\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuBase.prototype, \"wrapFocus\", void 0);\n__decorate([\n    property({ type: String })\n], MenuBase.prototype, \"innerRole\", void 0);\n__decorate([\n    property({ type: String })\n], MenuBase.prototype, \"innerAriaLabel\", void 0);\n__decorate([\n    property({ type: String })\n], MenuBase.prototype, \"corner\", void 0);\n__decorate([\n    property({ type: Number })\n], MenuBase.prototype, \"x\", void 0);\n__decorate([\n    property({ type: Number })\n], MenuBase.prototype, \"y\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuBase.prototype, \"absolute\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuBase.prototype, \"multi\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuBase.prototype, \"activatable\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuBase.prototype, \"fixed\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuBase.prototype, \"forceGroupSelection\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuBase.prototype, \"fullwidth\", void 0);\n__decorate([\n    property({ type: String })\n], MenuBase.prototype, \"menuCorner\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MenuBase.prototype, \"stayOpenOnBodyClick\", void 0);\n__decorate([\n    property({ type: String }),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.setDefaultFocusState(DefaultFocusStateEnum[value]);\n        }\n    })\n], MenuBase.prototype, \"defaultFocus\", void 0);\n//# sourceMappingURL=mwc-menu-base.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-notched-outline/mwc-notched-outline.js';\nimport '@material/mwc-menu/mwc-menu.js';\nimport '@material/mwc-icon/mwc-icon.js';\nimport { KEY, normalizeKey } from '@material/dom/keyboard.js';\nimport * as typeahead from '@material/list/typeahead.js';\nimport { addHasRemoveClass, FormElement } from '@material/mwc-base/form-element.js';\nimport { observer } from '@material/mwc-base/observer.js';\nimport { isNodeElement } from '@material/mwc-base/utils.js';\nimport { floatingLabel } from '@material/mwc-floating-label/mwc-floating-label-directive.js';\nimport { lineRipple } from '@material/mwc-line-ripple/mwc-line-ripple-directive.js';\nimport MDCSelectFoundation from '@material/select/foundation.js';\nimport { html, nothing } from 'lit';\nimport { eventOptions, property, query, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nconst createValidityObj = (customValidity = {}) => {\n    /*\n     * We need to make ValidityState an object because it is readonly and\n     * we cannot use the spread operator. Also, we don't export\n     * `CustomValidityState` because it is a leaky implementation and the user\n     * already has access to `ValidityState` in lib.dom.ts. Also an interface\n     * {a: Type} can be casted to {readonly a: Type} so passing any object\n     * should be fine.\n     */\n    const objectifiedCustomValidity = {};\n    // eslint-disable-next-line guard-for-in\n    for (const propName in customValidity) {\n        /*\n         * Casting is needed because ValidityState's props are all readonly and\n         * thus cannot be set on `onjectifiedCustomValidity`. In the end, the\n         * interface is the same as ValidityState (but not readonly), but the\n         * function signature casts the output to ValidityState (thus readonly).\n         */\n        objectifiedCustomValidity[propName] =\n            customValidity[propName];\n    }\n    return Object.assign({ badInput: false, customError: false, patternMismatch: false, rangeOverflow: false, rangeUnderflow: false, stepMismatch: false, tooLong: false, tooShort: false, typeMismatch: false, valid: true, valueMissing: false }, objectifiedCustomValidity);\n};\n/**\n * @fires selected {SelectedDetail}\n * @fires action {ActionDetail}\n * @fires opened\n * @fires closed\n * @fires change\n * @fires invalid\n */\nexport class SelectBase extends FormElement {\n    constructor() {\n        super(...arguments);\n        this.mdcFoundationClass = MDCSelectFoundation;\n        this.disabled = false;\n        this.outlined = false;\n        this.label = '';\n        this.outlineOpen = false;\n        this.outlineWidth = 0;\n        this.value = '';\n        this.name = '';\n        this.selectedText = '';\n        this.icon = '';\n        this.menuOpen = false;\n        this.helper = '';\n        this.validateOnInitialRender = false;\n        this.validationMessage = '';\n        this.required = false;\n        this.naturalMenuWidth = false;\n        this.isUiValid = true;\n        this.fixedMenuPosition = false;\n        // Transiently holds current typeahead prefix from user.\n        this.typeaheadState = typeahead.initState();\n        this.sortedIndexByFirstChar = new Map();\n        this.menuElement_ = null;\n        this.listeners = [];\n        this.onBodyClickBound = () => undefined;\n        this._menuUpdateComplete = null;\n        this.valueSetDirectly = false;\n        this.validityTransform = null;\n        this._validity = createValidityObj();\n    }\n    get items() {\n        // memoize menuElement to prevent unnecessary querySelector calls.\n        if (!this.menuElement_) {\n            this.menuElement_ = this.menuElement;\n        }\n        if (this.menuElement_) {\n            return this.menuElement_.items;\n        }\n        return [];\n    }\n    get selected() {\n        const menuElement = this.menuElement;\n        if (menuElement) {\n            return menuElement.selected;\n        }\n        return null;\n    }\n    get index() {\n        const menuElement = this.menuElement;\n        if (menuElement) {\n            return menuElement.index;\n        }\n        return -1;\n    }\n    get shouldRenderHelperText() {\n        return !!this.helper || !!this.validationMessage;\n    }\n    get validity() {\n        this._checkValidity(this.value);\n        return this._validity;\n    }\n    render() {\n        const classes = {\n            'mdc-select--disabled': this.disabled,\n            'mdc-select--no-label': !this.label,\n            'mdc-select--filled': !this.outlined,\n            'mdc-select--outlined': this.outlined,\n            'mdc-select--with-leading-icon': !!this.icon,\n            'mdc-select--required': this.required,\n            'mdc-select--invalid': !this.isUiValid,\n        };\n        const labelledby = !!this.label ? 'label' : undefined;\n        const describedby = this.shouldRenderHelperText ? 'helper-text' : undefined;\n        return html `\n      <div\n          class=\"mdc-select ${classMap(classes)}\">\n        <input\n            class=\"formElement\"\n            name=\"${this.name}\"\n            .value=\"${this.value}\"\n            hidden\n            ?disabled=\"${this.disabled}\"\n            ?required=${this.required}>\n        <!-- @ts-ignore -->\n        <div class=\"mdc-select__anchor\"\n            aria-autocomplete=\"none\"\n            role=\"combobox\"\n            aria-expanded=${this.menuOpen}\n            aria-invalid=${!this.isUiValid}\n            aria-haspopup=\"listbox\"\n            aria-labelledby=${ifDefined(labelledby)}\n            aria-required=${this.required}\n            aria-describedby=${ifDefined(describedby)}\n            @click=${this.onClick}\n            @focus=${this.onFocus}\n            @blur=${this.onBlur}\n            @keydown=${this.onKeydown}>\n          ${this.renderRipple()}\n          ${this.outlined ? this.renderOutline() : this.renderLabel()}\n          ${this.renderLeadingIcon()}\n          <span class=\"mdc-select__selected-text-container\">\n            <span class=\"mdc-select__selected-text\">${this.selectedText}</span>\n          </span>\n          <span class=\"mdc-select__dropdown-icon\">\n            <svg\n                class=\"mdc-select__dropdown-icon-graphic\"\n                viewBox=\"7 10 10 5\"\n                focusable=\"false\">\n              <polygon\n                  class=\"mdc-select__dropdown-icon-inactive\"\n                  stroke=\"none\"\n                  fill-rule=\"evenodd\"\n                  points=\"7 10 12 15 17 10\">\n              </polygon>\n              <polygon\n                  class=\"mdc-select__dropdown-icon-active\"\n                  stroke=\"none\"\n                  fill-rule=\"evenodd\"\n                  points=\"7 15 12 10 17 15\">\n              </polygon>\n            </svg>\n          </span>\n          ${this.renderLineRipple()}\n        </div>\n        ${this.renderMenu()}\n      </div>\n      ${this.renderHelperText()}`;\n    }\n    renderMenu() {\n        const classes = this.getMenuClasses();\n        return html `\n      <mwc-menu\n        innerRole=\"listbox\"\n        wrapFocus\n        class=\" ${classMap(classes)}\"\n        activatable\n        .fullwidth=${this.fixedMenuPosition ? false : !this.naturalMenuWidth}\n        .open=${this.menuOpen}\n        .anchor=${this.anchorElement}\n        .fixed=${this.fixedMenuPosition}\n        @selected=${this.onSelected}\n        @opened=${this.onOpened}\n        @closed=${this.onClosed}\n        @items-updated=${this.onItemsUpdated}\n        @keydown=${this.handleTypeahead}>\n      ${this.renderMenuContent()}\n    </mwc-menu>`;\n    }\n    getMenuClasses() {\n        return {\n            'mdc-select__menu': true,\n            'mdc-menu': true,\n            'mdc-menu-surface': true,\n            'mdc-select__menu--invalid': !this.isUiValid,\n        };\n    }\n    renderMenuContent() {\n        return html `<slot></slot>`;\n    }\n    renderRipple() {\n        if (this.outlined) {\n            return nothing;\n        }\n        return html `\n      <span class=\"mdc-select__ripple\"></span>\n    `;\n    }\n    renderOutline() {\n        if (!this.outlined) {\n            return nothing;\n        }\n        return html `\n      <mwc-notched-outline\n          .width=${this.outlineWidth}\n          .open=${this.outlineOpen}\n          class=\"mdc-notched-outline\">\n        ${this.renderLabel()}\n      </mwc-notched-outline>`;\n    }\n    renderLabel() {\n        if (!this.label) {\n            return nothing;\n        }\n        return html `\n      <span\n          .floatingLabelFoundation=${floatingLabel(this.label)}\n          id=\"label\">${this.label}</span>\n    `;\n    }\n    renderLeadingIcon() {\n        if (!this.icon) {\n            return nothing;\n        }\n        return html `<mwc-icon class=\"mdc-select__icon\"><div>${this.icon}</div></mwc-icon>`;\n    }\n    renderLineRipple() {\n        if (this.outlined) {\n            return nothing;\n        }\n        return html `\n      <span .lineRippleFoundation=${lineRipple()}></span>\n    `;\n    }\n    renderHelperText() {\n        if (!this.shouldRenderHelperText) {\n            return nothing;\n        }\n        const showValidationMessage = this.validationMessage && !this.isUiValid;\n        const classes = {\n            'mdc-select-helper-text--validation-msg': showValidationMessage,\n        };\n        return html `\n        <p\n          class=\"mdc-select-helper-text ${classMap(classes)}\"\n          id=\"helper-text\">${showValidationMessage ? this.validationMessage : this.helper}</p>`;\n    }\n    createAdapter() {\n        return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), { activateBottomLine: () => {\n                if (this.lineRippleElement) {\n                    this.lineRippleElement.lineRippleFoundation.activate();\n                }\n            }, deactivateBottomLine: () => {\n                if (this.lineRippleElement) {\n                    this.lineRippleElement.lineRippleFoundation.deactivate();\n                }\n            }, hasLabel: () => {\n                return !!this.label;\n            }, floatLabel: (shouldFloat) => {\n                if (this.labelElement) {\n                    this.labelElement.floatingLabelFoundation.float(shouldFloat);\n                }\n            }, getLabelWidth: () => {\n                if (this.labelElement) {\n                    return this.labelElement.floatingLabelFoundation.getWidth();\n                }\n                return 0;\n            }, setLabelRequired: (isRequired) => {\n                if (this.labelElement) {\n                    this.labelElement.floatingLabelFoundation.setRequired(isRequired);\n                }\n            }, hasOutline: () => this.outlined, notchOutline: (labelWidth) => {\n                const outlineElement = this.outlineElement;\n                if (outlineElement && !this.outlineOpen) {\n                    this.outlineWidth = labelWidth;\n                    this.outlineOpen = true;\n                }\n            }, closeOutline: () => {\n                if (this.outlineElement) {\n                    this.outlineOpen = false;\n                }\n            }, setRippleCenter: (normalizedX) => {\n                if (this.lineRippleElement) {\n                    const foundation = this.lineRippleElement.lineRippleFoundation;\n                    foundation.setRippleCenter(normalizedX);\n                }\n            }, notifyChange: async (value) => {\n                if (!this.valueSetDirectly && value === this.value) {\n                    return;\n                }\n                this.valueSetDirectly = false;\n                this.value = value;\n                await this.updateComplete;\n                const ev = new Event('change', { bubbles: true });\n                this.dispatchEvent(ev);\n            }, setSelectedText: (value) => this.selectedText = value, isSelectAnchorFocused: () => {\n                const selectAnchorElement = this.anchorElement;\n                if (!selectAnchorElement) {\n                    return false;\n                }\n                const rootNode = selectAnchorElement.getRootNode();\n                return rootNode.activeElement === selectAnchorElement;\n            }, getSelectAnchorAttr: (attr) => {\n                const selectAnchorElement = this.anchorElement;\n                if (!selectAnchorElement) {\n                    return null;\n                }\n                return selectAnchorElement.getAttribute(attr);\n            }, setSelectAnchorAttr: (attr, value) => {\n                const selectAnchorElement = this.anchorElement;\n                if (!selectAnchorElement) {\n                    return;\n                }\n                selectAnchorElement.setAttribute(attr, value);\n            }, removeSelectAnchorAttr: (attr) => {\n                const selectAnchorElement = this.anchorElement;\n                if (!selectAnchorElement) {\n                    return;\n                }\n                selectAnchorElement.removeAttribute(attr);\n            }, openMenu: () => {\n                this.menuOpen = true;\n            }, closeMenu: () => {\n                this.menuOpen = false;\n            }, addMenuClass: () => undefined, removeMenuClass: () => undefined, getAnchorElement: () => this.anchorElement, setMenuAnchorElement: () => {\n                /* Handled by anchor directive */\n            }, setMenuAnchorCorner: () => {\n                const menuElement = this.menuElement;\n                if (menuElement) {\n                    menuElement.corner = 'BOTTOM_START';\n                }\n            }, setMenuWrapFocus: (wrapFocus) => {\n                const menuElement = this.menuElement;\n                if (menuElement) {\n                    menuElement.wrapFocus = wrapFocus;\n                }\n            }, focusMenuItemAtIndex: (index) => {\n                const menuElement = this.menuElement;\n                if (!menuElement) {\n                    return;\n                }\n                const element = menuElement.items[index];\n                if (!element) {\n                    return;\n                }\n                element.focus();\n            }, getMenuItemCount: () => {\n                const menuElement = this.menuElement;\n                if (menuElement) {\n                    return menuElement.items.length;\n                }\n                return 0;\n            }, getMenuItemValues: () => {\n                const menuElement = this.menuElement;\n                if (!menuElement) {\n                    return [];\n                }\n                const items = menuElement.items;\n                return items.map((item) => item.value);\n            }, getMenuItemTextAtIndex: (index) => {\n                const menuElement = this.menuElement;\n                if (!menuElement) {\n                    return '';\n                }\n                const element = menuElement.items[index];\n                if (!element) {\n                    return '';\n                }\n                return element.text;\n            }, getSelectedIndex: () => this.index, setSelectedIndex: () => undefined, isTypeaheadInProgress: () => typeahead.isTypingInProgress(this.typeaheadState), typeaheadMatchItem: (nextChar, startingIndex) => {\n                if (!this.menuElement) {\n                    return -1;\n                }\n                const opts = {\n                    focusItemAtIndex: (index) => {\n                        this.menuElement.focusItemAtIndex(index);\n                    },\n                    focusedItemIndex: startingIndex ?\n                        startingIndex :\n                        this.menuElement.getFocusedItemIndex(),\n                    nextChar,\n                    sortedIndexByFirstChar: this.sortedIndexByFirstChar,\n                    skipFocus: false,\n                    isItemAtIndexDisabled: (index) => this.items[index].disabled,\n                };\n                const index = typeahead.matchItem(opts, this.typeaheadState);\n                if (index !== -1) {\n                    this.select(index);\n                }\n                return index;\n            } });\n    }\n    checkValidity() {\n        const isValid = this._checkValidity(this.value);\n        if (!isValid) {\n            const invalidEvent = new Event('invalid', { bubbles: false, cancelable: true });\n            this.dispatchEvent(invalidEvent);\n        }\n        return isValid;\n    }\n    reportValidity() {\n        const isValid = this.checkValidity();\n        this.isUiValid = isValid;\n        return isValid;\n    }\n    _checkValidity(value) {\n        const nativeValidity = this.formElement.validity;\n        let validity = createValidityObj(nativeValidity);\n        if (this.validityTransform) {\n            const customValidity = this.validityTransform(value, validity);\n            validity = Object.assign(Object.assign({}, validity), customValidity);\n        }\n        this._validity = validity;\n        return this._validity.valid;\n    }\n    setCustomValidity(message) {\n        this.validationMessage = message;\n        this.formElement.setCustomValidity(message);\n    }\n    // tslint:disable:ban-ts-ignore\n    async getUpdateComplete() {\n        await this._menuUpdateComplete;\n        // @ts-ignore\n        const result = await super.getUpdateComplete();\n        return result;\n    }\n    // tslint:enable:ban-ts-ignore\n    async firstUpdated() {\n        const menuElement = this.menuElement;\n        if (menuElement) {\n            this._menuUpdateComplete = menuElement.updateComplete;\n            await this._menuUpdateComplete;\n        }\n        super.firstUpdated();\n        this.mdcFoundation.isValid = () => true;\n        this.mdcFoundation.setValid = () => undefined;\n        this.mdcFoundation.setDisabled(this.disabled);\n        if (this.validateOnInitialRender) {\n            this.reportValidity();\n        }\n        // Select an option based on init value\n        if (!this.selected) {\n            if (!this.items.length && this.slotElement &&\n                this.slotElement.assignedNodes({ flatten: true }).length) {\n                // Shady DOM initial render fix\n                await new Promise((res) => requestAnimationFrame(res));\n                await this.layout();\n            }\n            const hasEmptyFirstOption = this.items.length && this.items[0].value === '';\n            if (!this.value && hasEmptyFirstOption) {\n                this.select(0);\n                return;\n            }\n            this.selectByValue(this.value);\n        }\n        this.sortedIndexByFirstChar = typeahead.initSortedIndex(this.items.length, (index) => this.items[index].text);\n    }\n    onItemsUpdated() {\n        this.sortedIndexByFirstChar = typeahead.initSortedIndex(this.items.length, (index) => this.items[index].text);\n    }\n    select(index) {\n        const menuElement = this.menuElement;\n        if (menuElement) {\n            menuElement.select(index);\n        }\n    }\n    selectByValue(value) {\n        let indexToSelect = -1;\n        for (let i = 0; i < this.items.length; i++) {\n            const item = this.items[i];\n            if (item.value === value) {\n                indexToSelect = i;\n                break;\n            }\n        }\n        this.valueSetDirectly = true;\n        this.select(indexToSelect);\n        this.mdcFoundation.handleChange();\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        for (const listener of this.listeners) {\n            listener.target.removeEventListener(listener.name, listener.cb);\n        }\n    }\n    focus() {\n        const focusEvt = new CustomEvent('focus');\n        const selectAnchorElement = this.anchorElement;\n        if (selectAnchorElement) {\n            selectAnchorElement.dispatchEvent(focusEvt);\n            selectAnchorElement.focus();\n        }\n    }\n    blur() {\n        const focusEvt = new CustomEvent('blur');\n        const selectAnchorElement = this.anchorElement;\n        if (selectAnchorElement) {\n            selectAnchorElement.dispatchEvent(focusEvt);\n            selectAnchorElement.blur();\n        }\n    }\n    onFocus() {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.handleFocus();\n        }\n    }\n    onBlur() {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.handleBlur();\n        }\n        const menuElement = this.menuElement;\n        if (menuElement && !menuElement.open) {\n            this.reportValidity();\n        }\n    }\n    onClick(evt) {\n        if (this.mdcFoundation) {\n            this.focus();\n            const targetClientRect = evt.target.getBoundingClientRect();\n            let xCoord = 0;\n            if ('touches' in evt) {\n                xCoord = evt.touches[0].clientX;\n            }\n            else {\n                xCoord = evt.clientX;\n            }\n            const normalizedX = xCoord - targetClientRect.left;\n            this.mdcFoundation.handleClick(normalizedX);\n        }\n    }\n    onKeydown(evt) {\n        const arrowUp = normalizeKey(evt) === KEY.ARROW_UP;\n        const arrowDown = normalizeKey(evt) === KEY.ARROW_DOWN;\n        if (arrowDown || arrowUp) {\n            const shouldSelectNextItem = arrowUp && this.index > 0;\n            const shouldSelectPrevItem = arrowDown && this.index < this.items.length - 1;\n            if (shouldSelectNextItem) {\n                this.select(this.index - 1);\n            }\n            else if (shouldSelectPrevItem) {\n                this.select(this.index + 1);\n            }\n            evt.preventDefault();\n            this.mdcFoundation.openMenu();\n            return;\n        }\n        this.mdcFoundation.handleKeydown(evt);\n    }\n    // must capture to run before list foundation captures event\n    handleTypeahead(event) {\n        if (!this.menuElement) {\n            return;\n        }\n        const focusedItemIndex = this.menuElement.getFocusedItemIndex();\n        const target = isNodeElement(event.target) ?\n            event.target :\n            null;\n        const isTargetListItem = target ? target.hasAttribute('mwc-list-item') : false;\n        const opts = {\n            event,\n            focusItemAtIndex: (index) => {\n                this.menuElement.focusItemAtIndex(index);\n            },\n            focusedItemIndex,\n            isTargetListItem,\n            sortedIndexByFirstChar: this.sortedIndexByFirstChar,\n            isItemAtIndexDisabled: (index) => this.items[index].disabled,\n        };\n        typeahead.handleKeydown(opts, this.typeaheadState);\n    }\n    async onSelected(event) {\n        if (!this.mdcFoundation) {\n            await this.updateComplete;\n        }\n        this.mdcFoundation.handleMenuItemAction(event.detail.index);\n        const item = this.items[event.detail.index];\n        if (item) {\n            this.value = item.value;\n        }\n    }\n    onOpened() {\n        if (this.mdcFoundation) {\n            this.menuOpen = true;\n            this.mdcFoundation.handleMenuOpened();\n        }\n    }\n    onClosed() {\n        if (this.mdcFoundation) {\n            this.menuOpen = false;\n            this.mdcFoundation.handleMenuClosed();\n        }\n    }\n    setFormData(formData) {\n        if (this.name && this.selected !== null) {\n            formData.append(this.name, this.value);\n        }\n    }\n    async layout(updateItems = true) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.layout();\n        }\n        await this.updateComplete;\n        const menuElement = this.menuElement;\n        if (menuElement) {\n            menuElement.layout(updateItems);\n        }\n        const labelElement = this.labelElement;\n        if (!labelElement) {\n            this.outlineOpen = false;\n            return;\n        }\n        const shouldFloat = !!this.label && !!this.value;\n        labelElement.floatingLabelFoundation.float(shouldFloat);\n        if (!this.outlined) {\n            return;\n        }\n        this.outlineOpen = shouldFloat;\n        await this.updateComplete;\n        /* When the textfield automatically notches due to a value and label\n         * being defined, the textfield may be set to `display: none` by the user.\n         * this means that the notch is of size 0px. We provide this function so\n         * that the user may manually resize the notch to the floated label's\n         * width.\n         */\n        const labelWidth = labelElement.floatingLabelFoundation.getWidth();\n        if (this.outlineOpen) {\n            this.outlineWidth = labelWidth;\n        }\n    }\n    async layoutOptions() {\n        if (!this.mdcFoundation) {\n            return;\n        }\n        this.mdcFoundation.layoutOptions();\n    }\n}\n__decorate([\n    query('.mdc-select')\n], SelectBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    query('.formElement')\n], SelectBase.prototype, \"formElement\", void 0);\n__decorate([\n    query('slot')\n], SelectBase.prototype, \"slotElement\", void 0);\n__decorate([\n    query('select')\n], SelectBase.prototype, \"nativeSelectElement\", void 0);\n__decorate([\n    query('input')\n], SelectBase.prototype, \"nativeInputElement\", void 0);\n__decorate([\n    query('.mdc-line-ripple')\n], SelectBase.prototype, \"lineRippleElement\", void 0);\n__decorate([\n    query('.mdc-floating-label')\n], SelectBase.prototype, \"labelElement\", void 0);\n__decorate([\n    query('mwc-notched-outline')\n], SelectBase.prototype, \"outlineElement\", void 0);\n__decorate([\n    query('.mdc-menu')\n], SelectBase.prototype, \"menuElement\", void 0);\n__decorate([\n    query('.mdc-select__anchor')\n], SelectBase.prototype, \"anchorElement\", void 0);\n__decorate([\n    property({ type: Boolean, attribute: 'disabled', reflect: true }),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            this.mdcFoundation.setDisabled(value);\n        }\n    })\n], SelectBase.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean }),\n    observer(function (_newVal, oldVal) {\n        if (oldVal !== undefined && this.outlined !== oldVal) {\n            this.layout(false);\n        }\n    })\n], SelectBase.prototype, \"outlined\", void 0);\n__decorate([\n    property({ type: String }),\n    observer(function (_newVal, oldVal) {\n        if (oldVal !== undefined && this.label !== oldVal) {\n            this.layout(false);\n        }\n    })\n], SelectBase.prototype, \"label\", void 0);\n__decorate([\n    state()\n], SelectBase.prototype, \"outlineOpen\", void 0);\n__decorate([\n    state()\n], SelectBase.prototype, \"outlineWidth\", void 0);\n__decorate([\n    property({ type: String }),\n    observer(function (value) {\n        if (this.mdcFoundation) {\n            const initialization = this.selected === null && !!value;\n            const valueSetByUser = this.selected && this.selected.value !== value;\n            if (initialization || valueSetByUser) {\n                this.selectByValue(value);\n            }\n            this.reportValidity();\n        }\n    })\n], SelectBase.prototype, \"value\", void 0);\n__decorate([\n    property()\n], SelectBase.prototype, \"name\", void 0);\n__decorate([\n    state()\n], SelectBase.prototype, \"selectedText\", void 0);\n__decorate([\n    property({ type: String })\n], SelectBase.prototype, \"icon\", void 0);\n__decorate([\n    state()\n], SelectBase.prototype, \"menuOpen\", void 0);\n__decorate([\n    property({ type: String })\n], SelectBase.prototype, \"helper\", void 0);\n__decorate([\n    property({ type: Boolean })\n], SelectBase.prototype, \"validateOnInitialRender\", void 0);\n__decorate([\n    property({ type: String })\n], SelectBase.prototype, \"validationMessage\", void 0);\n__decorate([\n    property({ type: Boolean })\n], SelectBase.prototype, \"required\", void 0);\n__decorate([\n    property({ type: Boolean })\n], SelectBase.prototype, \"naturalMenuWidth\", void 0);\n__decorate([\n    state()\n], SelectBase.prototype, \"isUiValid\", void 0);\n__decorate([\n    property({ type: Boolean })\n], SelectBase.prototype, \"fixedMenuPosition\", void 0);\n__decorate([\n    eventOptions({ capture: true })\n], SelectBase.prototype, \"handleTypeahead\", null);\n//# sourceMappingURL=mwc-select-base.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\nimport '@material/mwc-ripple/mwc-ripple.js';\nimport { ariaProperty } from '@material/mwc-base/aria-property.js';\nimport { FormElement } from '@material/mwc-base/form-element.js';\nimport { RippleHandlers } from '@material/mwc-ripple/ripple-handlers.js';\nimport { MDCSwitchFoundation } from '@material/switch/foundation.js';\nimport { html } from 'lit';\nimport { eventOptions, property, query, queryAsync, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nexport class SwitchBase extends FormElement {\n    constructor() {\n        super(...arguments);\n        // MDCSwitchState\n        this.processing = false;\n        this.selected = false;\n        // Aria\n        /** @soyPrefixAttribute */\n        this.ariaLabel = '';\n        /** @soyPrefixAttribute */\n        this.ariaLabelledBy = '';\n        this.shouldRenderRipple = false;\n        this.rippleHandlers = new RippleHandlers(() => {\n            this.shouldRenderRipple = true;\n            return this.ripple;\n        });\n        // FormElement\n        this.name = '';\n        this.value = 'on';\n        this.mdcFoundationClass = MDCSwitchFoundation;\n    }\n    setFormData(formData) {\n        if (this.name && this.selected) {\n            formData.append(this.name, this.value);\n        }\n    }\n    click() {\n        var _a, _b;\n        // Switch uses a hidden input as its form element, but a different <button>\n        // for interaction. It overrides click() from FormElement to avoid clicking\n        // the hidden input.\n        if (this.disabled) {\n            return;\n        }\n        (_a = this.mdcRoot) === null || _a === void 0 ? void 0 : _a.focus();\n        (_b = this.mdcRoot) === null || _b === void 0 ? void 0 : _b.click();\n    }\n    /** @soyTemplate */\n    render() {\n        return html `\n      <button\n        type=\"button\"\n        class=\"mdc-switch ${classMap(this.getRenderClasses())}\"\n        role=\"switch\"\n        aria-checked=\"${this.selected}\"\n        aria-label=\"${ifDefined(this.ariaLabel || undefined)}\"\n        aria-labelledby=\"${ifDefined(this.ariaLabelledBy || undefined)}\"\n        .disabled=${this.disabled}\n        @click=${this.handleClick}\n        @focus=\"${this.handleFocus}\"\n        @blur=\"${this.handleBlur}\"\n        @pointerdown=\"${this.handlePointerDown}\"\n        @pointerup=\"${this.handlePointerUp}\"\n        @pointerenter=\"${this.handlePointerEnter}\"\n        @pointerleave=\"${this.handlePointerLeave}\"\n      >\n        <div class=\"mdc-switch__track\"></div>\n        <div class=\"mdc-switch__handle-track\">\n          ${this.renderHandle()}\n        </div>\n      </button>\n\n      <input\n        type=\"checkbox\"\n        aria-hidden=\"true\"\n        name=\"${this.name}\"\n        .checked=${this.selected}\n        .value=${this.value}\n      >\n    `;\n    }\n    /** @soyTemplate */\n    getRenderClasses() {\n        return {\n            'mdc-switch--processing': this.processing,\n            'mdc-switch--selected': this.selected,\n            'mdc-switch--unselected': !this.selected,\n        };\n    }\n    /** @soyTemplate */\n    renderHandle() {\n        return html `\n      <div class=\"mdc-switch__handle\">\n        ${this.renderShadow()}\n        ${this.renderRipple()}\n        <div class=\"mdc-switch__icons\">\n          ${this.renderOnIcon()}\n          ${this.renderOffIcon()}\n        </div>\n      </div>\n    `;\n    }\n    /** @soyTemplate */\n    renderShadow() {\n        return html `\n      <div class=\"mdc-switch__shadow\">\n        <div class=\"mdc-elevation-overlay\"></div>\n      </div>\n    `;\n    }\n    /** @soyTemplate */\n    renderRipple() {\n        if (this.shouldRenderRipple) {\n            return html `\n        <div class=\"mdc-switch__ripple\">\n          <mwc-ripple\n            internalUseStateLayerCustomProperties\n            .disabled=\"${this.disabled}\"\n            unbounded>\n          </mwc-ripple>\n        </div>\n      `;\n        }\n        else {\n            return html ``;\n        }\n    }\n    /** @soyTemplate */\n    renderOnIcon() {\n        return html `\n      <svg class=\"mdc-switch__icon mdc-switch__icon--on\" viewBox=\"0 0 24 24\">\n        <path d=\"M19.69,5.23L8.96,15.96l-4.23-4.23L2.96,13.5l6,6L21.46,7L19.69,5.23z\" />\n      </svg>\n    `;\n    }\n    /** @soyTemplate */\n    renderOffIcon() {\n        return html `\n      <svg class=\"mdc-switch__icon mdc-switch__icon--off\" viewBox=\"0 0 24 24\">\n        <path d=\"M20 13H4v-2h16v2z\" />\n      </svg>\n    `;\n    }\n    handleClick() {\n        var _a;\n        (_a = this.mdcFoundation) === null || _a === void 0 ? void 0 : _a.handleClick();\n    }\n    handleFocus() {\n        this.rippleHandlers.startFocus();\n    }\n    handleBlur() {\n        this.rippleHandlers.endFocus();\n    }\n    handlePointerDown(event) {\n        event.target.setPointerCapture(event.pointerId);\n        this.rippleHandlers.startPress(event);\n    }\n    handlePointerUp() {\n        this.rippleHandlers.endPress();\n    }\n    handlePointerEnter() {\n        this.rippleHandlers.startHover();\n    }\n    handlePointerLeave() {\n        this.rippleHandlers.endHover();\n    }\n    createAdapter() {\n        return { state: this };\n    }\n}\n__decorate([\n    property({ type: Boolean })\n], SwitchBase.prototype, \"processing\", void 0);\n__decorate([\n    property({ type: Boolean })\n], SwitchBase.prototype, \"selected\", void 0);\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-label' })\n], SwitchBase.prototype, \"ariaLabel\", void 0);\n__decorate([\n    ariaProperty,\n    property({ type: String, attribute: 'aria-labelledby' })\n], SwitchBase.prototype, \"ariaLabelledBy\", void 0);\n__decorate([\n    queryAsync('mwc-ripple')\n], SwitchBase.prototype, \"ripple\", void 0);\n__decorate([\n    state()\n], SwitchBase.prototype, \"shouldRenderRipple\", void 0);\n__decorate([\n    property({ type: String, reflect: true })\n], SwitchBase.prototype, \"name\", void 0);\n__decorate([\n    property({ type: String })\n], SwitchBase.prototype, \"value\", void 0);\n__decorate([\n    query('input')\n], SwitchBase.prototype, \"formElement\", void 0);\n__decorate([\n    query('.mdc-switch')\n], SwitchBase.prototype, \"mdcRoot\", void 0);\n__decorate([\n    eventOptions({ passive: true })\n], SwitchBase.prototype, \"handlePointerDown\", null);\n//# sourceMappingURL=mwc-switch-base.js.map","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport { TextFieldBase } from '@material/mwc-textfield/mwc-textfield-base.js';\nimport { html } from 'lit';\nimport { property, query } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { live } from 'lit/directives/live.js';\nconst booleanOrStringConverter = {\n    fromAttribute(value) {\n        if (value === null) {\n            return false;\n        }\n        else if (value === '') {\n            return true;\n        }\n        return value;\n    },\n    toAttribute(value) {\n        if (typeof value === 'boolean') {\n            return value ? '' : null;\n        }\n        return value;\n    }\n};\n/** @soyCompatible */\nexport class TextAreaBase extends TextFieldBase {\n    constructor() {\n        super(...arguments);\n        this.rows = 2;\n        this.cols = 20;\n        this.charCounter = false;\n    }\n    /** @soyTemplate */\n    render() {\n        const shouldRenderCharCounter = this.charCounter && this.maxLength !== -1;\n        const shouldRenderInternalCharCounter = shouldRenderCharCounter && this.charCounter === 'internal';\n        const shouldRenderExternalCharCounter = shouldRenderCharCounter && !shouldRenderInternalCharCounter;\n        const shouldRenderHelperText = !!this.helper || !!this.validationMessage ||\n            shouldRenderExternalCharCounter;\n        /** @classMap */\n        const classes = {\n            'mdc-text-field--disabled': this.disabled,\n            'mdc-text-field--no-label': !this.label,\n            'mdc-text-field--filled': !this.outlined,\n            'mdc-text-field--outlined': this.outlined,\n            'mdc-text-field--end-aligned': this.endAligned,\n            'mdc-text-field--with-internal-counter': shouldRenderInternalCharCounter,\n        };\n        return html `\n      <label class=\"mdc-text-field mdc-text-field--textarea ${classMap(classes)}\">\n        ${this.renderRipple()}\n        ${this.outlined ? this.renderOutline() : this.renderLabel()}\n        ${this.renderInput()}\n        ${this.renderCharCounter(shouldRenderInternalCharCounter)}\n        ${this.renderLineRipple()}\n      </label>\n      ${this.renderHelperText(shouldRenderHelperText, shouldRenderExternalCharCounter)}\n    `;\n    }\n    /** @soyTemplate */\n    renderInput() {\n        const ariaLabelledbyOrUndef = !!this.label ? 'label' : undefined;\n        const minOrUndef = this.minLength === -1 ? undefined : this.minLength;\n        const maxOrUndef = this.maxLength === -1 ? undefined : this.maxLength;\n        const autocapitalizeOrUndef = this.autocapitalize ?\n            this.autocapitalize :\n            undefined;\n        return html `\n      <textarea\n          aria-labelledby=${ifDefined(ariaLabelledbyOrUndef)}\n          class=\"mdc-text-field__input\"\n          .value=\"${live(this.value)}\"\n          rows=\"${this.rows}\"\n          cols=\"${this.cols}\"\n          ?disabled=\"${this.disabled}\"\n          placeholder=\"${this.placeholder}\"\n          ?required=\"${this.required}\"\n          ?readonly=\"${this.readOnly}\"\n          minlength=\"${ifDefined(minOrUndef)}\"\n          maxlength=\"${ifDefined(maxOrUndef)}\"\n          name=\"${ifDefined(this.name === '' ? undefined : this.name)}\"\n          inputmode=\"${ifDefined(this.inputMode)}\"\n          autocapitalize=\"${ifDefined(autocapitalizeOrUndef)}\"\n          @input=\"${this.handleInputChange}\"\n          @blur=\"${this.onInputBlur}\">\n      </textarea>`;\n    }\n}\n__decorate([\n    query('textarea')\n], TextAreaBase.prototype, \"formElement\", void 0);\n__decorate([\n    property({ type: Number })\n], TextAreaBase.prototype, \"rows\", void 0);\n__decorate([\n    property({ type: Number })\n], TextAreaBase.prototype, \"cols\", void 0);\n__decorate([\n    property({ converter: booleanOrStringConverter })\n], TextAreaBase.prototype, \"charCounter\", void 0);\n//# sourceMappingURL=mwc-textarea-base.js.map","/*\nCopyright 2020 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\nimport { __decorate } from \"tslib\";\nimport { html, SpectrumElement, property, query, } from '@spectrum-web-components/base';\nimport { openOverlay } from '@spectrum-web-components/overlay/src/loader.js';\nimport tooltipStyles from './tooltip.css.js';\n/**\n * @element sp-tooltip\n *\n * @slot icon - the icon element appearing at the start of the label\n * @slot - the text label of the Tooltip\n */\nexport class Tooltip extends SpectrumElement {\n    constructor() {\n        super();\n        this._tooltipId = `sp-tooltip-describedby-helper-${Tooltip.instanceCount++}`;\n        this.selfManaged = false;\n        this.offset = 6;\n        this.open = false;\n        /**\n         * @type {\"auto\" | \"auto-start\" | \"auto-end\" | \"top\" | \"bottom\" | \"right\" | \"left\" | \"top-start\" | \"top-end\" | \"bottom-start\" | \"bottom-end\" | \"right-start\" | \"right-end\" | \"left-start\" | \"left-end\" | \"none\"}\n         * @attr\n         */\n        this.placement = 'top';\n        /* Ensure that a '' value for `variant` removes the attribute instead of a blank value */\n        this._variant = '';\n        this.abortOverlay = () => {\n            return;\n        };\n        this.openOverlay = () => {\n            const parentElement = this.parentElement;\n            const abortPromise = new Promise((res) => {\n                this.abortOverlay = res;\n            });\n            this.closeOverlayCallback = openOverlay(parentElement, 'hover', this, {\n                abortPromise,\n                offset: this.offset,\n                placement: this.placement,\n            });\n        };\n        this.closeOverlay = async () => {\n            if (this.abortOverlay)\n                this.abortOverlay(true);\n            if (!this.closeOverlayCallback)\n                return;\n            (await this.closeOverlayCallback)();\n            delete this.closeOverlayCallback;\n        };\n        this.addEventListener('sp-overlay-query', this.onOverlayQuery);\n    }\n    static get styles() {\n        return [tooltipStyles];\n    }\n    get variant() {\n        return this._variant;\n    }\n    set variant(variant) {\n        if (variant === this.variant) {\n            return;\n        }\n        if (['info', 'positive', 'negative'].includes(variant)) {\n            this.setAttribute('variant', variant);\n            this._variant = variant;\n            return;\n        }\n        this.removeAttribute('variant');\n        this._variant = '';\n    }\n    onOverlayQuery(event) {\n        /* c8 ignore next */\n        if (!event.target)\n            return;\n        const target = event.target;\n        /* c8 ignore next */\n        if (target !== this)\n            return;\n        event.detail.overlayContentTipElement = this.tipElement;\n    }\n    overlayWillOpenCallback({ trigger, }) {\n        this.setAttribute('aria-hidden', 'true');\n        if (!this._proxy) {\n            this._proxy = document.createElement('span');\n            this._proxy.textContent = this.textContent;\n            this._proxy.id = this._tooltipId;\n            this._proxy.hidden = true;\n            this._proxy.setAttribute('role', 'tooltip');\n        }\n        trigger.setAttribute('aria-describedby', this._tooltipId);\n        trigger.insertAdjacentElement('beforebegin', this._proxy);\n    }\n    overlayOpenCancelledCallback({ trigger, }) {\n        this.overlayCloseCallback({ trigger });\n    }\n    overlayCloseCallback({ trigger }) {\n        trigger.removeAttribute('aria-describedby');\n        this.removeAttribute('aria-hidden');\n        this.removeProxy();\n    }\n    removeProxy() {\n        if (this._proxy) {\n            this._proxy.remove();\n            this._proxy = undefined;\n        }\n    }\n    manageTooltip() {\n        const parentElement = this.parentElement;\n        if (this.selfManaged) {\n            parentElement.addEventListener('pointerenter', this.openOverlay);\n            parentElement.addEventListener('focusin', this.openOverlay);\n            parentElement.addEventListener('pointerleave', this.closeOverlay);\n            parentElement.addEventListener('focusout', this.closeOverlay);\n        }\n        else {\n            parentElement.removeEventListener('pointerenter', this.openOverlay);\n            parentElement.removeEventListener('focusin', this.openOverlay);\n            parentElement.removeEventListener('pointerleave', this.closeOverlay);\n            parentElement.removeEventListener('focusout', this.closeOverlay);\n        }\n    }\n    render() {\n        return html `\n            <slot name=\"icon\"></slot>\n            <span id=\"label\"><slot></slot></span>\n            <span id=\"tip\"></span>\n        `;\n    }\n    async update(changed) {\n        if (changed.has('open') && this.selfManaged) {\n            if (this.open) {\n                this.openOverlay();\n            }\n            else {\n                this.closeOverlay();\n            }\n        }\n        super.update(changed);\n    }\n    updated(changed) {\n        super.updated(changed);\n        if (changed.has('selfManaged')) {\n            this.manageTooltip();\n        }\n    }\n}\n/**\n * @private\n */\nTooltip.instanceCount = 0;\n__decorate([\n    property({ type: Boolean, attribute: 'self-managed' })\n], Tooltip.prototype, \"selfManaged\", void 0);\n__decorate([\n    property({ type: Number, reflect: true })\n], Tooltip.prototype, \"offset\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Tooltip.prototype, \"open\", void 0);\n__decorate([\n    property({ reflect: true })\n], Tooltip.prototype, \"placement\", void 0);\n__decorate([\n    query('#tip')\n], Tooltip.prototype, \"tipElement\", void 0);\n__decorate([\n    property({ type: String })\n], Tooltip.prototype, \"variant\", null);\n//# sourceMappingURL=Tooltip.js.map","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { PolymerElement, html } from '@polymer/polymer/polymer-element.js';\nimport { GestureEventListeners } from '@polymer/polymer/lib/mixins/gesture-event-listeners.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ControlStateMixin } from '@vaadin/vaadin-control-state-mixin/vaadin-control-state-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\n\n/**\n * `<vaadin-checkbox>` is a Web Component for customized checkboxes.\n *\n * ```html\n * <vaadin-checkbox>\n *   Make my profile visible\n * </vaadin-checkbox>\n * ```\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name         | Description\n * ------------------|----------------\n * `checkbox`        | The wrapper element for the native <input type=\"checkbox\">\n * `label`           | The wrapper element in which the component's children, namely the label, is slotted\n *\n * The following state attributes are available for styling:\n *\n * Attribute    | Description | Part name\n * -------------|-------------|--------------\n * `active`     | Set when the checkbox is pressed down, either with mouse, touch or the keyboard. | `:host`\n * `disabled`   | Set when the checkbox is disabled. | `:host`\n * `focus-ring` | Set when the checkbox is focused using the keyboard. | `:host`\n * `focused`    | Set when the checkbox is focused. | `:host`\n * `indeterminate` | Set when the checkbox is in indeterminate mode. | `:host`\n * `checked` | Set when the checkbox is checked. | `:host`\n * `empty` | Set when there is no label provided. | `label`\n *\n * See [Styling Components](https://vaadin.com/docs/latest/ds/customization/styling-components) documentation.\n *\n * @fires {Event} change - Fired when the user commits a value change.\n * @fires {CustomEvent} checked-changed - Fired when the `checked` property changes.\n * @fires {CustomEvent} indeterminate-changed - Fired when the `indeterminate` property changes.\n *\n * @extends HTMLElement\n * @mixes ElementMixin\n * @mixes ControlStateMixin\n * @mixes ThemableMixin\n * @mixes GestureEventListeners\n */\nclass CheckboxElement extends ElementMixin(ControlStateMixin(ThemableMixin(GestureEventListeners(PolymerElement)))) {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          display: inline-block;\n        }\n\n        :host([hidden]) {\n          display: none !important;\n        }\n\n        label {\n          display: inline-flex;\n          align-items: baseline;\n          outline: none;\n        }\n\n        [part='checkbox'] {\n          position: relative;\n          display: inline-block;\n          flex: none;\n        }\n\n        input[type='checkbox'] {\n          position: absolute;\n          top: 0;\n          left: 0;\n          right: 0;\n          width: 100%;\n          height: 100%;\n          opacity: 0;\n          cursor: inherit;\n          margin: 0;\n        }\n\n        :host([disabled]) {\n          -webkit-tap-highlight-color: transparent;\n        }\n      </style>\n\n      <label>\n        <span part=\"checkbox\">\n          <input\n            type=\"checkbox\"\n            checked=\"{{checked::change}}\"\n            disabled$=\"[[disabled]]\"\n            indeterminate=\"{{indeterminate::change}}\"\n            role=\"presentation\"\n            tabindex=\"-1\"\n          />\n        </span>\n\n        <span part=\"label\">\n          <slot></slot>\n        </span>\n      </label>\n    `;\n  }\n\n  static get is() {\n    return 'vaadin-checkbox';\n  }\n\n  static get version() {\n    return '21.0.5';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * True if the checkbox is checked.\n       * @type {boolean}\n       */\n      checked: {\n        type: Boolean,\n        value: false,\n        notify: true,\n        observer: '_checkedChanged',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Indeterminate state of the checkbox when it's neither checked nor unchecked, but undetermined.\n       * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Indeterminate_state_checkboxes\n       * @type {boolean}\n       */\n      indeterminate: {\n        type: Boolean,\n        notify: true,\n        observer: '_indeterminateChanged',\n        reflectToAttribute: true,\n        value: false\n      },\n\n      /**\n       * The value given to the data submitted with the checkbox's name to the server when the control is inside a form.\n       */\n      value: {\n        type: String,\n        value: 'on'\n      },\n\n      /** @private */\n      _nativeCheckbox: {\n        type: Object\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    /**\n     * @type {string}\n     * Name of the element.\n     */\n    this.name;\n  }\n\n  get name() {\n    return this.checked ? this._storedName : '';\n  }\n\n  set name(name) {\n    this._storedName = name;\n  }\n\n  ready() {\n    super.ready();\n\n    this.setAttribute('role', 'checkbox');\n\n    this._nativeCheckbox = this.shadowRoot.querySelector('input[type=\"checkbox\"]');\n\n    this.addEventListener('click', this._handleClick.bind(this));\n\n    this._addActiveListeners();\n\n    const attrName = this.getAttribute('name');\n    if (attrName) {\n      this.name = attrName;\n    }\n\n    this.shadowRoot\n      .querySelector('[part~=\"label\"]')\n      .querySelector('slot')\n      .addEventListener('slotchange', this._updateLabelAttribute.bind(this));\n\n    this._updateLabelAttribute();\n  }\n\n  /** @private */\n  _updateLabelAttribute() {\n    const label = this.shadowRoot.querySelector('[part~=\"label\"]');\n    const assignedNodes = label.firstElementChild.assignedNodes();\n    if (this._isAssignedNodesEmpty(assignedNodes)) {\n      label.setAttribute('empty', '');\n    } else {\n      label.removeAttribute('empty');\n    }\n  }\n\n  /** @private */\n  _isAssignedNodesEmpty(nodes) {\n    // The assigned nodes considered to be empty if there is no slotted content or only one empty text node\n    return (\n      nodes.length === 0 ||\n      (nodes.length == 1 && nodes[0].nodeType == Node.TEXT_NODE && nodes[0].textContent.trim() === '')\n    );\n  }\n\n  /** @private */\n  _checkedChanged(checked) {\n    if (this.indeterminate) {\n      this.setAttribute('aria-checked', 'mixed');\n    } else {\n      this.setAttribute('aria-checked', Boolean(checked));\n    }\n  }\n\n  /** @private */\n  _indeterminateChanged(indeterminate) {\n    if (indeterminate) {\n      this.setAttribute('aria-checked', 'mixed');\n    } else {\n      this.setAttribute('aria-checked', this.checked);\n    }\n  }\n\n  /** @private */\n  _addActiveListeners() {\n    // DOWN\n    this._addEventListenerToNode(this, 'down', (e) => {\n      if (this.__interactionsAllowed(e)) {\n        this.setAttribute('active', '');\n      }\n    });\n\n    // UP\n    this._addEventListenerToNode(this, 'up', () => this.removeAttribute('active'));\n\n    // KEYDOWN\n    this.addEventListener('keydown', (e) => {\n      if (this.__interactionsAllowed(e) && e.keyCode === 32) {\n        e.preventDefault();\n        this.setAttribute('active', '');\n      }\n    });\n\n    // KEYUP\n    this.addEventListener('keyup', (e) => {\n      if (this.__interactionsAllowed(e) && e.keyCode === 32) {\n        e.preventDefault();\n        this._toggleChecked();\n        this.removeAttribute('active');\n\n        if (this.indeterminate) {\n          this.indeterminate = false;\n        }\n      }\n    });\n  }\n\n  /**\n   * @return {!HTMLInputElement}\n   * @protected\n   */\n  get focusElement() {\n    return this.shadowRoot.querySelector('input');\n  }\n\n  /**\n   * True if users' interactions (mouse or keyboard)\n   * should toggle the checkbox\n   */\n  __interactionsAllowed(e) {\n    if (this.disabled) {\n      return false;\n    }\n\n    // https://github.com/vaadin/vaadin-checkbox/issues/63\n    if (e.target.localName === 'a') {\n      return false;\n    }\n\n    return true;\n  }\n\n  /** @private */\n  _handleClick(e) {\n    if (this.__interactionsAllowed(e)) {\n      if (!this.indeterminate) {\n        if (e.composedPath()[0] !== this._nativeCheckbox) {\n          e.preventDefault();\n          this._toggleChecked();\n        }\n      } else {\n        /*\n         * Required for IE 11 and Edge.\n         * See issue here: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7344418/\n         */\n        this.indeterminate = false;\n        e.preventDefault();\n        this._toggleChecked();\n      }\n    }\n  }\n\n  /** @protected */\n  _toggleChecked() {\n    this.checked = !this.checked;\n    this.dispatchEvent(new CustomEvent('change', { composed: false, bubbles: true }));\n  }\n\n  /**\n   * Fired when the user commits a value change.\n   *\n   * @event change\n   */\n}\n\ncustomElements.define(CheckboxElement.is, CheckboxElement);\n\nexport { CheckboxElement };\n","import { registerStyles, css } from '@vaadin/vaadin-themable-mixin/register-styles.js';\nimport '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\n\nregisterStyles(\n  'vaadin-checkbox',\n  css`\n    :host {\n      -webkit-tap-highlight-color: transparent;\n      -webkit-user-select: none;\n      -moz-user-select: none;\n      user-select: none;\n      cursor: default;\n      outline: none;\n    }\n\n    [part='label']:not([empty]) {\n      margin: 0.1875em 0.875em 0.1875em 0.375em;\n    }\n\n    [part='checkbox'] {\n      width: calc(1em + 2px);\n      height: calc(1em + 2px);\n      margin: 0.1875em;\n      position: relative;\n      border-radius: var(--lumo-border-radius-s);\n      background-color: var(--lumo-contrast-20pct);\n      transition: transform 0.2s cubic-bezier(0.12, 0.32, 0.54, 2), background-color 0.15s;\n      pointer-events: none;\n      line-height: 1.2;\n      cursor: var(--lumo-clickable-cursor);\n    }\n\n    :host([indeterminate]) [part='checkbox'],\n    :host([checked]) [part='checkbox'] {\n      background-color: var(--lumo-primary-color);\n    }\n\n    /* Needed to align the checkbox nicely on the baseline */\n    [part='checkbox']::before {\n      content: '\\\\2003';\n    }\n\n    /* Checkmark */\n    [part='checkbox']::after {\n      content: '';\n      display: inline-block;\n      width: 0;\n      height: 0;\n      border: 0 solid var(--lumo-primary-contrast-color);\n      border-width: 0.1875em 0 0 0.1875em;\n      box-sizing: border-box;\n      transform-origin: 0 0;\n      position: absolute;\n      top: 0.8125em;\n      left: 0.5em;\n      transform: scale(0.55) rotate(-135deg);\n      opacity: 0;\n    }\n\n    :host([checked]) [part='checkbox']::after {\n      opacity: 1;\n      width: 0.625em;\n      height: 1.0625em;\n    }\n\n    /* Indeterminate checkmark */\n    :host([indeterminate]) [part='checkbox']::after {\n      transform: none;\n      opacity: 1;\n      top: 45%;\n      height: 10%;\n      left: 22%;\n      right: 22%;\n      width: auto;\n      border: 0;\n      background-color: var(--lumo-primary-contrast-color);\n      transition: opacity 0.25s;\n    }\n\n    /* Focus ring */\n    :host([focus-ring]) [part='checkbox'] {\n      box-shadow: 0 0 0 3px var(--lumo-primary-color-50pct);\n    }\n\n    /* Disabled */\n    :host([disabled]) {\n      pointer-events: none;\n      color: var(--lumo-disabled-text-color);\n    }\n\n    :host([disabled]) [part='label'] ::slotted(*) {\n      color: inherit;\n    }\n\n    :host([disabled]) [part='checkbox'] {\n      background-color: var(--lumo-contrast-10pct);\n    }\n\n    :host([disabled]) [part='checkbox']::after {\n      border-color: var(--lumo-contrast-30pct);\n    }\n\n    :host([indeterminate][disabled]) [part='checkbox']::after {\n      background-color: var(--lumo-contrast-30pct);\n    }\n\n    /* RTL specific styles */\n    :host([dir='rtl']) [part='label']:not([empty]) {\n      margin: 0.1875em 0.375em 0.1875em 0.875em;\n    }\n\n    /* Transition the checkmark if activated with the mouse (disabled for grid select-all this way) */\n    :host(:hover) [part='checkbox']::after {\n      transition: width 0.1s, height 0.25s;\n    }\n\n    /* Used for activation \"halo\" */\n    [part='checkbox']::before {\n      color: transparent;\n      display: inline-block;\n      width: 100%;\n      height: 100%;\n      border-radius: inherit;\n      background-color: inherit;\n      transform: scale(1.4);\n      opacity: 0;\n      transition: transform 0.1s, opacity 0.8s;\n    }\n\n    /* Hover */\n    :host(:not([checked]):not([indeterminate]):not([disabled]):hover) [part='checkbox'] {\n      background-color: var(--lumo-contrast-30pct);\n    }\n\n    /* Disable hover for touch devices */\n    @media (pointer: coarse) {\n      :host(:not([checked]):not([indeterminate]):not([disabled]):hover) [part='checkbox'] {\n        background-color: var(--lumo-contrast-20pct);\n      }\n    }\n\n    /* Active */\n    :host([active]) [part='checkbox'] {\n      transform: scale(0.9);\n      transition-duration: 0.05s;\n    }\n\n    :host([active][checked]) [part='checkbox'] {\n      transform: scale(1.1);\n    }\n\n    :host([active]:not([checked])) [part='checkbox']::before {\n      transition-duration: 0.01s, 0.01s;\n      transform: scale(0);\n      opacity: 0.4;\n    }\n  `,\n  { moduleId: 'lumo-checkbox' }\n);\n","import { registerStyles, css } from '@vaadin/vaadin-themable-mixin/register-styles.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport '@vaadin/vaadin-lumo-styles/mixins/menu-overlay.js';\nimport '@vaadin/vaadin-lumo-styles/font-icons.js';\nimport '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/sizing.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\n\nregisterStyles(\n  'vaadin-context-menu-overlay',\n  css`\n    :host([phone]) {\n      top: 0 !important;\n      right: 0 !important;\n      bottom: var(--vaadin-overlay-viewport-bottom) !important;\n      left: 0 !important;\n      align-items: stretch;\n      justify-content: flex-end;\n    }\n\n    /* TODO These style overrides should not be needed.\n       We should instead offer a way to have non-selectable items inside the context menu. */\n\n    :host {\n      --_lumo-list-box-item-selected-icon-display: none;\n      --_lumo-list-box-item-padding-left: calc(var(--lumo-space-m) + var(--lumo-border-radius-m) / 4);\n    }\n\n    [part='overlay'] {\n      outline: none;\n    }\n  `,\n  { include: ['lumo-menu-overlay'], moduleId: 'lumo-context-menu-overlay' }\n);\n\nregisterStyles(\n  'vaadin-context-menu-list-box',\n  css`\n    :host(.vaadin-menu-list-box) {\n      --_lumo-list-box-item-selected-icon-display: block;\n    }\n\n    /* Normal item */\n    [part='items'] ::slotted(.vaadin-menu-item) {\n      -webkit-tap-highlight-color: var(--lumo-primary-color-10pct);\n      cursor: default;\n    }\n\n    [part='items'] ::slotted(.vaadin-menu-item) {\n      outline: none;\n      border-radius: var(--lumo-border-radius-m);\n      padding-left: var(--_lumo-list-box-item-padding-left, calc(var(--lumo-border-radius-m) / 4));\n      padding-right: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);\n    }\n\n    :host(.vaadin-menu-list-box) [part='items'] ::slotted(.vaadin-menu-item) {\n      padding-left: calc(var(--lumo-border-radius-m) / 4);\n      padding-right: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);\n    }\n\n    /* Hovered item */\n    /* TODO a workaround until we have \"focus-follows-mouse\". After that, use the hover style for focus-ring as well */\n    [part='items'] ::slotted(.vaadin-menu-item:hover:not([disabled])),\n    [part='items'] ::slotted(.vaadin-menu-item[expanded]:not([disabled])) {\n      background-color: var(--lumo-primary-color-10pct);\n    }\n\n    /* RTL styles */\n    :host([dir='rtl'])[part='items'] ::slotted(.vaadin-menu-item) {\n      padding-left: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);\n      padding-right: var(--_lumo-list-box-item-padding-left, calc(var(--lumo-border-radius-m) / 4));\n    }\n\n    :host([dir='rtl'].vaadin-menu-list-box) [part='items'] ::slotted(.vaadin-menu-item) {\n      padding-left: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);\n      padding-right: calc(var(--lumo-border-radius-m) / 4);\n    }\n\n    /* Focused item */\n    @media (pointer: coarse) {\n      [part='items'] ::slotted(.vaadin-menu-item:hover:not([expanded]):not([disabled])) {\n        background-color: transparent;\n      }\n    }\n  `,\n  { moduleId: 'lumo-context-menu-list-box' }\n);\n\nregisterStyles(\n  'vaadin-context-menu-item',\n  css`\n    :host {\n      user-select: none;\n      -ms-user-select: none;\n      -webkit-user-select: none;\n    }\n\n    :host(.vaadin-menu-item[menu-item-checked])::before {\n      opacity: 1;\n    }\n\n    :host(.vaadin-menu-item.vaadin-context-menu-parent-item)::after {\n      font-family: lumo-icons;\n      font-size: var(--lumo-icon-size-xs);\n      content: var(--lumo-icons-angle-right);\n      color: var(--lumo-tertiary-text-color);\n    }\n\n    :host(:not([dir='rtl']).vaadin-menu-item.vaadin-context-menu-parent-item)::after {\n      margin-right: calc(var(--lumo-space-m) * -1);\n      padding-left: var(--lumo-space-m);\n    }\n\n    :host([expanded]) {\n      background-color: var(--lumo-primary-color-10pct);\n    }\n\n    /* RTL styles */\n    :host([dir='rtl'].vaadin-menu-item.vaadin-context-menu-parent-item)::after {\n      content: var(--lumo-icons-angle-left);\n      margin-left: calc(var(--lumo-space-m) * -1);\n      padding-right: var(--lumo-space-m);\n    }\n  `,\n  { moduleId: 'lumo-context-menu-item' }\n);\n","import { registerStyles, css } from '@vaadin/vaadin-themable-mixin/register-styles.js';\nimport '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\n\nregisterStyles(\n  'vaadin-list-box',\n  css`\n    :host {\n      -webkit-tap-highlight-color: transparent;\n      --_lumo-item-selected-icon-display: var(--_lumo-list-box-item-selected-icon-display, block);\n    }\n\n    /* Normal item */\n    [part='items'] ::slotted(vaadin-item) {\n      -webkit-tap-highlight-color: var(--lumo-primary-color-10pct);\n      cursor: var(--lumo-clickable-cursor);\n      outline: none;\n      border-radius: var(--lumo-border-radius-m);\n      padding-left: var(--_lumo-list-box-item-padding-left, calc(var(--lumo-border-radius-m) / 4));\n      padding-right: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);\n    }\n\n    [part='items'] ::slotted(vaadin-item[disabled]) {\n      cursor: default;\n    }\n\n    /* Workaround to display checkmark in IE11 when list-box is not used in dropdown-menu */\n    [part='items'] ::slotted(vaadin-item)::before {\n      display: var(--_lumo-item-selected-icon-display);\n    }\n\n    /* Hovered item */\n    /* TODO a workaround until we have \"focus-follows-mouse\". After that, use the hover style for focus-ring as well */\n    [part='items'] ::slotted(vaadin-item:hover:not([disabled])) {\n      background-color: var(--lumo-primary-color-10pct);\n    }\n\n    /* Focused item */\n    [part='items'] ::slotted([focus-ring]:not([disabled])) {\n      box-shadow: inset 0 0 0 2px var(--lumo-primary-color-50pct);\n    }\n\n    @media (pointer: coarse) {\n      [part='items'] ::slotted(vaadin-item:hover:not([disabled])) {\n        background-color: transparent;\n      }\n\n      [part='items'] ::slotted([focus-ring]:not([disabled])) {\n        box-shadow: none;\n      }\n    }\n\n    /* Dividers */\n    [part='items'] ::slotted(hr) {\n      height: 1px;\n      border: 0;\n      padding: 0;\n      margin: var(--lumo-space-s) var(--lumo-border-radius-m);\n      background-color: var(--lumo-contrast-10pct);\n    }\n\n    /* RTL specific styles */\n    :host([dir='rtl']) [part='items'] ::slotted(vaadin-item) {\n      padding-left: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);\n      padding-right: var(--_lumo-list-box-item-padding-left, calc(var(--lumo-border-radius-m) / 4));\n    }\n  `,\n  { moduleId: 'lumo-list-box' }\n);\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { PolymerElement, html } from '@polymer/polymer/polymer-element.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { MultiSelectListMixin } from '@vaadin/vaadin-list-mixin/vaadin-multi-select-list-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\n\n/**\n * `<vaadin-list-box>` is a Web Component for creating menus.\n *\n * ```\n *   <vaadin-list-box selected=\"2\">\n *     <vaadin-item>Item 1</vaadin-item>\n *     <vaadin-item>Item 2</vaadin-item>\n *     <vaadin-item>Item 3</vaadin-item>\n *     <vaadin-item>Item 4</vaadin-item>\n *   </vaadin-list-box>\n * ```\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name         | Description\n * ------------------|------------------------\n * `items`           | The items container\n *\n * See [Styling Components](https://vaadin.com/docs/latest/ds/customization/styling-components) documentation.\n *\n * @fires {CustomEvent} items-changed - Fired when the `items` property changes.\n * @fires {CustomEvent} selected-changed - Fired when the `selected` property changes.\n * @fires {CustomEvent} selected-values-changed - Fired when the `selectedValues` property changes.\n *\n * @extends HTMLElement\n * @mixes MultiSelectListMixin\n * @mixes ThemableMixin\n * @mixes ElementMixin\n */\nclass ListBoxElement extends ElementMixin(MultiSelectListMixin(ThemableMixin(PolymerElement))) {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          display: flex;\n        }\n\n        :host([hidden]) {\n          display: none !important;\n        }\n\n        [part='items'] {\n          height: 100%;\n          width: 100%;\n          overflow-y: auto;\n          -webkit-overflow-scrolling: touch;\n        }\n      </style>\n      <div part=\"items\">\n        <slot></slot>\n      </div>\n    `;\n  }\n\n  static get is() {\n    return 'vaadin-list-box';\n  }\n\n  static get version() {\n    return '21.0.5';\n  }\n\n  static get properties() {\n    return {\n      // We don't need to define this property since super default is vertical,\n      // but we don't want it to be modified, or be shown in the API docs.\n      /** @private */\n      orientation: {\n        readOnly: true\n      }\n    };\n  }\n\n  constructor() {\n    super();\n\n    /**\n     * @type {Element | null}\n     * @protected\n     */\n    this.focused;\n  }\n\n  ready() {\n    super.ready();\n    this.setAttribute('role', 'list');\n\n    setTimeout(this._checkImport.bind(this), 2000);\n  }\n\n  /**\n   * @return {!HTMLElement}\n   * @protected\n   */\n  get _scrollerElement() {\n    return this.shadowRoot.querySelector('[part=\"items\"]');\n  }\n\n  /** @private */\n  _checkImport() {\n    var item = this.querySelector('vaadin-item');\n    if (item && !(item instanceof PolymerElement)) {\n      console.warn(`Make sure you have imported the vaadin-item element.`);\n    }\n  }\n}\n\ncustomElements.define(ListBoxElement.is, ListBoxElement);\n\nexport { ListBoxElement };\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { registerStyles, css } from '@vaadin/vaadin-themable-mixin/register-styles.js';\nimport { OverlayElement } from '@vaadin/vaadin-overlay/src/vaadin-overlay.js';\n\nregisterStyles(\n  'vaadin-context-menu-overlay',\n  css`\n    :host {\n      align-items: flex-start;\n      justify-content: flex-start;\n    }\n\n    :host([right-aligned]),\n    :host([end-aligned]) {\n      align-items: flex-end;\n    }\n\n    :host([bottom-aligned]) {\n      justify-content: flex-end;\n    }\n\n    [part='overlay'] {\n      background-color: #fff;\n    }\n  `,\n  { moduleId: 'vaadin-context-menu-overlay-styles' }\n);\n\n/**\n * An element used internally by `<vaadin-context-menu>`. Not intended to be used separately.\n *\n * @extends OverlayElement\n * @protected\n */\nclass ContextMenuOverlayElement extends OverlayElement {\n  static get is() {\n    return 'vaadin-context-menu-overlay';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * @protected\n       */\n      parentOverlay: {\n        type: Object,\n        readOnly: true\n      }\n    };\n  }\n\n  static get observers() {\n    return ['_themeChanged(theme)'];\n  }\n\n  ready() {\n    super.ready();\n\n    this.addEventListener('keydown', (e) => {\n      if (!e.defaultPrevented && e.composedPath()[0] === this.$.overlay && [38, 40].indexOf(e.keyCode) > -1) {\n        const child = this.getFirstChild();\n        if (child && Array.isArray(child.items) && child.items.length) {\n          e.preventDefault();\n          if (e.keyCode === 38) {\n            child.items[child.items.length - 1].focus();\n          } else {\n            child.focus();\n          }\n        }\n      }\n    });\n  }\n\n  getFirstChild() {\n    return this.content.querySelector(':not(style):not(slot)');\n  }\n\n  _themeChanged() {\n    this.close();\n  }\n\n  getBoundaries() {\n    // Measure actual overlay and content sizes\n    const overlayRect = this.getBoundingClientRect();\n    const contentRect = this.$.overlay.getBoundingClientRect();\n\n    // Maximum x and y values are imposed by content size and overlay limits.\n    let yMax = overlayRect.bottom - contentRect.height;\n\n    // Adjust constraints to ensure bottom-aligned applies to sub-menu.\n    const parent = this.parentOverlay;\n    if (parent && parent.hasAttribute('bottom-aligned')) {\n      const parentStyle = getComputedStyle(parent);\n      yMax = yMax - parseFloat(parentStyle.bottom) - parseFloat(parentStyle.height);\n    }\n\n    return {\n      xMax: overlayRect.right - contentRect.width,\n      xMin: overlayRect.left + contentRect.width,\n      yMax,\n      left: overlayRect.left,\n      right: overlayRect.right,\n      top: overlayRect.top,\n      width: contentRect.width\n    };\n  }\n}\n\ncustomElements.define(ContextMenuOverlayElement.is, ContextMenuOverlayElement);\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { PolymerElement, html } from '@polymer/polymer/polymer-element.js';\nimport { gestures, addListener, removeListener } from '@polymer/polymer/lib/utils/gestures.js';\nimport { GestureEventListeners } from '@polymer/polymer/lib/mixins/gesture-event-listeners.js';\nimport { ItemsMixin } from './vaadin-contextmenu-items-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { processTemplates } from '@vaadin/vaadin-element-mixin/templates.js';\nimport { ThemePropertyMixin } from '@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js';\nimport './vaadin-contextmenu-event.js';\nimport './vaadin-device-detector.js';\nimport './vaadin-context-menu-overlay.js';\n\n/**\n * `<vaadin-context-menu>` is a Web Component for creating context menus.\n *\n * ### Items\n *\n * Items is a higher level convenience API for defining a (hierarchical) menu structure for the component.\n * If a menu item has a non-empty `children` set, a sub-menu with the child items is opened\n * next to the parent menu on mouseover, tap or a right arrow keypress.\n *\n * When an item is selected, `<vaadin-context-menu>` dispatches an \"item-selected\" event\n * with the selected item as `event.detail.value` property.\n *\n * ```javascript\n * contextMenu.items = [\n *   {text: 'Menu Item 1', children:\n *     [\n *       {text: 'Menu Item 1-1', checked: true},\n *       {text: 'Menu Item 1-2'}\n *     ]\n *   },\n *   {component: 'hr'},\n *   {text: 'Menu Item 2', children:\n *     [\n *       {text: 'Menu Item 2-1'},\n *       {text: 'Menu Item 2-2', disabled: true}\n *     ]\n *   },\n *   {text: 'Menu Item 3', disabled: true}\n * ];\n *\n * contextMenu.addEventListener('item-selected', e => {\n *   const item = e.detail.value;\n *   console.log(`${item.text} selected`);\n * });\n * ```\n *\n * **NOTE:** when the `items` array is defined, the renderer cannot be used.\n *\n * ### Rendering\n *\n * The content of the menu can be populated by using the renderer callback function.\n *\n * The renderer function provides `root`, `contextMenu`, `model` arguments when applicable.\n * Generate DOM content by using `model` object properties if needed, append it to the `root`\n * element and control the state of the host element by accessing `contextMenu`. Before generating\n * new content, the renderer function should check if there is already content in `root` for reusing it.\n *\n * ```html\n * <vaadin-context-menu id=\"contextMenu\">\n *  <p>This paragraph has a context menu.</p>\n * </vaadin-context-menu>\n * ```\n * ```js\n * const contextMenu = document.querySelector('#contextMenu');\n * contextMenu.renderer = (root, contextMenu, context) => {\n *   let listBox = root.firstElementChild;\n *   if (!listBox) {\n *     listBox = document.createElement('vaadin-list-box');\n *     root.appendChild(listBox);\n *   }\n *\n *   let item = listBox.querySelector('vaadin-item');\n *   if (!item) {\n *     item = document.createElement('vaadin-item');\n *     listBox.appendChild(item);\n *   }\n *   item.textContent = 'Content of the selector: ' + context.target.textContent;\n * };\n * ```\n *\n * You can access the menu context inside the renderer using\n * `context.target` and `context.detail`.\n *\n * Renderer is called on the opening of the context-menu and each time the related context is updated.\n * DOM generated during the renderer call can be reused\n * in the next renderer call and will be provided with the `root` argument.\n * On first call it will be empty.\n *\n * ### vaadin-contextmenu Gesture Event\n *\n * `vaadin-contextmenu` is a gesture event (a custom event),\n * which is dispatched after either `contextmenu` or long touch events.\n * This enables support for both mouse and touch environments in a uniform way.\n *\n * `<vaadin-context-menu>` opens the menu overlay on the `vaadin-contextmenu`\n * event by default.\n *\n * ### Menu Listener\n *\n * By default, the `<vaadin-context-menu>` element listens for the menu opening\n * event on itself. In case if you do not want to wrap the target, you can listen for\n * events on an element outside the `<vaadin-context-menu>` by setting the\n * `listenOn` property:\n *\n * ```html\n * <vaadin-context-menu id=\"contextMenu\"></vaadin-context-menu>\n *\n * <div id=\"menuListener\">The element that listens for the contextmenu event.</div>\n * ```\n * ```javascript\n * const contextMenu = document.querySelector('#contextMenu');\n * contextMenu.listenOn = document.querySelector('#menuListener');\n * ```\n *\n * ### Filtering Menu Targets\n *\n * By default, the listener element and all its descendants open the context\n * menu. You can filter the menu targets to a smaller set of elements inside\n * the listener element by setting the `selector` property.\n *\n * In the following example, only the elements matching `.has-menu` will open the context menu:\n *\n * ```html\n * <vaadin-context-menu selector=\".has-menu\">\n *   <p class=\"has-menu\">This paragraph opens the context menu</p>\n *   <p>This paragraph does not open the context menu</p>\n * </vaadin-context-menu>\n * ```\n *\n * ### Menu Context\n *\n * The following properties are available in the `context` argument:\n *\n * - `target` is the menu opening event target, which is the element that\n * the user has called the context menu for\n * - `detail` is the menu opening event detail\n *\n * In the following example, the menu item text is composed with the contents\n * of the element that opened the menu:\n *\n * ```html\n * <vaadin-context-menu selector=\"li\" id=\"contextMenu\">\n *   <ul>\n *     <li>Foo</li>\n *     <li>Bar</li>\n *     <li>Baz</li>\n *   </ul>\n * </vaadin-context-menu>\n * ```\n * ```js\n * const contextMenu = document.querySelector('#contextMenu');\n * contextMenu.renderer = (root, contextMenu, context) => {\n *   let listBox = root.firstElementChild;\n *   if (!listBox) {\n *     listBox = document.createElement('vaadin-list-box');\n *     root.appendChild(listBox);\n *   }\n *\n *   let item = listBox.querySelector('vaadin-item');\n *   if (!item) {\n *     item = document.createElement('vaadin-item');\n *     listBox.appendChild(item);\n *   }\n *   item.textContent = 'The menu target: ' + context.target.textContent;\n * };\n * ```\n *\n * ### Styling\n *\n * `<vaadin-context-menu>` uses `<vaadin-context-menu-overlay>` internal\n * themable component as the actual visible context menu overlay.\n *\n * See [`<vaadin-overlay>`](#/elements/vaadin-overlay)\n * documentation for `<vaadin-context-menu-overlay>` stylable parts.\n *\n * See [Styling Components](https://vaadin.com/docs/latest/ds/customization/styling-components) documentation.\n *\n * ### Internal components\n *\n * When using `items` API, in addition `<vaadin-context-menu-overlay>`, the following\n * internal components are themable:\n *\n * - `<vaadin-context-menu-item>` - has the same API as [`<vaadin-item>`](#/elements/vaadin-item).\n * - `<vaadin-context-menu-list-box>` - has the same API as [`<vaadin-list-box>`](#/elements/vaadin-list-box).\n *\n * Note: the `theme` attribute value set on `<vaadin-context-menu>` is\n * propagated to the internal components listed above.\n *\n * @fires {CustomEvent} opened-changed - Fired when the `opened` property changes.\n * @fires {CustomEvent} item-selected - Fired when an item is selected when the context menu is populated using the `items` API.\n *\n * @extends HTMLElement\n * @mixes ElementMixin\n * @mixes ThemePropertyMixin\n * @mixes ItemsMixin\n * @mixes GestureEventListeners\n */\nclass ContextMenuElement extends ElementMixin(ThemePropertyMixin(ItemsMixin(GestureEventListeners(PolymerElement)))) {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          display: block;\n        }\n\n        :host([hidden]) {\n          display: none !important;\n        }\n      </style>\n\n      <slot id=\"slot\"></slot>\n\n      <vaadin-device-detector phone=\"{{_phone}}\" touch=\"{{_touch}}\"></vaadin-device-detector>\n\n      <vaadin-context-menu-overlay\n        id=\"overlay\"\n        on-opened-changed=\"_onOverlayOpened\"\n        on-vaadin-overlay-open=\"_onVaadinOverlayOpen\"\n        with-backdrop=\"[[_phone]]\"\n        phone$=\"[[_phone]]\"\n        model=\"[[_context]]\"\n        theme$=\"[[theme]]\"\n      >\n      </vaadin-context-menu-overlay>\n    `;\n  }\n\n  static get is() {\n    return 'vaadin-context-menu';\n  }\n\n  static get version() {\n    return '21.0.5';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * CSS selector that can be used to target any child element\n       * of the context menu to listen for `openOn` events.\n       */\n      selector: {\n        type: String\n      },\n\n      /**\n       * True if the overlay is currently displayed.\n       * @type {boolean}\n       */\n      opened: {\n        type: Boolean,\n        value: false,\n        notify: true,\n        readOnly: true\n      },\n\n      /**\n       * Event name to listen for opening the context menu.\n       * @attr {string} open-on\n       * @type {string}\n       */\n      openOn: {\n        type: String,\n        value: 'vaadin-contextmenu'\n      },\n\n      /**\n       * The target element that's listened to for context menu opening events.\n       * By default the vaadin-context-menu listens to the target's `vaadin-contextmenu`\n       * events.\n       * @type {!HTMLElement}\n       * @default self\n       */\n      listenOn: {\n        type: Object,\n        value: function () {\n          return this;\n        }\n      },\n\n      /**\n       * Event name to listen for closing the context menu.\n       * @attr {string} close-on\n       * @type {string}\n       */\n      closeOn: {\n        type: String,\n        value: 'click',\n        observer: '_closeOnChanged'\n      },\n\n      /**\n       * Custom function for rendering the content of the menu overlay.\n       * Receives three arguments:\n       *\n       * - `root` The root container DOM element. Append your content to it.\n       * - `contextMenu` The reference to the `<vaadin-context-menu>` element.\n       * - `context` The object with the menu context, contains:\n       *   - `context.target`  the target of the menu opening event,\n       *   - `context.detail` the menu opening event detail.\n       * @type {ContextMenuRenderer | undefined}\n       */\n      renderer: {\n        type: Function\n      },\n\n      /** @private */\n      _context: Object,\n\n      /** @private */\n      _boundClose: Object,\n\n      /** @private */\n      _boundOpen: Object,\n\n      /** @private */\n      _touch: Boolean\n    };\n  }\n\n  static get observers() {\n    return ['_openedChanged(opened)', '_targetOrOpenOnChanged(listenOn, openOn)', '_rendererChanged(renderer, items)'];\n  }\n\n  constructor() {\n    super();\n    this._boundOpen = this.open.bind(this);\n    this._boundClose = this.close.bind(this);\n    this._boundOnGlobalContextMenu = this._onGlobalContextMenu.bind(this);\n  }\n\n  /** @protected */\n  connectedCallback() {\n    super.connectedCallback();\n\n    this.__boundOnScroll = this.__onScroll.bind(this);\n    window.addEventListener('scroll', this.__boundOnScroll, true);\n  }\n\n  /** @protected */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n\n    window.removeEventListener('scroll', this.__boundOnScroll, true);\n    this.close();\n  }\n\n  /** @protected */\n  ready() {\n    super.ready();\n\n    processTemplates(this);\n  }\n\n  /**\n   * Runs before overlay is fully rendered\n   * @private\n   */\n  _onOverlayOpened(e) {\n    this._setOpened(e.detail.value);\n    this.__alignOverlayPosition();\n  }\n\n  /**\n   * Runs after overlay is fully rendered\n   * @private\n   */\n  _onVaadinOverlayOpen() {\n    this.__alignOverlayPosition();\n    this.$.overlay.style.opacity = '';\n    this.__forwardFocus();\n  }\n\n  /** @private */\n  _targetOrOpenOnChanged(listenOn, openOn) {\n    if (this._oldListenOn && this._oldOpenOn) {\n      this._unlisten(this._oldListenOn, this._oldOpenOn, this._boundOpen);\n\n      this._oldListenOn.style.webkitTouchCallout = '';\n      this._oldListenOn.style.webkitUserSelect = '';\n      this._oldListenOn.style.userSelect = '';\n\n      this._oldListenOn = null;\n      this._oldOpenOn = null;\n    }\n\n    if (listenOn && openOn) {\n      this._listen(listenOn, openOn, this._boundOpen);\n\n      this._oldListenOn = listenOn;\n      this._oldOpenOn = openOn;\n    }\n  }\n\n  /** @private */\n  _setListenOnUserSelect(value) {\n    // note: these styles don't seem to work in Firefox on iOS.\n    this.listenOn.style.webkitTouchCallout = value;\n    this.listenOn.style.webkitUserSelect = value; // Chrome, Safari, Firefox\n    this.listenOn.style.userSelect = value;\n\n    // note: because user-selection is disabled on the overlay\n    // before opening the menu the text could be already selected\n    // so we need to clear that selection\n    document.getSelection().removeAllRanges();\n  }\n\n  /** @private */\n  _closeOnChanged(closeOn, oldCloseOn) {\n    // Listen on this.$.overlay.root to workaround issue on\n    //  ShadyDOM polyfill: https://github.com/webcomponents/shadydom/issues/159\n\n    // Outside click event from overlay\n    const evtOverlay = 'vaadin-overlay-outside-click';\n\n    if (oldCloseOn) {\n      this._unlisten(this.$.overlay, oldCloseOn, this._boundClose);\n      this._unlisten(this.$.overlay.root, oldCloseOn, this._boundClose);\n    }\n    if (closeOn) {\n      this._listen(this.$.overlay, closeOn, this._boundClose);\n      this._listen(this.$.overlay.root, closeOn, this._boundClose);\n      this._unlisten(this.$.overlay, evtOverlay, this._preventDefault);\n    } else {\n      this._listen(this.$.overlay, evtOverlay, this._preventDefault);\n    }\n  }\n\n  /** @private */\n  _preventDefault(e) {\n    e.preventDefault();\n  }\n\n  /** @private */\n  _openedChanged(opened) {\n    if (opened) {\n      document.documentElement.addEventListener('contextmenu', this._boundOnGlobalContextMenu, true);\n      this._setListenOnUserSelect('none');\n    } else {\n      document.documentElement.removeEventListener('contextmenu', this._boundOnGlobalContextMenu, true);\n      this._setListenOnUserSelect('');\n    }\n\n    // Has to be set after instance has been created\n    this.$.overlay.opened = opened;\n  }\n\n  /**\n   * Requests an update for the content of the menu overlay.\n   * While performing the update, it invokes the renderer passed in the `renderer` property.\n   *\n   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.\n   */\n  requestContentUpdate() {\n    this.$.overlay.requestContentUpdate();\n  }\n\n  /**\n   * Manually invoke existing renderer.\n   *\n   * @deprecated Since Vaadin 21, `render()` is deprecated. Please use `requestContentUpdate()` instead.\n   */\n  render() {\n    console.warn('WARNING: Since Vaadin 21, render() is deprecated. Please use requestContentUpdate() instead.');\n\n    this.requestContentUpdate();\n  }\n\n  /** @private */\n  _rendererChanged(renderer, items) {\n    if (items) {\n      if (renderer) {\n        throw new Error('The items API cannot be used together with a renderer');\n      }\n\n      if (this.closeOn === 'click') {\n        this.closeOn = '';\n      }\n\n      renderer = this.__itemsRenderer;\n    }\n\n    this.$.overlay.setProperties({ owner: this, renderer });\n  }\n\n  /**\n   * Closes the overlay.\n   */\n  close() {\n    this._setOpened(false);\n  }\n\n  /** @private */\n  _contextTarget(e) {\n    if (this.selector) {\n      const targets = this.listenOn.querySelectorAll(this.selector);\n\n      return Array.prototype.filter.call(targets, (el) => {\n        return e.composedPath().indexOf(el) > -1;\n      })[0];\n    } else {\n      return e.target;\n    }\n  }\n\n  /**\n   * Opens the overlay.\n   * @param {!Event | undefined} e used as the context for the menu. Overlay coordinates are taken from this event.\n   */\n  open(e) {\n    if (e && !this.opened) {\n      this._context = {\n        detail: e.detail,\n        target: this._contextTarget(e)\n      };\n\n      if (this._context.target) {\n        this._preventDefault(e);\n        e.stopPropagation();\n\n        // Used in alignment which is delayed until overlay is rendered\n        this.__x = this._getEventCoordinate(e, 'x');\n        this.__pageXOffset = window.pageXOffset;\n\n        this.__y = this._getEventCoordinate(e, 'y');\n        this.__pageYOffset = window.pageYOffset;\n\n        this.$.overlay.style.opacity = '0';\n        this._setOpened(true);\n      }\n    }\n  }\n\n  /** @private */\n  __onScroll() {\n    if (!this.opened) {\n      return;\n    }\n\n    const yDiff = window.pageYOffset - this.__pageYOffset;\n    const xDiff = window.pageXOffset - this.__pageXOffset;\n\n    this.__adjustPosition('left', -xDiff);\n    this.__adjustPosition('right', xDiff);\n\n    this.__adjustPosition('top', -yDiff);\n    this.__adjustPosition('bottom', yDiff);\n\n    this.__pageYOffset += yDiff;\n    this.__pageXOffset += xDiff;\n  }\n\n  /** @private */\n  __adjustPosition(coord, diff) {\n    const overlay = this.$.overlay;\n    const style = overlay.style;\n\n    style[coord] = (parseInt(style[coord]) || 0) + diff + 'px';\n  }\n\n  /** @private */\n  __alignOverlayPosition() {\n    const overlay = this.$.overlay;\n    const style = overlay.style;\n\n    // Reset all properties before measuring\n    ['top', 'right', 'bottom', 'left'].forEach((prop) => style.removeProperty(prop));\n    ['right-aligned', 'end-aligned', 'bottom-aligned'].forEach((attr) => overlay.removeAttribute(attr));\n\n    // Maximum x and y values are imposed by content size and overlay limits.\n    const { xMax, xMin, yMax, left, right, top, width } = overlay.getBoundaries();\n    // Reuse saved x and y event values, in order to this method be used async\n    // in the `vaadin-overlay-change` which guarantees that overlay is ready\n    let x = this.__x || (!this.__isRTL ? left : right);\n    const y = this.__y || top;\n\n    // Select one overlay corner and move to the event x/y position.\n    // Then set styling attrs for flex-aligning the content appropriately.\n    const wdthVport = document.documentElement.clientWidth;\n    const hghtVport = document.documentElement.clientHeight;\n\n    // Align to the parent menu overlay, if any.\n    const parent = overlay.parentOverlay;\n    let alignedToParent = false;\n    let parentContentRect;\n    if (parent) {\n      parentContentRect = parent.$.overlay.getBoundingClientRect();\n      if (parent.hasAttribute('right-aligned') || parent.hasAttribute('end-aligned')) {\n        const parentStyle = getComputedStyle(parent);\n        const getPadding = (el, direction) => {\n          return parseFloat(getComputedStyle(el.$.content)['padding' + direction]);\n        };\n        const dimensionToSet = parseFloat(parentStyle[this.__isRTL ? 'left' : 'right']) + parentContentRect.width;\n        const padding = getPadding(parent, 'Left') + getPadding(overlay, 'Right');\n\n        // Preserve end-aligned, if possible.\n        if (wdthVport - (dimensionToSet - padding) > width) {\n          this._setEndAligned(overlay);\n          style[this.__isRTL ? 'left' : 'right'] = dimensionToSet + 'px';\n          alignedToParent = true;\n        }\n      } else if (x < parentContentRect.x) {\n        // Check if sub menu opens on the left side and the parent menu is not right aligned.\n        // If so, use actual width of the submenu content instead of the parent menu content.\n        x = x - (width - parentContentRect.width);\n      }\n    }\n\n    if (!alignedToParent) {\n      if (!this.__isRTL) {\n        // Sub-menu is displayed in the right side of root menu\n        if ((x < wdthVport / 2 || x < xMax) && !parent) {\n          style.left = x + 'px';\n        } else if (parent && wdthVport - parentContentRect.width - parentContentRect.left >= parentContentRect.width) {\n          // Sub-menu is displayed in the right side of root menu If it is nested menu\n          style.left = parentContentRect.left + parentContentRect.width + 'px';\n        } else if (parent) {\n          // Sub-menu is displayed in the left side of root menu If it is nested menu\n          style.right = 'auto';\n          style.left =\n            Math.max(\n              overlay.getBoundingClientRect().left,\n              parentContentRect.left - overlay.getBoundingClientRect().width\n            ) + 'px';\n          this._setEndAligned(overlay);\n        } else {\n          // Sub-menu is displayed in the left side of root menu\n          style.right = Math.max(0, wdthVport - x) + 'px';\n          this._setEndAligned(overlay);\n        }\n      } else {\n        // Sub-menu is displayed in the left side of root menu\n        if ((x > wdthVport / 2 || x > xMin) && !parent) {\n          style.right = Math.max(0, wdthVport - x) + 'px';\n        } else if (parent && parentContentRect.left >= parentContentRect.width) {\n          // Sub-menu is displayed in the left side of root menu If it is nested menu\n          style.right = wdthVport - parentContentRect.right + parentContentRect.width + 'px';\n        } else if (parent) {\n          // Sub-menu is displayed in the right side of root menu If it is nested menu\n          style.right = 'auto';\n          style.left =\n            Math.max(\n              overlay.getBoundingClientRect().left - overlay.getBoundingClientRect().width,\n              parentContentRect.right\n            ) + 'px';\n          this._setEndAligned(overlay);\n        } else {\n          // Sub-menu is displayed in the left side of root menu\n          style.left = x + 'px';\n          this._setEndAligned(overlay);\n        }\n      }\n    }\n    if (y < hghtVport / 2 || y < yMax) {\n      style.top = y + 'px';\n    } else {\n      style.bottom = Math.max(0, hghtVport - y) + 'px';\n      overlay.setAttribute('bottom-aligned', '');\n    }\n  }\n\n  /** @private */\n  _setEndAligned(element) {\n    element.setAttribute('end-aligned', '');\n    if (!this.__isRTL) {\n      element.setAttribute('right-aligned', '');\n    }\n  }\n\n  /** @private */\n  _getEventCoordinate(event, coord) {\n    if (event.detail instanceof Object) {\n      if (event.detail[coord]) {\n        // Polymer gesture events, get coordinate from detail\n        return event.detail[coord];\n      } else if (event.detail.sourceEvent) {\n        // Unwrap detailed event\n        return this._getEventCoordinate(event.detail.sourceEvent, coord);\n      }\n    } else {\n      const prop = 'client' + coord.toUpperCase();\n      const position = event.changedTouches ? event.changedTouches[0][prop] : event[prop];\n\n      if (position === 0) {\n        // Native keyboard event\n        const rect = event.target.getBoundingClientRect();\n        return coord === 'x' ? rect.left : rect.top + rect.height;\n      } else {\n        // Native mouse or touch event\n        return position;\n      }\n    }\n  }\n\n  /** @private */\n  _listen(node, evType, handler) {\n    if (gestures[evType]) {\n      addListener(node, evType, handler);\n    } else {\n      node.addEventListener(evType, handler);\n    }\n  }\n\n  /** @private */\n  _unlisten(node, evType, handler) {\n    if (gestures[evType]) {\n      removeListener(node, evType, handler);\n    } else {\n      node.removeEventListener(evType, handler);\n    }\n  }\n\n  /** @private */\n  _onGlobalContextMenu(e) {\n    if (!e.shiftKey) {\n      e.preventDefault();\n      this.close();\n    }\n  }\n\n  /**\n   * Fired when an item is selected when the context menu is populated using the `items` API.\n   *\n   * @event item-selected\n   * @param {Object} detail\n   * @param {Object} detail.value the selected menu item\n   */\n}\n\ncustomElements.define(ContextMenuElement.is, ContextMenuElement);\nexport { ContextMenuElement };\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { PolymerElement, html } from '@polymer/polymer/polymer-element.js';\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\nimport '@vaadin/vaadin-text-field/src/vaadin-text-field.js';\n\n/**\n * `<vaadin-grid-filter>` is a helper element for the `<vaadin-grid>` that provides out-of-the-box UI controls,\n * and handlers for filtering the grid data.\n *\n * #### Example:\n * ```html\n * <vaadin-grid-column id=\"column\"></vaadin-grid-column>\n * ```\n * ```js\n * const column = document.querySelector('#column');\n * column.headerRenderer = (root, column) => {\n *   let filter = root.firstElementChild;\n *   if (!filter) {\n *     filter = document.createElement('vaadin-grid-filter');\n *     root.appendChild(filter);\n *   }\n *   filter.path = 'name.first';\n * };\n * column.renderer = (root, column, model) => {\n *   root.textContent = model.item.name.first;\n * };\n * ```\n *\n * @fires {CustomEvent} value-changed - Fired when the `value` property changes.\n *\n * @extends HTMLElement\n */\nclass GridFilterElement extends class extends PolymerElement {} {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          display: inline-flex;\n          max-width: 100%;\n        }\n\n        #filter {\n          width: 100%;\n          box-sizing: border-box;\n        }\n      </style>\n      <slot name=\"filter\">\n        <vaadin-text-field id=\"filter\" value=\"{{value}}\"></vaadin-text-field>\n      </slot>\n    `;\n  }\n\n  static get is() {\n    return 'vaadin-grid-filter';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * JS Path of the property in the item used for filtering the data.\n       */\n      path: String,\n\n      /**\n       * Current filter value.\n       */\n      value: {\n        type: String,\n        notify: true\n      },\n\n      /** @private */\n      _connected: Boolean\n    };\n  }\n\n  /** @protected */\n  connectedCallback() {\n    super.connectedCallback();\n    this._connected = true;\n  }\n\n  static get observers() {\n    return ['_filterChanged(path, value, _connected)'];\n  }\n\n  /** @protected */\n  ready() {\n    super.ready();\n\n    const child = this.firstElementChild;\n    if (child && child.getAttribute('slot') !== 'filter') {\n      console.warn('Make sure you have assigned slot=\"filter\" to the child elements of <vaadin-grid-filter>');\n      child.setAttribute('slot', 'filter');\n    }\n  }\n\n  /** @private */\n  _filterChanged(path, value, connected) {\n    if (path === undefined || value === undefined || !connected) {\n      return;\n    }\n    if (this._previousValue === undefined && value === '') {\n      return;\n    }\n    this._previousValue = value;\n\n    this._debouncerFilterChanged = Debouncer.debounce(this._debouncerFilterChanged, timeOut.after(200), () => {\n      this.dispatchEvent(new CustomEvent('filter-changed', { bubbles: true }));\n    });\n  }\n\n  focus() {\n    this.$.filter.focus();\n  }\n}\n\ncustomElements.define(GridFilterElement.is, GridFilterElement);\n\nexport { GridFilterElement };\n","import { registerStyles, css } from '@vaadin/vaadin-themable-mixin/register-styles.js';\nimport '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\n\nregisterStyles(\n  'vaadin-grid-sorter',\n  css`\n    :host {\n      justify-content: flex-start;\n      align-items: baseline;\n      -webkit-user-select: none;\n      -moz-user-select: none;\n      user-select: none;\n      cursor: var(--lumo-clickable-cursor);\n    }\n\n    [part='content'] {\n      display: inline-block;\n      overflow: hidden;\n      text-overflow: ellipsis;\n    }\n\n    [part='indicators'] {\n      margin-left: var(--lumo-space-s);\n    }\n\n    :host(:not([direction])) [part='indicators']::before {\n      opacity: 0.2;\n    }\n\n    :host([direction]) {\n      color: var(--lumo-primary-text-color);\n    }\n\n    :host(:hover) [part='indicators'] {\n      color: var(--lumo-body-text-color);\n      opacity: 0.6;\n    }\n\n    [part='order'] {\n      font-size: var(--lumo-font-size-xxs);\n      line-height: 1;\n    }\n\n    /* RTL specific styles */\n\n    :host([dir='rtl']) [part='indicators'] {\n      margin-right: var(--lumo-space-s);\n      margin-left: 0;\n    }\n  `,\n  { moduleId: 'lumo-grid-sorter' }\n);\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { PolymerElement, html } from '@polymer/polymer/polymer-element.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { DirMixin } from '@vaadin/vaadin-element-mixin/vaadin-dir-mixin.js';\n\nconst $_documentContainer = document.createElement('template');\n\n$_documentContainer.innerHTML = `\n  <style>\n    @font-face {\n      font-family: 'vaadin-grid-sorter-icons';\n      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAQwAA0AAAAABuwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAEFAAAABkAAAAcfep+mUdERUYAAAP4AAAAHAAAAB4AJwAOT1MvMgAAAZgAAAA/AAAAYA8TBPpjbWFwAAAB7AAAAFUAAAFeF1fZ4mdhc3AAAAPwAAAACAAAAAgAAAAQZ2x5ZgAAAlgAAABcAAAAnMvguMloZWFkAAABMAAAAC8AAAA2C5Ap72hoZWEAAAFgAAAAHQAAACQGbQPHaG10eAAAAdgAAAAUAAAAHAoAAABsb2NhAAACRAAAABIAAAASAIwAYG1heHAAAAGAAAAAFgAAACAACwAKbmFtZQAAArQAAAECAAACZxWCgKhwb3N0AAADuAAAADUAAABZCrApUXicY2BkYGAA4rDECVrx/DZfGbhZGEDgyqNPOxH0/wNMq5kPALkcDEwgUQBWRA0dAHicY2BkYGA+8P8AAwMLAwgwrWZgZEAFbABY4QM8AAAAeJxjYGRgYOAAQiYGEICQSAAAAi8AFgAAeJxjYGY6yziBgZWBgWkm0xkGBoZ+CM34msGYkZMBFTAKoAkwODAwvmRiPvD/AIMDMxCD1CDJKjAwAgBktQsXAHicY2GAAMZQCM0EwqshbAALxAEKeJxjYGBgZoBgGQZGBhCIAPIYwXwWBhsgzcXAwcAEhIwMCi+Z/v/9/x+sSuElA4T9/4k4K1gHFwMMMILMY2QDYmaoABOQYGJABUA7WBiGNwAAJd4NIQAAAAAAAAAACAAIABAAGAAmAEAATgAAeJyNjLENgDAMBP9tIURJwQCMQccSZgk2i5fIYBDAidJjycXr7x5EPwE2wY8si7jmyBNXGo/bNBerxJNrpxhbO3/fEFpx8ZICpV+ghxJ74fAMe+h7Ox14AbrsHB14nK2QQWrDMBRER4mTkhQK3ZRQKOgCNk7oGQqhhEIX2WSlWEI1BAlkJ5CDdNsj5Ey9Rncdi38ES+jzNJo/HwTgATcoDEthhY3wBHc4CE+pfwsX5F/hGe7Vo/AcK/UhvMSz+mGXKhZU6pww8ISz3oWn1BvhgnwTnuEJf8Jz1OpFeIlX9YULDLdFi4ASHolkSR0iuYdjLak1vAequBhj21D61Nqyi6l3qWybGPjySbPHGScGJl6dP58MYcQRI0bts7mjebBqrFENH7t3qWtj0OuqHnXcW7b0HOTZFnKryRGW2hFX1m0O2vEM3opNMfTau+CS6Z3Vx6veNnEXY6jwDxhsc2gAAHicY2BiwA84GBgYmRiYGJkZmBlZGFkZ2djScyoLMgzZS/MyDQwMwLSrpYEBlIbxjQDrzgsuAAAAAAEAAf//AA94nGNgZGBg4AFiMSBmYmAEQnYgZgHzGAAD6wA2eJxjYGBgZACCKyoz1cD0o087YTQATOcIewAAAA==) format('woff');\n      font-weight: normal;\n      font-style: normal;\n    }\n  </style>\n`;\n\ndocument.head.appendChild($_documentContainer.content);\n\n/**\n * `<vaadin-grid-sorter>` is a helper element for the `<vaadin-grid>` that provides out-of-the-box UI controls,\n * visual feedback, and handlers for sorting the grid data.\n *\n * #### Example:\n * ```html\n * <vaadin-grid-column id=\"column\"></vaadin-grid-column>\n * ```\n * ```js\n * const column = document.querySelector('#column');\n * column.renderer = (root, column, model) => {\n *   let sorter = root.firstElementChild;\n *   if (!sorter) {\n *     sorter = document.createElement('vaadin-grid-sorter');\n *     root.appendChild(sorter);\n *   }\n *   sorter.path = 'name.first';\n * };\n * ```\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name | Description\n * ----------------|----------------\n * `content` | The slotted content wrapper\n * `indicators` | The internal sorter indicators.\n * `order` | The internal sorter order\n *\n * The following state attributes are available for styling:\n *\n * Attribute    | Description | Part name\n * -------------|-------------|------------\n * `direction` | Sort direction of a sorter | :host\n *\n * @fires {CustomEvent} direction-changed - Fired when the `direction` property changes.\n * @fires {CustomEvent} sorter-changed - Fired when the `path` or `direction` property changes.\n *\n * @extends HTMLElement\n */\nclass GridSorterElement extends ThemableMixin(DirMixin(PolymerElement)) {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          display: inline-flex;\n          cursor: pointer;\n          max-width: 100%;\n        }\n\n        [part='content'] {\n          flex: 1 1 auto;\n        }\n\n        [part='indicators'] {\n          position: relative;\n          align-self: center;\n          flex: none;\n        }\n\n        [part='order'] {\n          display: inline;\n          vertical-align: super;\n        }\n\n        [part='indicators']::before {\n          font-family: 'vaadin-grid-sorter-icons';\n          display: inline-block;\n        }\n\n        :host(:not([direction])) [part='indicators']::before {\n          content: '\\\\e901';\n        }\n\n        :host([direction='asc']) [part='indicators']::before {\n          content: '\\\\e900';\n        }\n\n        :host([direction='desc']) [part='indicators']::before {\n          content: '\\\\e902';\n        }\n      </style>\n\n      <div part=\"content\">\n        <slot></slot>\n      </div>\n      <div part=\"indicators\">\n        <span part=\"order\">[[_getDisplayOrder(_order)]]</span>\n      </div>\n    `;\n  }\n\n  static get is() {\n    return 'vaadin-grid-sorter';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * JS Path of the property in the item used for sorting the data.\n       */\n      path: String,\n\n      /**\n       * How to sort the data.\n       * Possible values are `asc` to use an ascending algorithm, `desc` to sort the data in\n       * descending direction, or `null` for not sorting the data.\n       * @type {GridSorterDirection | undefined}\n       */\n      direction: {\n        type: String,\n        reflectToAttribute: true,\n        notify: true,\n        value: null\n      },\n\n      /**\n       * @type {number | null}\n       * @protected\n       */\n      _order: {\n        type: Number,\n        value: null\n      },\n\n      /** @private */\n      _isConnected: {\n        type: Boolean,\n        observer: '__isConnectedChanged'\n      }\n    };\n  }\n\n  static get observers() {\n    return ['_pathOrDirectionChanged(path, direction)'];\n  }\n\n  /** @protected */\n  ready() {\n    super.ready();\n    this.addEventListener('click', this._onClick.bind(this));\n  }\n\n  /** @protected */\n  connectedCallback() {\n    super.connectedCallback();\n    this._isConnected = true;\n  }\n\n  /** @protected */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this._isConnected = false;\n  }\n\n  /** @private */\n  _pathOrDirectionChanged() {\n    this.__dispatchSorterChangedEvenIfPossible();\n  }\n\n  /** @private */\n  __isConnectedChanged(newValue, oldValue) {\n    if (oldValue === false) {\n      return;\n    }\n\n    this.__dispatchSorterChangedEvenIfPossible();\n  }\n\n  /** @private */\n  __dispatchSorterChangedEvenIfPossible() {\n    if (this.path === undefined || this.direction === undefined || !this._isConnected) {\n      return;\n    }\n\n    this.dispatchEvent(new CustomEvent('sorter-changed', { bubbles: true, composed: true }));\n  }\n\n  /** @private */\n  _getDisplayOrder(order) {\n    return order === null ? '' : order + 1;\n  }\n\n  /** @private */\n  _onClick(e) {\n    const activeElement = this.getRootNode().activeElement;\n    if (this !== activeElement && this.contains(activeElement)) {\n      // Some focusable content inside the sorter was clicked, do nothing.\n      return;\n    }\n\n    e.preventDefault();\n    if (this.direction === 'asc') {\n      this.direction = 'desc';\n    } else if (this.direction === 'desc') {\n      this.direction = null;\n    } else {\n      this.direction = 'asc';\n    }\n  }\n}\n\ncustomElements.define(GridSorterElement.is, GridSorterElement);\n\nexport { GridSorterElement };\n","import { registerStyles, css } from '@vaadin/vaadin-themable-mixin/register-styles.js';\nimport '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/font-icons.js';\nimport '@vaadin/vaadin-lumo-styles/sizing.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\nimport '@vaadin/vaadin-checkbox/theme/lumo/vaadin-checkbox.js';\n\nregisterStyles(\n  'vaadin-grid',\n  css`\n    :host {\n      font-family: var(--lumo-font-family);\n      font-size: var(--lumo-font-size-m);\n      line-height: var(--lumo-line-height-s);\n      color: var(--lumo-body-text-color);\n      background-color: var(--lumo-base-color);\n      box-sizing: border-box;\n      -webkit-text-size-adjust: 100%;\n      -webkit-tap-highlight-color: transparent;\n      -webkit-font-smoothing: antialiased;\n      -moz-osx-font-smoothing: grayscale;\n\n      /* For internal use only */\n      --_lumo-grid-border-color: var(--lumo-contrast-20pct);\n      --_lumo-grid-secondary-border-color: var(--lumo-contrast-10pct);\n      --_lumo-grid-border-width: 1px;\n      --_lumo-grid-selected-row-color: var(--lumo-primary-color-10pct);\n    }\n\n    /* No (outer) border */\n\n    :host(:not([theme~='no-border'])) {\n      border: var(--_lumo-grid-border-width) solid var(--_lumo-grid-border-color);\n    }\n\n    /* Cell styles */\n\n    [part~='cell'] {\n      min-height: var(--lumo-size-m);\n      background-color: var(--lumo-base-color);\n    }\n\n    [part~='cell'] ::slotted(vaadin-grid-cell-content) {\n      cursor: default;\n      padding: var(--lumo-space-xs) var(--lumo-space-m);\n    }\n\n    /* Apply row borders by default and introduce the \"no-row-borders\" variant */\n    :host(:not([theme~='no-row-borders'])) [part~='cell']:not([part~='details-cell']) {\n      border-top: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);\n    }\n\n    /* Hide first body row top border */\n    :host(:not([theme~='no-row-borders'])) [part='row'][first] [part~='cell']:not([part~='details-cell']) {\n      border-top: 0;\n      min-height: calc(var(--lumo-size-m) - var(--_lumo-grid-border-width));\n    }\n\n    /* Focus-ring */\n\n    [part~='cell']:focus {\n      outline: none;\n    }\n\n    :host([navigating]) [part~='cell']:focus::before {\n      content: '';\n      position: absolute;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      left: 0;\n      pointer-events: none;\n      box-shadow: inset 0 0 0 2px var(--lumo-primary-color-50pct);\n    }\n\n    /* Drag and Drop styles */\n    :host([dragover])::after {\n      content: '';\n      position: absolute;\n      z-index: 100;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      left: 0;\n      pointer-events: none;\n      box-shadow: inset 0 0 0 2px var(--lumo-primary-color-50pct);\n    }\n\n    [part~='row'][dragover] {\n      z-index: 100 !important;\n    }\n\n    [part~='row'][dragover] [part~='cell'] {\n      overflow: visible;\n    }\n\n    [part~='row'][dragover] [part~='cell']::after {\n      content: '';\n      position: absolute;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      left: 0;\n      height: calc(var(--_lumo-grid-border-width) + 2px);\n      pointer-events: none;\n      background: var(--lumo-primary-color-50pct);\n    }\n\n    :host([theme~='no-row-borders']) [dragover] [part~='cell']::after {\n      height: 2px;\n    }\n\n    [part~='row'][dragover='below'] [part~='cell']::after {\n      top: 100%;\n      bottom: auto;\n      margin-top: -1px;\n    }\n\n    [part~='row'][dragover='above'] [part~='cell']::after {\n      top: auto;\n      bottom: 100%;\n      margin-bottom: -1px;\n    }\n\n    [part~='row'][details-opened][dragover='below'] [part~='cell']:not([part~='details-cell'])::after,\n    [part~='row'][details-opened][dragover='above'] [part~='details-cell']::after {\n      display: none;\n    }\n\n    [part~='row'][dragover][dragover='on-top'] [part~='cell']::after {\n      height: 100%;\n    }\n\n    [part~='row'][dragstart] {\n      /* Add bottom-space to the row so the drag number doesn't get clipped. Needed for IE/Edge */\n      border-bottom: 100px solid transparent;\n      z-index: 100 !important;\n      opacity: 0.9;\n    }\n\n    [part~='row'][dragstart] [part~='cell'] {\n      border: none !important;\n      box-shadow: none !important;\n    }\n\n    [part~='row'][dragstart] [part~='cell'][last-column] {\n      border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;\n    }\n\n    [part~='row'][dragstart] [part~='cell'][first-column] {\n      border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);\n    }\n\n    [ios] [part~='row'][dragstart] [part~='cell'] {\n      background: var(--lumo-primary-color-50pct);\n    }\n\n    #scroller:not([ios]) [part~='row'][dragstart]:not([dragstart=''])::after {\n      display: block;\n      position: absolute;\n      left: var(--_grid-drag-start-x);\n      top: var(--_grid-drag-start-y);\n      z-index: 100;\n      content: attr(dragstart);\n      align-items: center;\n      justify-content: center;\n      box-sizing: border-box;\n      padding: calc(var(--lumo-space-xs) * 0.8);\n      color: var(--lumo-error-contrast-color);\n      background-color: var(--lumo-error-color);\n      border-radius: var(--lumo-border-radius-m);\n      font-family: var(--lumo-font-family);\n      font-size: var(--lumo-font-size-xxs);\n      line-height: 1;\n      font-weight: 500;\n      text-transform: initial;\n      letter-spacing: initial;\n      min-width: calc(var(--lumo-size-s) * 0.7);\n      text-align: center;\n    }\n\n    /* Headers and footers */\n\n    [part~='header-cell'] ::slotted(vaadin-grid-cell-content),\n    [part~='footer-cell'] ::slotted(vaadin-grid-cell-content),\n    [part~='reorder-ghost'] {\n      font-size: var(--lumo-font-size-s);\n      font-weight: 500;\n    }\n\n    [part~='footer-cell'] ::slotted(vaadin-grid-cell-content) {\n      font-weight: 400;\n    }\n\n    [part='row']:only-child [part~='header-cell'] {\n      min-height: var(--lumo-size-xl);\n    }\n\n    /* Header borders */\n\n    /* Hide first header row top border */\n    :host(:not([theme~='no-row-borders'])) [part='row']:first-child [part~='header-cell'] {\n      border-top: 0;\n    }\n\n    [part='row']:last-child [part~='header-cell'] {\n      border-bottom: var(--_lumo-grid-border-width) solid transparent;\n    }\n\n    :host(:not([theme~='no-row-borders'])) [part='row']:last-child [part~='header-cell'] {\n      border-bottom-color: var(--_lumo-grid-secondary-border-color);\n    }\n\n    /* Overflow uses a stronger border color */\n    :host([overflow~='top']) [part='row']:last-child [part~='header-cell'] {\n      border-bottom-color: var(--_lumo-grid-border-color);\n    }\n\n    /* Footer borders */\n\n    [part='row']:first-child [part~='footer-cell'] {\n      border-top: var(--_lumo-grid-border-width) solid transparent;\n    }\n\n    :host(:not([theme~='no-row-borders'])) [part='row']:first-child [part~='footer-cell'] {\n      border-top-color: var(--_lumo-grid-secondary-border-color);\n    }\n\n    /* Overflow uses a stronger border color */\n    :host([overflow~='bottom']) [part='row']:first-child [part~='footer-cell'] {\n      border-top-color: var(--_lumo-grid-border-color);\n    }\n\n    /* Column reordering */\n\n    :host([reordering]) [part~='cell'] {\n      background: linear-gradient(var(--lumo-shade-20pct), var(--lumo-shade-20pct)) var(--lumo-base-color);\n    }\n\n    :host([reordering]) [part~='cell'][reorder-status='allowed'] {\n      background: var(--lumo-base-color);\n    }\n\n    :host([reordering]) [part~='cell'][reorder-status='dragging'] {\n      background: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct)) var(--lumo-base-color);\n    }\n\n    [part~='reorder-ghost'] {\n      opacity: 0.85;\n      box-shadow: var(--lumo-box-shadow-s);\n      /* TODO Use the same styles as for the cell element (reorder-ghost copies styles from the cell element) */\n      padding: var(--lumo-space-s) var(--lumo-space-m) !important;\n    }\n\n    /* Column resizing */\n\n    [part='resize-handle'] {\n      width: 3px;\n      background-color: var(--lumo-primary-color-50pct);\n      opacity: 0;\n      transition: opacity 0.2s;\n    }\n\n    :host(:not([reordering])) *:not([column-resizing]) [part~='cell']:hover [part='resize-handle'],\n    [part='resize-handle']:active {\n      opacity: 1;\n      transition-delay: 0.15s;\n    }\n\n    /* Column borders */\n\n    :host([theme~='column-borders']) [part~='cell']:not([last-column]):not([part~='details-cell']) {\n      border-right: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);\n    }\n\n    /* Frozen columns */\n\n    [last-frozen] {\n      border-right: var(--_lumo-grid-border-width) solid transparent;\n      overflow: hidden;\n    }\n\n    :host([overflow~='left']) [part~='cell'][last-frozen]:not([part~='details-cell']) {\n      border-right-color: var(--_lumo-grid-border-color);\n    }\n\n    /* Row stripes */\n\n    :host([theme~='row-stripes']) [part~='row']:not([odd]) [part~='body-cell'],\n    :host([theme~='row-stripes']) [part~='row']:not([odd]) [part~='details-cell'] {\n      background-image: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));\n      background-repeat: repeat-x;\n    }\n\n    /* Selected row */\n\n    /* Raise the selected rows above unselected rows (so that box-shadow can cover unselected rows) */\n    :host(:not([reordering])) [part~='row'][selected] {\n      z-index: 1;\n    }\n\n    :host(:not([reordering])) [part~='row'][selected] [part~='body-cell']:not([part~='details-cell']) {\n      background-image: linear-gradient(var(--_lumo-grid-selected-row-color), var(--_lumo-grid-selected-row-color));\n      background-repeat: repeat;\n    }\n\n    /* Cover the border of an unselected row */\n    :host(:not([theme~='no-row-borders'])) [part~='row'][selected] [part~='cell']:not([part~='details-cell']) {\n      box-shadow: 0 var(--_lumo-grid-border-width) 0 0 var(--_lumo-grid-selected-row-color);\n    }\n\n    /* Compact */\n\n    :host([theme~='compact']) [part='row']:only-child [part~='header-cell'] {\n      min-height: var(--lumo-size-m);\n    }\n\n    :host([theme~='compact']) [part~='cell'] {\n      min-height: var(--lumo-size-s);\n    }\n\n    :host([theme~='compact']) [part='row'][first] [part~='cell']:not([part~='details-cell']) {\n      min-height: calc(var(--lumo-size-s) - var(--_lumo-grid-border-width));\n    }\n\n    :host([theme~='compact']) [part~='cell'] ::slotted(vaadin-grid-cell-content) {\n      padding: var(--lumo-space-xs) var(--lumo-space-s);\n    }\n\n    /* Wrap cell contents */\n\n    :host([theme~='wrap-cell-content']) [part~='cell'] ::slotted(vaadin-grid-cell-content) {\n      white-space: normal;\n    }\n\n    /* RTL specific styles */\n\n    :host([dir='rtl']) [part~='row'][dragstart] [part~='cell'][last-column] {\n      border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);\n    }\n\n    :host([dir='rtl']) [part~='row'][dragstart] [part~='cell'][first-column] {\n      border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;\n    }\n\n    :host([dir='rtl'][theme~='column-borders']) [part~='cell']:not([last-column]):not([part~='details-cell']) {\n      border-right: none;\n      border-left: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);\n    }\n\n    :host([dir='rtl']) [last-frozen] {\n      border-right: none;\n      border-left: var(--_lumo-grid-border-width) solid transparent;\n    }\n\n    :host([dir='rtl'][overflow~='right']) [part~='cell'][last-frozen]:not([part~='details-cell']) {\n      border-left-color: var(--_lumo-grid-border-color);\n    }\n  `,\n  { moduleId: 'lumo-grid' }\n);\n\nregisterStyles(\n  'vaadin-checkbox',\n  css`\n    :host(.vaadin-grid-select-all-checkbox) {\n      font-size: var(--lumo-font-size-m);\n    }\n  `,\n  { moduleId: 'vaadin-grid-select-all-checkbox-lumo' }\n);\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { registerStyles, css } from '@vaadin/vaadin-themable-mixin/register-styles.js';\n\nregisterStyles(\n  'vaadin-grid',\n  css`\n    @keyframes vaadin-grid-appear {\n      to {\n        opacity: 1;\n      }\n    }\n\n    :host {\n      display: block;\n      animation: 1ms vaadin-grid-appear;\n      height: 400px;\n      flex: 1 1 auto;\n      align-self: stretch;\n      position: relative;\n    }\n\n    :host([hidden]) {\n      display: none !important;\n    }\n\n    #scroller {\n      display: block;\n      transform: translateY(0);\n      width: auto;\n      height: auto;\n      position: absolute;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      left: 0;\n    }\n\n    :host([all-rows-visible]) {\n      height: auto;\n      align-self: flex-start;\n      flex-grow: 0;\n      width: 100%;\n    }\n\n    :host([all-rows-visible]) #scroller {\n      width: 100%;\n      height: 100%;\n      position: relative;\n    }\n\n    :host([all-rows-visible]) #items {\n      min-height: 1px;\n    }\n\n    #table {\n      display: flex;\n      flex-direction: column;\n      width: 100%;\n      height: 100%;\n      overflow: auto;\n      position: relative;\n      outline: none;\n      /* Workaround for a Desktop Safari bug: new stacking context here prevents the scrollbar from getting hidden */\n      z-index: 0;\n    }\n\n    #header,\n    #footer {\n      display: block;\n      position: -webkit-sticky;\n      position: sticky;\n      left: 0;\n      overflow: visible;\n      width: 100%;\n      z-index: 1;\n    }\n\n    #header {\n      top: 0;\n    }\n\n    th {\n      text-align: inherit;\n    }\n\n    /* Safari doesn't work with \"inherit\" */\n    [safari] th {\n      text-align: initial;\n    }\n\n    #footer {\n      bottom: 0;\n    }\n\n    #items {\n      flex-grow: 1;\n      flex-shrink: 0;\n      display: block;\n      position: -webkit-sticky;\n      position: sticky;\n      width: 100%;\n      left: 0;\n      overflow: visible;\n    }\n\n    [part~='row'] {\n      display: flex;\n      width: 100%;\n      box-sizing: border-box;\n      margin: 0;\n    }\n\n    [part~='row'][loading] [part~='body-cell'] ::slotted(vaadin-grid-cell-content) {\n      opacity: 0;\n    }\n\n    #items [part~='row'] {\n      position: absolute;\n    }\n\n    #items [part~='row']:empty {\n      height: 100%;\n    }\n\n    [part~='cell']:not([part~='details-cell']) {\n      flex-shrink: 0;\n      flex-grow: 1;\n      box-sizing: border-box;\n      display: flex;\n      width: 100%;\n      position: relative;\n      align-items: center;\n      padding: 0;\n      white-space: nowrap;\n    }\n\n    [part~='details-cell'] {\n      position: absolute;\n      bottom: 0;\n      width: 100%;\n      box-sizing: border-box;\n      padding: 0;\n    }\n\n    [part~='cell'] ::slotted(vaadin-grid-cell-content) {\n      display: block;\n      width: 100%;\n      box-sizing: border-box;\n      overflow: hidden;\n      text-overflow: ellipsis;\n    }\n\n    [hidden] {\n      display: none !important;\n    }\n\n    [frozen] {\n      z-index: 2;\n      will-change: transform;\n    }\n\n    [no-scrollbars][safari] #table,\n    [no-scrollbars][firefox] #table {\n      overflow: hidden;\n    }\n\n    /* Reordering styles */\n    :host([reordering]) [part~='cell'] ::slotted(vaadin-grid-cell-content),\n    :host([reordering]) [part~='resize-handle'],\n    #scroller[no-content-pointer-events] [part~='cell'] ::slotted(vaadin-grid-cell-content) {\n      pointer-events: none;\n    }\n\n    [part~='reorder-ghost'] {\n      visibility: hidden;\n      position: fixed;\n      pointer-events: none;\n      opacity: 0.5;\n\n      /* Prevent overflowing the grid in Firefox */\n      top: 0;\n      left: 0;\n    }\n\n    :host([reordering]) {\n      -moz-user-select: none;\n      -webkit-user-select: none;\n      user-select: none;\n    }\n\n    /* Resizing styles */\n    [part~='resize-handle'] {\n      position: absolute;\n      top: 0;\n      right: 0;\n      height: 100%;\n      cursor: col-resize;\n      z-index: 1;\n    }\n\n    [part~='resize-handle']::before {\n      position: absolute;\n      content: '';\n      height: 100%;\n      width: 35px;\n      transform: translateX(-50%);\n    }\n\n    [last-column] [part~='resize-handle']::before,\n    [last-frozen] [part~='resize-handle']::before {\n      width: 18px;\n      transform: none;\n      right: 0;\n    }\n\n    #scroller[column-resizing] {\n      -ms-user-select: none;\n      -moz-user-select: none;\n      -webkit-user-select: none;\n      user-select: none;\n    }\n\n    /* Sizer styles */\n    #sizer {\n      display: flex;\n      position: absolute;\n      visibility: hidden;\n    }\n\n    #sizer [part~='details-cell'] {\n      display: none !important;\n    }\n\n    #sizer [part~='cell'][hidden] {\n      display: none !important;\n    }\n\n    #sizer [part~='cell'] {\n      display: block;\n      flex-shrink: 0;\n      line-height: 0;\n      height: 0 !important;\n      min-height: 0 !important;\n      max-height: 0 !important;\n      padding: 0 !important;\n      border: none !important;\n    }\n\n    #sizer [part~='cell']::before {\n      content: '-';\n    }\n\n    #sizer [part~='cell'] ::slotted(vaadin-grid-cell-content) {\n      display: none !important;\n    }\n\n    /* RTL specific styles */\n\n    :host([dir='rtl']) #items,\n    :host([dir='rtl']) #header,\n    :host([dir='rtl']) #footer {\n      left: auto;\n    }\n\n    :host([dir='rtl']) [part~='reorder-ghost'] {\n      left: auto;\n      right: 0;\n    }\n\n    :host([dir='rtl']) [part~='resize-handle'] {\n      left: 0;\n      right: auto;\n    }\n\n    :host([dir='rtl']) [part~='resize-handle']::before {\n      transform: translateX(50%);\n    }\n\n    :host([dir='rtl']) [last-column] [part~='resize-handle']::before,\n    :host([dir='rtl']) [last-frozen] [part~='resize-handle']::before {\n      left: 0;\n      right: auto;\n    }\n  `,\n  { moduleId: 'vaadin-grid-styles' }\n);\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { beforeNextRender } from '@polymer/polymer/lib/utils/render-status.js';\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { animationFrame } from '@polymer/polymer/lib/utils/async.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { processTemplates } from '@vaadin/vaadin-element-mixin/templates.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { PolymerElement, html } from '@polymer/polymer/polymer-element.js';\nimport { A11yMixin } from './vaadin-grid-a11y-mixin.js';\nimport { ActiveItemMixin } from './vaadin-grid-active-item-mixin.js';\nimport { ArrayDataProviderMixin } from './vaadin-grid-array-data-provider-mixin.js';\nimport { ColumnResizingMixin } from './vaadin-grid-column-resizing-mixin.js';\nimport { DataProviderMixin } from './vaadin-grid-data-provider-mixin.js';\nimport { DynamicColumnsMixin } from './vaadin-grid-dynamic-columns-mixin.js';\nimport { EventContextMixin } from './vaadin-grid-event-context-mixin.js';\nimport { FilterMixin } from './vaadin-grid-filter-mixin.js';\nimport { RowDetailsMixin } from './vaadin-grid-row-details-mixin.js';\nimport { ScrollMixin } from './vaadin-grid-scroll-mixin.js';\nimport { SelectionMixin } from './vaadin-grid-selection-mixin.js';\nimport { SortMixin } from './vaadin-grid-sort-mixin.js';\nimport { StylingMixin } from './vaadin-grid-styling-mixin.js';\nimport { DragAndDropMixin } from './vaadin-grid-drag-and-drop-mixin.js';\nimport { KeyboardNavigationMixin } from './vaadin-grid-keyboard-navigation-mixin.js';\nimport { ColumnReorderingMixin } from './vaadin-grid-column-reordering-mixin.js';\nimport { Virtualizer } from '@vaadin/vaadin-virtual-list/src/virtualizer.js';\nimport './vaadin-grid-column.js';\nimport './vaadin-grid-styles.js';\n\nconst TOUCH_DEVICE = (() => {\n  try {\n    document.createEvent('TouchEvent');\n    return true;\n  } catch (e) {\n    return false;\n  }\n})();\n\n/**\n * `<vaadin-grid>` is a free, high quality data grid / data table Web Component. The content of the\n * the grid can be populated by using renderer callback function.\n *\n * ### Quick Start\n *\n * Start with an assigning an array to the [`items`](#/elements/vaadin-grid#property-items) property to visualize your data.\n *\n * Use the [`<vaadin-grid-column>`](#/elements/vaadin-grid-column) element to configure the grid columns. Set `path` and `header`\n * shorthand properties for the columns to define what gets rendered in the cells of the column.\n *\n * #### Example:\n * ```html\n * <vaadin-grid>\n *   <vaadin-grid-column path=\"name.first\" header=\"First name\"></vaadin-grid-column>\n *   <vaadin-grid-column path=\"name.last\" header=\"Last name\"></vaadin-grid-column>\n *   <vaadin-grid-column path=\"email\"></vaadin-grid-column>\n * </vaadin-grid>\n * ```\n *\n * For custom content `vaadin-grid-column` element provides you with three types of `renderer` callback functions: `headerRenderer`,\n * `renderer` and `footerRenderer`.\n *\n * Each of those renderer functions provides `root`, `column`, `model` arguments when applicable.\n * Generate DOM content, append it to the `root` element and control the state\n * of the host element by accessing `column`. Before generating new content,\n * users are able to check if there is already content in `root` for reusing it.\n *\n * Renderers are called on initialization of new column cells and each time the\n * related row model is updated. DOM generated during the renderer call can be reused\n * in the next renderer call and will be provided with the `root` argument.\n * On first call it will be empty.\n *\n * #### Example:\n * ```html\n * <vaadin-grid>\n *   <vaadin-grid-column></vaadin-grid-column>\n *   <vaadin-grid-column></vaadin-grid-column>\n *   <vaadin-grid-column></vaadin-grid-column>\n * </vaadin-grid>\n * ```\n * ```js\n * const grid = document.querySelector('vaadin-grid');\n * grid.items = [{'name': 'John', 'surname': 'Lennon', 'role': 'singer'},\n *               {'name': 'Ringo', 'surname': 'Starr', 'role': 'drums'}];\n *\n * const columns = grid.querySelectorAll('vaadin-grid-column');\n *\n * columns[0].headerRenderer = function(root) {\n *   root.textContent = 'Name';\n * };\n * columns[0].renderer = function(root, column, model) {\n *   root.textContent = model.item.name;\n * };\n *\n * columns[1].headerRenderer = function(root) {\n *   root.textContent = 'Surname';\n * };\n * columns[1].renderer = function(root, column, model) {\n *   root.textContent = model.item.surname;\n * };\n *\n * columns[2].headerRenderer = function(root) {\n *   root.textContent = 'Role';\n * };\n * columns[2].renderer = function(root, column, model) {\n *   root.textContent = model.item.role;\n * };\n * ```\n *\n * The following properties are available in the `model` argument:\n *\n * Property name | Type | Description\n * --------------|------|------------\n * `index`| Number | The index of the item.\n * `item` | String or Object | The item.\n * `level` | Number | Number of the item's tree sublevel, starts from 0.\n * `expanded` | Boolean | True if the item's tree sublevel is expanded.\n * `selected` | Boolean | True if the item is selected.\n * `detailsOpened` | Boolean | True if the item's row details are open.\n *\n * The following helper elements can be used for further customization:\n * - [`<vaadin-grid-column-group>`](#/elements/vaadin-grid-column-group)\n * - [`<vaadin-grid-filter>`](#/elements/vaadin-grid-filter)\n * - [`<vaadin-grid-sorter>`](#/elements/vaadin-grid-sorter)\n * - [`<vaadin-grid-selection-column>`](#/elements/vaadin-grid-selection-column)\n * - [`<vaadin-grid-tree-toggle>`](#/elements/vaadin-grid-tree-toggle)\n *\n * __Note that the helper elements must be explicitly imported.__\n * If you want to import everything at once you can use the `all-imports.html` bundle.\n *\n * ### Lazy Loading with Function Data Provider\n *\n * In addition to assigning an array to the items property, you can alternatively\n * provide the `<vaadin-grid>` data through the\n * [`dataProvider`](#/elements/vaadin-grid#property-dataProvider) function property.\n * The `<vaadin-grid>` calls this function lazily, only when it needs more data\n * to be displayed.\n *\n * See the [`dataProvider`](#/elements/vaadin-grid#property-dataProvider) in\n * the API reference below for the detailed data provider arguments description,\n * and the Assigning Data page in the demos.\n *\n * __Note that expanding the tree grid's item will trigger a call to the `dataProvider`.__\n *\n * __Also, note that when using function data providers, the total number of items\n * needs to be set manually. The total number of items can be returned\n * in the second argument of the data provider callback:__\n *\n * ```javascript\n * grid.dataProvider = function(params, callback) {\n *   const url = 'https://api.example/data' +\n *       '?page=' + params.page +        // the requested page index\n *       '&per_page=' + params.pageSize; // number of items on the page\n *   const xhr = new XMLHttpRequest();\n *   xhr.onload = function() {\n *     const response = JSON.parse(xhr.responseText);\n *     callback(\n *       response.employees, // requested page of items\n *       response.totalSize  // total number of items\n *     );\n *   };\n *   xhr.open('GET', url, true);\n *   xhr.send();\n * };\n * ```\n *\n * __Alternatively, you can use the `size` property to set the total number of items:__\n *\n * ```javascript\n * grid.size = 200; // The total number of items\n * grid.dataProvider = function(params, callback) {\n *   const url = 'https://api.example/data' +\n *       '?page=' + params.page +        // the requested page index\n *       '&per_page=' + params.pageSize; // number of items on the page\n *   const xhr = new XMLHttpRequest();\n *   xhr.onload = function() {\n *     const response = JSON.parse(xhr.responseText);\n *     callback(response.employees);\n *   };\n *   xhr.open('GET', url, true);\n *   xhr.send();\n * };\n * ```\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name | Description\n * ----------------|----------------\n * `row` | Row in the internal table\n * `cell` | Cell in the internal table\n * `header-cell` | Header cell in the internal table\n * `body-cell` | Body cell in the internal table\n * `footer-cell` | Footer cell in the internal table\n * `details-cell` | Row details cell in the internal table\n * `resize-handle` | Handle for resizing the columns\n * `reorder-ghost` | Ghost element of the header cell being dragged\n *\n * The following state attributes are available for styling:\n *\n * Attribute    | Description | Part name\n * -------------|-------------|------------\n * `loading` | Set when the grid is loading data from data provider | :host\n * `interacting` | Keyboard navigation in interaction mode | :host\n * `navigating` | Keyboard navigation in navigation mode | :host\n * `overflow` | Set when rows are overflowing the grid viewport. Possible values: `top`, `bottom`, `left`, `right` | :host\n * `reordering` | Set when the grid's columns are being reordered | :host\n * `dragover` | Set when the grid (not a specific row) is dragged over | :host\n * `dragging-rows` : Set when grid rows are dragged  | :host\n * `reorder-status` | Reflects the status of a cell while columns are being reordered | cell\n * `frozen` | Frozen cell | cell\n * `last-frozen` | Last frozen cell | cell\n * * `first-column` | First visible cell on a row | cell\n * `last-column` | Last visible cell on a row | cell\n * `selected` | Selected row | row\n * `expanded` | Expanded row | row\n * `details-opened` | Row with details open | row\n * `loading` | Row that is waiting for data from data provider | row\n * `odd` | Odd row | row\n * `first` | The first body row | row\n * `dragstart` | Set for one frame when drag of a row is starting. The value is a number when multiple rows are dragged | row\n * `dragover` | Set when the row is dragged over | row\n * `drag-disabled` | Set to a row that isn't available for dragging | row\n * `drop-disabled` | Set to a row that can't be dropped on top of | row\n *\n * See [Styling Components](https://vaadin.com/docs/latest/ds/customization/styling-components) documentation.\n *\n * @fires {CustomEvent} active-item-changed - Fired when the `activeItem` property changes.\n * @fires {CustomEvent} cell-activate - Fired when the cell is activated with click or keyboard.\n * @fires {CustomEvent} cell-focus - Fired when a cell is focused with click or keyboard navigation.\n * @fires {CustomEvent} column-reorder - Fired when the columns in the grid are reordered.\n * @fires {CustomEvent} column-resize - Fired when the grid column resize is finished.\n * @fires {CustomEvent} expanded-items-changed - Fired when the `expandedItems` property changes.\n * @fires {CustomEvent} grid-dragstart - Fired when starting to drag grid rows.\n * @fires {CustomEvent} grid-dragend - Fired when the dragging of the rows ends.\n * @fires {CustomEvent} grid-drop - Fired when a drop occurs on top of the grid.\n * @fires {CustomEvent} loading-changed - Fired when the `loading` property changes.\n * @fires {CustomEvent} selected-items-changed - Fired when the `selectedItems` property changes.\n *\n * @extends HTMLElement\n * @mixes ElementMixin\n * @mixes ThemableMixin\n * @mixes A11yMixin\n * @mixes ActiveItemMixin\n * @mixes ArrayDataProviderMixin\n * @mixes ColumnResizingMixin\n * @mixes DataProviderMixin\n * @mixes DynamicColumnsMixin\n * @mixes FilterMixin\n * @mixes RowDetailsMixin\n * @mixes ScrollMixin\n * @mixes SelectionMixin\n * @mixes SortMixin\n * @mixes KeyboardNavigationMixin\n * @mixes ColumnReorderingMixin\n * @mixes EventContextMixin\n * @mixes StylingMixin\n * @mixes DragAndDropMixin\n */\nclass GridElement extends ElementMixin(\n  ThemableMixin(\n    DataProviderMixin(\n      ArrayDataProviderMixin(\n        DynamicColumnsMixin(\n          ActiveItemMixin(\n            ScrollMixin(\n              SelectionMixin(\n                SortMixin(\n                  RowDetailsMixin(\n                    KeyboardNavigationMixin(\n                      A11yMixin(\n                        FilterMixin(\n                          ColumnReorderingMixin(\n                            ColumnResizingMixin(EventContextMixin(DragAndDropMixin(StylingMixin(PolymerElement))))\n                          )\n                        )\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n) {\n  static get template() {\n    return html`\n      <div\n        id=\"scroller\"\n        safari$=\"[[_safari]]\"\n        ios$=\"[[_ios]]\"\n        loading$=\"[[loading]]\"\n        column-reordering-allowed$=\"[[columnReorderingAllowed]]\"\n      >\n        <table id=\"table\" role=\"grid\" aria-multiselectable=\"true\" tabindex=\"0\">\n          <caption id=\"sizer\" part=\"row\"></caption>\n          <thead id=\"header\" role=\"rowgroup\"></thead>\n          <tbody id=\"items\" role=\"rowgroup\"></tbody>\n          <tfoot id=\"footer\" role=\"rowgroup\"></tfoot>\n        </table>\n\n        <div part=\"reorder-ghost\"></div>\n      </div>\n\n      <div id=\"focusexit\" tabindex=\"0\"></div>\n    `;\n  }\n\n  static get is() {\n    return 'vaadin-grid';\n  }\n\n  static get version() {\n    return '21.0.5';\n  }\n\n  static get observers() {\n    return [\n      '_columnTreeChanged(_columnTree, _columnTree.*)',\n      '_effectiveSizeChanged(_effectiveSize, __virtualizer, _hasData, _columnTree)'\n    ];\n  }\n\n  static get properties() {\n    return {\n      /** @private */\n      _safari: {\n        type: Boolean,\n        value: /^((?!chrome|android).)*safari/i.test(navigator.userAgent)\n      },\n\n      /** @private */\n      _ios: {\n        type: Boolean,\n        value:\n          (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream) ||\n          (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)\n      },\n\n      /** @private */\n      _firefox: {\n        type: Boolean,\n        value: navigator.userAgent.toLowerCase().indexOf('firefox') > -1\n      },\n\n      /** @private */\n      _android: {\n        type: Boolean,\n        value: /android/i.test(navigator.userAgent)\n      },\n\n      /** @private */\n      _touchDevice: {\n        type: Boolean,\n        value: TOUCH_DEVICE\n      },\n\n      /**\n       * If true, the grid's height is defined by its rows.\n       *\n       * Effectively, this disables the grid's virtual scrolling so that all the rows are rendered in the DOM at once.\n       * If the grid has a large number of items, using the feature is discouraged to avoid performance issues.\n       * @attr {boolean} all-rows-visible\n       * @type {boolean}\n       */\n      allRowsVisible: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true,\n        observer: '_allRowsVisibleChanged'\n      },\n\n      /** @private */\n      _recalculateColumnWidthOnceLoadingFinished: {\n        type: Boolean,\n        value: true\n      },\n\n      /** @private */\n      isAttached: {\n        value: false\n      },\n\n      /**\n       * An internal property that is mainly used by `vaadin-template-renderer`\n       * to identify grid elements.\n       *\n       * @private\n       */\n      __gridElement: {\n        type: Boolean,\n        value: true\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.addEventListener('animationend', this._onAnimationEnd);\n  }\n\n  /** @protected */\n  connectedCallback() {\n    super.connectedCallback();\n    this.isAttached = true;\n    this.recalculateColumnWidths();\n  }\n\n  /** @protected */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.isAttached = false;\n  }\n\n  /** @private */\n  __getFirstVisibleItem() {\n    return this._getVisibleRows().find((row) => this._isInViewport(row));\n  }\n\n  /** @private */\n  get _firstVisibleIndex() {\n    const firstVisibleItem = this.__getFirstVisibleItem();\n    return firstVisibleItem ? firstVisibleItem.index : undefined;\n  }\n\n  /** @private */\n  __getLastVisibleItem() {\n    return this._getVisibleRows()\n      .reverse()\n      .find((row) => this._isInViewport(row));\n  }\n\n  /** @private */\n  get _lastVisibleIndex() {\n    const lastVisibleItem = this.__getLastVisibleItem();\n    return lastVisibleItem ? lastVisibleItem.index : undefined;\n  }\n\n  /** @private */\n  _isInViewport(item) {\n    const scrollTargetRect = this.$.table.getBoundingClientRect();\n    const itemRect = item.getBoundingClientRect();\n    const headerHeight = this.$.header.getBoundingClientRect().height;\n    const footerHeight = this.$.footer.getBoundingClientRect().height;\n    return (\n      itemRect.bottom > scrollTargetRect.top + headerHeight && itemRect.top < scrollTargetRect.bottom - footerHeight\n    );\n  }\n\n  /** @private */\n  _getVisibleRows() {\n    return Array.from(this.$.items.children)\n      .filter((item) => !item.hidden)\n      .sort((a, b) => a.index - b.index);\n  }\n\n  /** @protected */\n  ready() {\n    super.ready();\n\n    this.__virtualizer = new Virtualizer({\n      createElements: this._createScrollerRows.bind(this),\n      updateElement: this._updateScrollerItem.bind(this),\n      scrollContainer: this.$.items,\n      scrollTarget: this.$.table,\n      reorderElements: true\n    });\n\n    new ResizeObserver(() => setTimeout(() => this.__updateFooterPositioning())).observe(this.$.footer);\n\n    processTemplates(this);\n  }\n\n  /**\n   * @param {string} name\n   * @param {?string} oldValue\n   * @param {?string} newValue\n   * @protected\n   */\n  attributeChangedCallback(name, oldValue, newValue) {\n    super.attributeChangedCallback(name, oldValue, newValue);\n    if (name === 'dir') {\n      this.__isRTL = newValue === 'rtl';\n      this._updateScrollerMeasurements();\n    }\n  }\n\n  /** @private */\n  __getBodyCellCoordinates(cell) {\n    if (this.$.items.contains(cell) && cell.localName === 'td') {\n      return {\n        item: cell.parentElement._item,\n        column: cell._column\n      };\n    }\n  }\n\n  /** @private */\n  __focusBodyCell({ item, column }) {\n    const row = this._getVisibleRows().find((row) => row._item === item);\n    const cell = row && [...row.children].find((cell) => cell._column === column);\n    cell && cell.focus();\n  }\n\n  /** @private */\n  _effectiveSizeChanged(effectiveSize, virtualizer, hasData, columnTree) {\n    if (virtualizer && hasData && columnTree) {\n      // Changing the virtualizer size may result in the row with focus getting hidden\n      const cell = this.shadowRoot.activeElement;\n      const cellCoordinates = this.__getBodyCellCoordinates(cell);\n\n      virtualizer.size = effectiveSize;\n      virtualizer.flush();\n\n      // If the focused cell's parent row got hidden by the size change, focus the corresponding new cell\n      cellCoordinates && cell.parentElement.hidden && this.__focusBodyCell(cellCoordinates);\n    }\n  }\n\n  /** @private */\n  __hasRowsWithClientHeight() {\n    return !!Array.from(this.$.items.children).filter((row) => row.clientHeight).length;\n  }\n\n  /** @protected */\n  __itemsReceived() {\n    if (\n      this._recalculateColumnWidthOnceLoadingFinished &&\n      !this._cache.isLoading() &&\n      this.__hasRowsWithClientHeight()\n    ) {\n      this._recalculateColumnWidthOnceLoadingFinished = false;\n      this.recalculateColumnWidths();\n    }\n  }\n\n  /** @private */\n  __getIntrinsicWidth(col) {\n    const initialWidth = col.width;\n    const initialFlexGrow = col.flexGrow;\n\n    col.width = 'auto';\n    col.flexGrow = 0;\n\n    // Note: _allCells only contains cells which are currently rendered in DOM\n    const width = col._allCells\n      .filter((cell) => {\n        // Exclude body cells that are out of the visible viewport\n        return !this.$.items.contains(cell) || this._isInViewport(cell.parentElement);\n      })\n      .reduce((width, cell) => {\n        // Add 1px buffer to the offset width to avoid too narrow columns (sub-pixel rendering)\n        return Math.max(width, cell.offsetWidth + 1);\n      }, 0);\n\n    col.flexGrow = initialFlexGrow;\n    col.width = initialWidth;\n\n    return width;\n  }\n\n  /** @private */\n  __getDistributedWidth(col, innerColumn) {\n    if (col == null || col === this) return 0;\n\n    const columnWidth = Math.max(this.__getIntrinsicWidth(col), this.__getDistributedWidth(col.parentElement, col));\n\n    // we're processing a regular grid-column and not a grid-column-group\n    if (!innerColumn) {\n      return columnWidth;\n    }\n\n    // At the end, the width of each vaadin-grid-column-group is determined by the sum of the width of its children.\n    // Here we determine how much space the vaadin-grid-column-group actually needs to render properly and then we distribute that space\n    // to its children, so when we actually do the summation it will be rendered properly.\n    // Check out vaadin-grid-column-group:_updateFlexAndWidth\n    const columnGroup = col;\n    const columnGroupWidth = columnWidth;\n    const sumOfWidthOfAllChildColumns = columnGroup._visibleChildColumns\n      .map((col) => this.__getIntrinsicWidth(col))\n      .reduce((sum, curr) => sum + curr, 0);\n\n    const extraNecessarySpaceForGridColumnGroup = Math.max(0, columnGroupWidth - sumOfWidthOfAllChildColumns);\n\n    // The distribution of the extra necessary space is done according to the intrinsic width of each child column.\n    // Lets say we need 100 pixels of extra space for the grid-column-group to render properly\n    // it has two grid-column children, |100px|300px| in total 400px\n    // the first column gets 25px of the additional space (100/400)*100 = 25\n    // the second column gets the 75px of the additional space (300/400)*100 = 75\n    const proportionOfExtraSpace = this.__getIntrinsicWidth(innerColumn) / sumOfWidthOfAllChildColumns;\n    const shareOfInnerColumnFromNecessaryExtraSpace = proportionOfExtraSpace * extraNecessarySpaceForGridColumnGroup;\n\n    return this.__getIntrinsicWidth(innerColumn) + shareOfInnerColumnFromNecessaryExtraSpace;\n  }\n\n  /**\n   * @param {!Array<!GridColumnElement>} cols the columns to auto size based on their content width\n   * @private\n   */\n  _recalculateColumnWidths(cols) {\n    cols.forEach((col) => {\n      col.width = `${this.__getDistributedWidth(col)}px`;\n    });\n  }\n\n  /**\n   * Updates the `width` of all columns which have `autoWidth` set to `true`.\n   */\n  recalculateColumnWidths() {\n    if (!this._columnTree) {\n      return; // No columns\n    }\n    if (this._cache.isLoading()) {\n      this._recalculateColumnWidthOnceLoadingFinished = true;\n    } else {\n      const cols = this._getColumns().filter((col) => !col.hidden && col.autoWidth);\n      this._recalculateColumnWidths(cols);\n    }\n  }\n\n  /** @private */\n  _createScrollerRows(count) {\n    const rows = [];\n    for (let i = 0; i < count; i++) {\n      const row = document.createElement('tr');\n      row.setAttribute('part', 'row');\n      row.setAttribute('role', 'row');\n      if (this._columnTree) {\n        this._updateRow(row, this._columnTree[this._columnTree.length - 1], 'body', false, true);\n      }\n      rows.push(row);\n    }\n\n    if (this._columnTree) {\n      this._columnTree[this._columnTree.length - 1].forEach(\n        (c) => c.isConnected && c.notifyPath && c.notifyPath('_cells.*', c._cells)\n      );\n    }\n\n    beforeNextRender(this, () => {\n      this._updateFirstAndLastColumn();\n      this._resetKeyboardNavigation();\n      this._afterScroll();\n      this.__itemsReceived();\n    });\n    return rows;\n  }\n\n  /** @private */\n  _createCell(tagName) {\n    const contentId = (this._contentIndex = this._contentIndex + 1 || 0);\n    const slotName = 'vaadin-grid-cell-content-' + contentId;\n\n    const cellContent = document.createElement('vaadin-grid-cell-content');\n    cellContent.setAttribute('slot', slotName);\n\n    const cell = document.createElement(tagName);\n    cell.id = slotName.replace('-content-', '-');\n    cell.setAttribute('tabindex', '-1');\n    cell.setAttribute('role', tagName === 'td' ? 'gridcell' : 'columnheader');\n\n    const slot = document.createElement('slot');\n    slot.setAttribute('name', slotName);\n\n    cell.appendChild(slot);\n\n    cell._content = cellContent;\n\n    // With native Shadow DOM, mousedown on slotted element does not focus\n    // focusable slot wrapper, that is why cells are not focused with\n    // mousedown. Workaround: listen for mousedown and focus manually.\n    cellContent.addEventListener('mousedown', () => {\n      if (window.chrome) {\n        // Chrome bug: focusing before mouseup prevents text selection, see http://crbug.com/771903\n        const mouseUpListener = () => {\n          if (!cellContent.contains(this.getRootNode().activeElement)) {\n            cell.focus();\n          }\n          // If focus is in the cell content  respect it, do not change.\n          document.removeEventListener('mouseup', mouseUpListener, true);\n        };\n        document.addEventListener('mouseup', mouseUpListener, true);\n      } else {\n        // Focus on mouseup, on the other hand, removes selection on Safari.\n        // Watch out sync focus removal issue, only async focus works here.\n        setTimeout(() => {\n          if (!cellContent.contains(this.getRootNode().activeElement)) {\n            cell.focus();\n          }\n        });\n      }\n    });\n\n    return cell;\n  }\n\n  /**\n   * @param {!HTMLTableRowElement} row\n   * @param {!Array<!GridColumnElement>} columns\n   * @param {?string} section\n   * @param {boolean} isColumnRow\n   * @param {boolean} noNotify\n   * @protected\n   */\n  _updateRow(row, columns, section, isColumnRow, noNotify) {\n    section = section || 'body';\n\n    const contentsFragment = document.createDocumentFragment();\n\n    Array.from(row.children).forEach((cell) => (cell._vacant = true));\n    row.innerHTML = '';\n\n    columns\n      .filter((column) => !column.hidden)\n      .forEach((column, index, cols) => {\n        let cell;\n\n        if (section === 'body') {\n          // Body\n          column._cells = column._cells || [];\n          cell = column._cells.filter((cell) => cell._vacant)[0];\n          if (!cell) {\n            cell = this._createCell('td');\n            column._cells.push(cell);\n          }\n          cell.setAttribute('part', 'cell body-cell');\n          row.appendChild(cell);\n\n          if (index === cols.length - 1 && this.rowDetailsRenderer) {\n            // Add details cell as last cell to body rows\n            this._detailsCells = this._detailsCells || [];\n            const detailsCell = this._detailsCells.filter((cell) => cell._vacant)[0] || this._createCell('td');\n            if (this._detailsCells.indexOf(detailsCell) === -1) {\n              this._detailsCells.push(detailsCell);\n            }\n            if (!detailsCell._content.parentElement) {\n              contentsFragment.appendChild(detailsCell._content);\n            }\n            this._configureDetailsCell(detailsCell);\n            row.appendChild(detailsCell);\n            this._a11ySetRowDetailsCell(row, detailsCell);\n            detailsCell._vacant = false;\n          }\n\n          if (column.notifyPath && !noNotify) {\n            column.notifyPath('_cells.*', column._cells);\n          }\n        } else {\n          // Header & footer\n          const tagName = section === 'header' ? 'th' : 'td';\n          if (isColumnRow || column.localName === 'vaadin-grid-column-group') {\n            cell = column[`_${section}Cell`] || this._createCell(tagName);\n            cell._column = column;\n            row.appendChild(cell);\n            column[`_${section}Cell`] = cell;\n          } else {\n            column._emptyCells = column._emptyCells || [];\n            cell = column._emptyCells.filter((cell) => cell._vacant)[0] || this._createCell(tagName);\n            cell._column = column;\n            row.appendChild(cell);\n            if (column._emptyCells.indexOf(cell) === -1) {\n              column._emptyCells.push(cell);\n            }\n          }\n          cell.setAttribute('part', `cell ${section}-cell`);\n          this.__updateHeaderFooterRowVisibility(row);\n        }\n\n        if (!cell._content.parentElement) {\n          contentsFragment.appendChild(cell._content);\n        }\n        cell._vacant = false;\n        cell._column = column;\n      });\n\n    // Might be empty if only cache was used\n    this.appendChild(contentsFragment);\n\n    this._frozenCellsChanged();\n    this._updateFirstAndLastColumnForRow(row);\n  }\n\n  /**\n   * @param {HTMLTableRowElement} row\n   * @protected\n   */\n  __updateHeaderFooterRowVisibility(row) {\n    if (!row) {\n      return;\n    }\n\n    const visibleRowCells = Array.from(row.children).filter((cell) => {\n      const column = cell._column;\n      if (column._emptyCells && column._emptyCells.indexOf(cell) > -1) {\n        // The cell is an \"empty cell\"  -> doesn't block hiding the row\n        return false;\n      }\n      if (row.parentElement === this.$.header) {\n        if (column.headerRenderer) {\n          // The cell is the header cell of a column that has a header renderer\n          // -> row should be visible\n          return true;\n        }\n        if (column.header === null) {\n          // The column header is explicilty set to null -> doesn't block hiding the row\n          return false;\n        }\n        if (column.path || column.header !== undefined) {\n          // The column has an explicit non-null header or a path that generates a header\n          // -> row should be visible\n          return true;\n        }\n      } else {\n        if (column.footerRenderer) {\n          // The cell is the footer cell of a column that has a footer renderer\n          // -> row should be visible\n          return true;\n        }\n      }\n    });\n\n    if (row.hidden !== !visibleRowCells.length) {\n      row.hidden = !visibleRowCells.length;\n      this.notifyResize();\n    }\n  }\n\n  /** @private */\n  _updateScrollerItem(row, index) {\n    this._preventScrollerRotatingCellFocus(row, index);\n\n    if (!this._columnTree) {\n      return;\n    }\n\n    this._toggleAttribute('first', index === 0, row);\n    this._toggleAttribute('odd', index % 2, row);\n    this._a11yUpdateRowRowindex(row, index);\n    this._getItem(index, row);\n  }\n\n  /** @private */\n  _columnTreeChanged(columnTree) {\n    this._renderColumnTree(columnTree);\n    this.recalculateColumnWidths();\n  }\n\n  /**\n   * @param {!Array<!GridColumnElement>} columnTree\n   * @protected\n   */\n  _renderColumnTree(columnTree) {\n    Array.from(this.$.items.children).forEach((row) =>\n      this._updateRow(row, columnTree[columnTree.length - 1], null, false, true)\n    );\n\n    while (this.$.header.children.length < columnTree.length) {\n      const headerRow = document.createElement('tr');\n      headerRow.setAttribute('part', 'row');\n      headerRow.setAttribute('role', 'row');\n      this.$.header.appendChild(headerRow);\n\n      const footerRow = document.createElement('tr');\n      footerRow.setAttribute('part', 'row');\n      footerRow.setAttribute('role', 'row');\n      this.$.footer.appendChild(footerRow);\n    }\n    while (this.$.header.children.length > columnTree.length) {\n      this.$.header.removeChild(this.$.header.firstElementChild);\n      this.$.footer.removeChild(this.$.footer.firstElementChild);\n    }\n\n    Array.from(this.$.header.children).forEach((headerRow, index) =>\n      this._updateRow(headerRow, columnTree[index], 'header', index === columnTree.length - 1)\n    );\n\n    Array.from(this.$.footer.children).forEach((footerRow, index) =>\n      this._updateRow(footerRow, columnTree[columnTree.length - 1 - index], 'footer', index === 0)\n    );\n\n    // Sizer rows\n    this._updateRow(this.$.sizer, columnTree[columnTree.length - 1]);\n\n    this._resizeHandler();\n    this._frozenCellsChanged();\n    this._updateFirstAndLastColumn();\n    this._resetKeyboardNavigation();\n    this._a11yUpdateHeaderRows();\n    this._a11yUpdateFooterRows();\n    this.__updateFooterPositioning();\n    this.generateCellClassNames();\n  }\n\n  __updateFooterPositioning() {\n    if (this._firefox) {\n      // Sticky (or translated) footer in a flexbox host doesn't get included in\n      // the scroll height calculation on FF. This is a workaround for the issue.\n      this.$.items.style.paddingBottom = 0;\n      if (!this.allRowsVisible) {\n        this.$.items.style.paddingBottom = `${this.$.footer.offsetHeight}px`;\n      }\n    }\n  }\n\n  /**\n   * @param {!HTMLElement} row\n   * @param {GridItem} item\n   * @protected\n   */\n  _updateItem(row, item) {\n    row._item = item;\n    const model = this.__getRowModel(row);\n\n    this._toggleDetailsCell(row, model.detailsOpened);\n\n    this._a11yUpdateRowLevel(row, model.level);\n    this._a11yUpdateRowSelected(row, model.selected);\n    this._a11yUpdateRowDetailsOpened(row, model.detailsOpened);\n\n    this._toggleAttribute('expanded', model.expanded, row);\n    this._toggleAttribute('selected', model.selected, row);\n    this._toggleAttribute('details-opened', model.detailsOpened, row);\n\n    this._generateCellClassNames(row, model);\n    this._filterDragAndDrop(row, model);\n\n    Array.from(row.children).forEach((cell) => {\n      if (cell._renderer) {\n        const owner = cell._column || this;\n        cell._renderer.call(owner, cell._content, owner, model);\n      }\n    });\n\n    this._updateDetailsCellHeight(row);\n  }\n\n  /** @private */\n  _resizeHandler() {\n    this._updateDetailsCellHeights();\n    this._updateScrollerMeasurements();\n    this.__updateFooterPositioning();\n  }\n\n  /** @private */\n  _onAnimationEnd(e) {\n    // ShadyCSS applies scoping suffixes to animation names\n    if (e.animationName.indexOf('vaadin-grid-appear') === 0) {\n      e.stopPropagation();\n      this.notifyResize();\n      this.__itemsReceived();\n\n      requestAnimationFrame(() => {\n        this.__scrollToPendingIndex();\n        // This needs to be set programmatically in order to avoid an iOS 10 bug (disappearing grid)\n        this.$.table.style.webkitOverflowScrolling = 'touch';\n      });\n    }\n  }\n\n  /**\n   * @param {string} name\n   * @param {boolean} bool\n   * @param {!Element} node\n   * @protected\n   */\n  _toggleAttribute(name, bool, node) {\n    if (node.hasAttribute(name) === !bool) {\n      if (bool) {\n        node.setAttribute(name, '');\n      } else {\n        node.removeAttribute(name);\n      }\n    }\n  }\n\n  /**\n   * @param {!HTMLTableRowElement} row\n   * @return {!GridItemModel}\n   * @protected\n   */\n  __getRowModel(row) {\n    return {\n      index: row.index,\n      item: row._item,\n      level: this._getIndexLevel(row.index),\n      expanded: this._isExpanded(row._item),\n      selected: this._isSelected(row._item),\n      detailsOpened: !!this.rowDetailsRenderer && this._isDetailsOpened(row._item)\n    };\n  }\n\n  /**\n   * Requests an update for the content of cells.\n   *\n   * While performing the update, the following renderers are invoked:\n   * - `GridElement.rowDetailsRenderer`\n   * - `GridColumnElement.renderer`\n   * - `GridColumnElement.headerRenderer`\n   * - `GridColumnElement.footerRenderer`\n   *\n   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.\n   */\n  requestContentUpdate() {\n    if (this._columnTree) {\n      // header and footer renderers\n      this._columnTree.forEach((level) => {\n        level.forEach((column) => {\n          column._renderHeaderAndFooter();\n        });\n      });\n\n      // body and row details renderers\n      this.__updateVisibleRows();\n    }\n  }\n\n  /**\n   * Manually invoke existing renderers for all the columns\n   * (header, footer and body cells) and opened row details.\n   *\n   * @deprecated Since Vaadin 21, `render()` is deprecated. Please use `requestContentUpdate()` instead.\n   */\n  render() {\n    console.warn('WARNING: Since Vaadin 21, render() is deprecated. Please use requestContentUpdate() instead.');\n\n    this.requestContentUpdate();\n  }\n\n  /** @protected */\n  __updateVisibleRows(start, end) {\n    this.__virtualizer && this.__virtualizer.update(start, end);\n  }\n\n  /**\n   * Updates the computed metrics and positioning of internal grid parts\n   * (row/details cell positioning etc). Needs to be invoked whenever the sizing of grid\n   * content changes asynchronously to ensure consistent appearance (e.g. when a\n   * contained image whose bounds aren't known beforehand finishes loading).\n   */\n  notifyResize() {\n    // To be removed in https://github.com/vaadin/web-components/issues/331\n  }\n\n  /** @private */\n  _allRowsVisibleChanged(value, oldValue) {\n    if (value || oldValue) {\n      this.notifyResize();\n    }\n  }\n\n  /** @protected */\n  __forceReflow() {\n    this._debouncerForceReflow = Debouncer.debounce(this._debouncerForceReflow, animationFrame, () => {\n      this.$.scroller.style.overflow = 'hidden';\n      setTimeout(() => (this.$.scroller.style.overflow = ''));\n    });\n  }\n}\n\ncustomElements.define(GridElement.is, GridElement);\n\nexport { GridElement };\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { PolymerElement, html } from '@polymer/polymer/polymer-element.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { DirMixin } from '@vaadin/vaadin-element-mixin/vaadin-dir-mixin.js';\nimport { ItemMixin } from './vaadin-item-mixin.js';\n\n/**\n * `<vaadin-item>` is a Web Component providing layout for items in tabs and menus.\n *\n * ```\n *   <vaadin-item>\n *     Item content\n *   </vaadin-item>\n * ```\n *\n * ### Selectable\n *\n * `<vaadin-item>` has the `selected` property and the corresponding state attribute.\n * Currently, the component sets the `selected` to false, when `disabled` property is set to true.\n * But other than that, the `<vaadin-item>` does not switch selection by itself.\n * In general, it is the wrapper component, like `<vaadin-list-box>`, which should update\n * the `selected` property on the items, e. g. on mousedown or when Enter / Spacebar is pressed.\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name | Description\n * ---|---\n * `content` | The element that wraps the slot\n *\n * The following state attributes are available for styling:\n *\n * Attribute  | Description | Part name\n * -----------|-------------|------------\n * `disabled` | Set to a disabled item | :host\n * `focused` | Set when the element is focused | :host\n * `focus-ring` | Set when the element is keyboard focused | :host\n * `selected` | Set when the item is selected | :host\n * `active` | Set when mousedown or enter/spacebar pressed | :host\n *\n * @extends HTMLElement\n * @mixes ItemMixin\n * @mixes ThemableMixin\n * @mixes DirMixin\n */\nclass ItemElement extends ItemMixin(ThemableMixin(DirMixin(PolymerElement))) {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          display: inline-block;\n        }\n\n        :host([hidden]) {\n          display: none !important;\n        }\n      </style>\n      <div part=\"content\">\n        <slot></slot>\n      </div>\n    `;\n  }\n\n  static get is() {\n    return 'vaadin-item';\n  }\n\n  static get version() {\n    return '21.0.5';\n  }\n\n  constructor() {\n    super();\n\n    /**\n     * Submittable string value. The default value is the trimmed text content of the element.\n     * @type {string}\n     */\n    this.value;\n  }\n}\n\ncustomElements.define(ItemElement.is, ItemElement);\n\nexport { ItemElement };\n","import { registerStyles, css } from '@vaadin/vaadin-themable-mixin/register-styles.js';\nimport '@vaadin/vaadin-lumo-styles/font-icons.js';\nimport '@vaadin/vaadin-lumo-styles/sizing.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\n\nregisterStyles(\n  'vaadin-item',\n  css`\n    :host {\n      display: flex;\n      align-items: center;\n      box-sizing: border-box;\n      font-family: var(--lumo-font-family);\n      font-size: var(--lumo-font-size-m);\n      line-height: var(--lumo-line-height-xs);\n      padding: 0.5em 1em;\n      min-height: var(--lumo-size-m);\n      -webkit-font-smoothing: antialiased;\n      -moz-osx-font-smoothing: grayscale;\n      -webkit-tap-highlight-color: transparent;\n    }\n\n    /* Checkmark */\n    :host([tabindex])::before {\n      display: var(--_lumo-item-selected-icon-display, none);\n      content: var(--lumo-icons-checkmark);\n      font-family: lumo-icons;\n      font-size: var(--lumo-icon-size-m);\n      line-height: 1;\n      font-weight: normal;\n      width: 1em;\n      height: 1em;\n      margin: calc((1 - var(--lumo-line-height-xs)) * var(--lumo-font-size-m) / 2) 0;\n      color: var(--lumo-primary-text-color);\n      flex: none;\n      opacity: 0;\n      transition: transform 0.2s cubic-bezier(0.12, 0.32, 0.54, 2), opacity 0.1s;\n    }\n\n    :host([selected])::before {\n      opacity: 1;\n    }\n\n    :host([active]:not([selected]))::before {\n      transform: scale(0.8);\n      opacity: 0;\n      transition-duration: 0s;\n    }\n\n    [part='content'] {\n      flex: auto;\n    }\n\n    /* Disabled */\n    :host([disabled]) {\n      color: var(--lumo-disabled-text-color);\n      cursor: default;\n      pointer-events: none;\n    }\n\n    /* Slotted icons */\n    :host ::slotted(vaadin-icon),\n    :host ::slotted(iron-icon) {\n      width: var(--lumo-icon-size-m);\n      height: var(--lumo-icon-size-m);\n    }\n  `,\n  { moduleId: 'lumo-item' }\n);\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { css, registerStyles } from '@vaadin/vaadin-themable-mixin/register-styles.js';\nimport './version.js';\n\nconst colorBase = css`\n  :host {\n    /* Base (background) */\n    --lumo-base-color: #fff;\n\n    /* Tint */\n    --lumo-tint-5pct: hsla(0, 0%, 100%, 0.3);\n    --lumo-tint-10pct: hsla(0, 0%, 100%, 0.37);\n    --lumo-tint-20pct: hsla(0, 0%, 100%, 0.44);\n    --lumo-tint-30pct: hsla(0, 0%, 100%, 0.5);\n    --lumo-tint-40pct: hsla(0, 0%, 100%, 0.57);\n    --lumo-tint-50pct: hsla(0, 0%, 100%, 0.64);\n    --lumo-tint-60pct: hsla(0, 0%, 100%, 0.7);\n    --lumo-tint-70pct: hsla(0, 0%, 100%, 0.77);\n    --lumo-tint-80pct: hsla(0, 0%, 100%, 0.84);\n    --lumo-tint-90pct: hsla(0, 0%, 100%, 0.9);\n    --lumo-tint: #fff;\n\n    /* Shade */\n    --lumo-shade-5pct: hsla(214, 61%, 25%, 0.05);\n    --lumo-shade-10pct: hsla(214, 57%, 24%, 0.1);\n    --lumo-shade-20pct: hsla(214, 53%, 23%, 0.16);\n    --lumo-shade-30pct: hsla(214, 50%, 22%, 0.26);\n    --lumo-shade-40pct: hsla(214, 47%, 21%, 0.38);\n    --lumo-shade-50pct: hsla(214, 45%, 20%, 0.5);\n    --lumo-shade-60pct: hsla(214, 43%, 19%, 0.61);\n    --lumo-shade-70pct: hsla(214, 42%, 18%, 0.72);\n    --lumo-shade-80pct: hsla(214, 41%, 17%, 0.83);\n    --lumo-shade-90pct: hsla(214, 40%, 16%, 0.94);\n    --lumo-shade: hsl(214, 35%, 15%);\n\n    /* Contrast */\n    --lumo-contrast-5pct: var(--lumo-shade-5pct);\n    --lumo-contrast-10pct: var(--lumo-shade-10pct);\n    --lumo-contrast-20pct: var(--lumo-shade-20pct);\n    --lumo-contrast-30pct: var(--lumo-shade-30pct);\n    --lumo-contrast-40pct: var(--lumo-shade-40pct);\n    --lumo-contrast-50pct: var(--lumo-shade-50pct);\n    --lumo-contrast-60pct: var(--lumo-shade-60pct);\n    --lumo-contrast-70pct: var(--lumo-shade-70pct);\n    --lumo-contrast-80pct: var(--lumo-shade-80pct);\n    --lumo-contrast-90pct: var(--lumo-shade-90pct);\n    --lumo-contrast: var(--lumo-shade);\n\n    /* Text */\n    --lumo-header-text-color: var(--lumo-contrast);\n    --lumo-body-text-color: var(--lumo-contrast-90pct);\n    --lumo-secondary-text-color: var(--lumo-contrast-70pct);\n    --lumo-tertiary-text-color: var(--lumo-contrast-50pct);\n    --lumo-disabled-text-color: var(--lumo-contrast-30pct);\n\n    /* Primary */\n    --lumo-primary-color: hsl(214, 90%, 52%);\n    --lumo-primary-color-50pct: hsla(214, 90%, 52%, 0.5);\n    --lumo-primary-color-10pct: hsla(214, 90%, 52%, 0.1);\n    --lumo-primary-text-color: var(--lumo-primary-color);\n    --lumo-primary-contrast-color: #fff;\n\n    /* Error */\n    --lumo-error-color: hsl(3, 100%, 61%);\n    --lumo-error-color-50pct: hsla(3, 100%, 60%, 0.5);\n    --lumo-error-color-10pct: hsla(3, 100%, 60%, 0.1);\n    --lumo-error-text-color: hsl(3, 92%, 53%);\n    --lumo-error-contrast-color: #fff;\n\n    /* Success */\n    --lumo-success-color: hsl(145, 80%, 42%); /* hsl(144,82%,37%); */\n    --lumo-success-color-50pct: hsla(145, 76%, 44%, 0.55);\n    --lumo-success-color-10pct: hsla(145, 76%, 44%, 0.12);\n    --lumo-success-text-color: hsl(145, 100%, 32%);\n    --lumo-success-contrast-color: #fff;\n  }\n`;\n\nconst $tpl = document.createElement('template');\n$tpl.innerHTML = `<style>${colorBase.toString().replace(':host', 'html')}</style>`;\ndocument.head.appendChild($tpl.content);\n\nconst color = css`\n  [theme~='dark'] {\n    /* Base (background) */\n    --lumo-base-color: hsl(214, 35%, 21%);\n\n    /* Tint */\n    --lumo-tint-5pct: hsla(214, 65%, 85%, 0.06);\n    --lumo-tint-10pct: hsla(214, 60%, 80%, 0.14);\n    --lumo-tint-20pct: hsla(214, 64%, 82%, 0.23);\n    --lumo-tint-30pct: hsla(214, 69%, 84%, 0.32);\n    --lumo-tint-40pct: hsla(214, 73%, 86%, 0.41);\n    --lumo-tint-50pct: hsla(214, 78%, 88%, 0.5);\n    --lumo-tint-60pct: hsla(214, 82%, 90%, 0.6);\n    --lumo-tint-70pct: hsla(214, 87%, 92%, 0.7);\n    --lumo-tint-80pct: hsla(214, 91%, 94%, 0.8);\n    --lumo-tint-90pct: hsla(214, 96%, 96%, 0.9);\n    --lumo-tint: hsl(214, 100%, 98%);\n\n    /* Shade */\n    --lumo-shade-5pct: hsla(214, 0%, 0%, 0.07);\n    --lumo-shade-10pct: hsla(214, 4%, 2%, 0.15);\n    --lumo-shade-20pct: hsla(214, 8%, 4%, 0.23);\n    --lumo-shade-30pct: hsla(214, 12%, 6%, 0.32);\n    --lumo-shade-40pct: hsla(214, 16%, 8%, 0.41);\n    --lumo-shade-50pct: hsla(214, 20%, 10%, 0.5);\n    --lumo-shade-60pct: hsla(214, 24%, 12%, 0.6);\n    --lumo-shade-70pct: hsla(214, 28%, 13%, 0.7);\n    --lumo-shade-80pct: hsla(214, 32%, 13%, 0.8);\n    --lumo-shade-90pct: hsla(214, 33%, 13%, 0.9);\n    --lumo-shade: hsl(214, 33%, 13%);\n\n    /* Contrast */\n    --lumo-contrast-5pct: var(--lumo-tint-5pct);\n    --lumo-contrast-10pct: var(--lumo-tint-10pct);\n    --lumo-contrast-20pct: var(--lumo-tint-20pct);\n    --lumo-contrast-30pct: var(--lumo-tint-30pct);\n    --lumo-contrast-40pct: var(--lumo-tint-40pct);\n    --lumo-contrast-50pct: var(--lumo-tint-50pct);\n    --lumo-contrast-60pct: var(--lumo-tint-60pct);\n    --lumo-contrast-70pct: var(--lumo-tint-70pct);\n    --lumo-contrast-80pct: var(--lumo-tint-80pct);\n    --lumo-contrast-90pct: var(--lumo-tint-90pct);\n    --lumo-contrast: var(--lumo-tint);\n\n    /* Text */\n    --lumo-header-text-color: var(--lumo-contrast);\n    --lumo-body-text-color: var(--lumo-contrast-90pct);\n    --lumo-secondary-text-color: var(--lumo-contrast-70pct);\n    --lumo-tertiary-text-color: var(--lumo-contrast-50pct);\n    --lumo-disabled-text-color: var(--lumo-contrast-30pct);\n\n    /* Primary */\n    --lumo-primary-color: hsl(214, 86%, 55%);\n    --lumo-primary-color-50pct: hsla(214, 86%, 55%, 0.5);\n    --lumo-primary-color-10pct: hsla(214, 90%, 63%, 0.1);\n    --lumo-primary-text-color: hsl(214, 100%, 70%);\n    --lumo-primary-contrast-color: #fff;\n\n    /* Error */\n    --lumo-error-color: hsl(3, 90%, 63%);\n    --lumo-error-color-50pct: hsla(3, 90%, 63%, 0.5);\n    --lumo-error-color-10pct: hsla(3, 90%, 63%, 0.1);\n    --lumo-error-text-color: hsl(3, 100%, 67%);\n\n    /* Success */\n    --lumo-success-color: hsl(145, 65%, 42%);\n    --lumo-success-color-50pct: hsla(145, 65%, 42%, 0.5);\n    --lumo-success-color-10pct: hsla(145, 65%, 42%, 0.1);\n    --lumo-success-text-color: hsl(145, 85%, 47%);\n  }\n\n  html {\n    color: var(--lumo-body-text-color);\n    background-color: var(--lumo-base-color);\n  }\n\n  [theme~='dark'] {\n    color: var(--lumo-body-text-color);\n    background-color: var(--lumo-base-color);\n  }\n\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6 {\n    color: var(--lumo-header-text-color);\n  }\n\n  a {\n    color: var(--lumo-primary-text-color);\n  }\n\n  blockquote {\n    color: var(--lumo-secondary-text-color);\n  }\n\n  code,\n  pre {\n    background-color: var(--lumo-contrast-10pct);\n    border-radius: var(--lumo-border-radius-m);\n  }\n`;\n\nregisterStyles('', color, { moduleId: 'lumo-color' });\n\nconst colorLegacy = css`\n  :host {\n    color: var(--lumo-body-text-color) !important;\n    background-color: var(--lumo-base-color) !important;\n  }\n`;\n\nregisterStyles('', colorLegacy, { moduleId: 'lumo-color-legacy', include: ['lumo-color'] });\n\nexport { colorBase, color, colorLegacy };\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { css, registerStyles } from '@vaadin/vaadin-themable-mixin/register-styles.js';\nimport '../color.js';\nimport '../font-icons.js';\nimport '../sizing.js';\nimport '../style.js';\n\nconst fieldButton = css`\n  [part$='button'] {\n    flex: none;\n    width: 1em;\n    height: 1em;\n    line-height: 1;\n    font-size: var(--lumo-icon-size-m);\n    text-align: center;\n    color: var(--lumo-contrast-60pct);\n    transition: 0.2s color;\n    cursor: var(--lumo-clickable-cursor);\n  }\n\n  [part$='button']:hover {\n    color: var(--lumo-contrast-90pct);\n  }\n\n  :host([disabled]) [part$='button'],\n  :host([readonly]) [part$='button'] {\n    color: var(--lumo-contrast-20pct);\n    cursor: default;\n  }\n\n  [part$='button']::before {\n    font-family: 'lumo-icons';\n    display: block;\n  }\n`;\nregisterStyles('', fieldButton, { moduleId: 'lumo-field-button' });\n\nexport { fieldButton };\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { css, registerStyles } from '@vaadin/vaadin-themable-mixin/register-styles.js';\nimport '../spacing.js';\nimport '../style.js';\nimport './overlay.js';\n\nconst menuOverlayCore = css`\n  :host([opening]),\n  :host([closing]) {\n    animation: 0.14s lumo-overlay-dummy-animation;\n  }\n\n  [part='overlay'] {\n    will-change: opacity, transform;\n  }\n\n  :host([opening]) [part='overlay'] {\n    animation: 0.1s lumo-menu-overlay-enter ease-out both;\n  }\n\n  @keyframes lumo-menu-overlay-enter {\n    0% {\n      opacity: 0;\n      transform: translateY(-4px);\n    }\n  }\n\n  :host([closing]) [part='overlay'] {\n    animation: 0.1s lumo-menu-overlay-exit both;\n  }\n\n  @keyframes lumo-menu-overlay-exit {\n    100% {\n      opacity: 0;\n    }\n  }\n`;\n\nregisterStyles('', menuOverlayCore, { moduleId: 'lumo-menu-overlay-core' });\n\nconst menuOverlay = css`\n  /* Small viewport (bottom sheet) styles */\n  /* Use direct media queries instead of the state attributes ([phone] and [fullscreen]) provided by the elements */\n  @media (max-width: 420px), (max-height: 420px) {\n    :host {\n      top: 0 !important;\n      right: 0 !important;\n      bottom: var(--vaadin-overlay-viewport-bottom, 0) !important;\n      left: 0 !important;\n      align-items: stretch !important;\n      justify-content: flex-end !important;\n    }\n\n    [part='overlay'] {\n      max-height: 50vh;\n      width: 100vw;\n      border-radius: 0;\n      box-shadow: var(--lumo-box-shadow-xl);\n    }\n\n    /* The content part scrolls instead of the overlay part, because of the gradient fade-out */\n    [part='content'] {\n      padding: 30px var(--lumo-space-m);\n      max-height: inherit;\n      box-sizing: border-box;\n      -webkit-overflow-scrolling: touch;\n      overflow: auto;\n      -webkit-mask-image: linear-gradient(transparent, #000 40px, #000 calc(100% - 40px), transparent);\n      mask-image: linear-gradient(transparent, #000 40px, #000 calc(100% - 40px), transparent);\n    }\n\n    [part='backdrop'] {\n      display: block;\n    }\n\n    /* Animations */\n\n    :host([opening]) [part='overlay'] {\n      animation: 0.2s lumo-mobile-menu-overlay-enter cubic-bezier(0.215, 0.61, 0.355, 1) both;\n    }\n\n    :host([closing]),\n    :host([closing]) [part='backdrop'] {\n      animation-delay: 0.14s;\n    }\n\n    :host([closing]) [part='overlay'] {\n      animation: 0.14s 0.14s lumo-mobile-menu-overlay-exit cubic-bezier(0.55, 0.055, 0.675, 0.19) both;\n    }\n  }\n\n  @keyframes lumo-mobile-menu-overlay-enter {\n    0% {\n      transform: translateY(150%);\n    }\n  }\n\n  @keyframes lumo-mobile-menu-overlay-exit {\n    100% {\n      transform: translateY(150%);\n    }\n  }\n`;\nregisterStyles('', menuOverlay, { moduleId: 'lumo-menu-overlay', include: ['lumo-overlay', 'lumo-menu-overlay-core'] });\n\nexport { menuOverlayCore, menuOverlay };\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { css, registerStyles } from '@vaadin/vaadin-themable-mixin/register-styles.js';\nimport '../color.js';\nimport '../spacing.js';\nimport '../style.js';\nimport '../typography.js';\n\nconst overlay = css`\n  :host {\n    top: var(--lumo-space-m);\n    right: var(--lumo-space-m);\n    bottom: var(--lumo-space-m);\n    left: var(--lumo-space-m);\n    /* Workaround for Edge issue (only on Surface), where an overflowing vaadin-list-box inside vaadin-select-overlay makes the overlay transparent */\n    /* stylelint-disable-next-line */\n    outline: 0px solid transparent;\n  }\n\n  [part='overlay'] {\n    background-color: var(--lumo-base-color);\n    background-image: linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));\n    border-radius: var(--lumo-border-radius-m);\n    box-shadow: 0 0 0 1px var(--lumo-shade-5pct), var(--lumo-box-shadow-m);\n    color: var(--lumo-body-text-color);\n    font-family: var(--lumo-font-family);\n    font-size: var(--lumo-font-size-m);\n    font-weight: 400;\n    line-height: var(--lumo-line-height-m);\n    letter-spacing: 0;\n    text-transform: none;\n    -webkit-text-size-adjust: 100%;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n  }\n\n  [part='content'] {\n    padding: var(--lumo-space-xs);\n  }\n\n  [part='backdrop'] {\n    background-color: var(--lumo-shade-20pct);\n    animation: 0.2s lumo-overlay-backdrop-enter both;\n    will-change: opacity;\n  }\n\n  @keyframes lumo-overlay-backdrop-enter {\n    0% {\n      opacity: 0;\n    }\n  }\n\n  :host([closing]) [part='backdrop'] {\n    animation: 0.2s lumo-overlay-backdrop-exit both;\n  }\n\n  @keyframes lumo-overlay-backdrop-exit {\n    100% {\n      opacity: 0;\n    }\n  }\n\n  @keyframes lumo-overlay-dummy-animation {\n    0% {\n      opacity: 1;\n    }\n\n    100% {\n      opacity: 1;\n    }\n  }\n`;\n\nregisterStyles('', overlay, { moduleId: 'lumo-overlay' });\n\nexport { overlay };\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { css } from '@vaadin/vaadin-themable-mixin/register-styles.js';\nimport './version.js';\n\nconst sizing = css`\n  :host {\n    --lumo-size-xs: 1.625rem;\n    --lumo-size-s: 1.875rem;\n    --lumo-size-m: 2.25rem;\n    --lumo-size-l: 2.75rem;\n    --lumo-size-xl: 3.5rem;\n\n    /* Icons */\n    --lumo-icon-size-s: 1.25em;\n    --lumo-icon-size-m: 1.5em;\n    --lumo-icon-size-l: 2.25em;\n    /* For backwards compatibility */\n    --lumo-icon-size: var(--lumo-icon-size-m);\n  }\n`;\n\nconst $tpl = document.createElement('template');\n$tpl.innerHTML = `<style>${sizing.toString().replace(':host', 'html')}</style>`;\ndocument.head.appendChild($tpl.content);\n\nexport { sizing };\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { css } from '@vaadin/vaadin-themable-mixin/register-styles.js';\nimport './version.js';\n\nconst spacing = css`\n  :host {\n    /* Square */\n    --lumo-space-xs: 0.25rem;\n    --lumo-space-s: 0.5rem;\n    --lumo-space-m: 1rem;\n    --lumo-space-l: 1.5rem;\n    --lumo-space-xl: 2.5rem;\n\n    /* Wide */\n    --lumo-space-wide-xs: calc(var(--lumo-space-xs) / 2) var(--lumo-space-xs);\n    --lumo-space-wide-s: calc(var(--lumo-space-s) / 2) var(--lumo-space-s);\n    --lumo-space-wide-m: calc(var(--lumo-space-m) / 2) var(--lumo-space-m);\n    --lumo-space-wide-l: calc(var(--lumo-space-l) / 2) var(--lumo-space-l);\n    --lumo-space-wide-xl: calc(var(--lumo-space-xl) / 2) var(--lumo-space-xl);\n\n    /* Tall */\n    --lumo-space-tall-xs: var(--lumo-space-xs) calc(var(--lumo-space-xs) / 2);\n    --lumo-space-tall-s: var(--lumo-space-s) calc(var(--lumo-space-s) / 2);\n    --lumo-space-tall-m: var(--lumo-space-m) calc(var(--lumo-space-m) / 2);\n    --lumo-space-tall-l: var(--lumo-space-l) calc(var(--lumo-space-l) / 2);\n    --lumo-space-tall-xl: var(--lumo-space-xl) calc(var(--lumo-space-xl) / 2);\n  }\n`;\n\nconst $tpl = document.createElement('template');\n$tpl.innerHTML = `<style>${spacing.toString().replace(':host', 'html')}</style>`;\ndocument.head.appendChild($tpl.content);\n\nexport { spacing };\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { css } from '@vaadin/vaadin-themable-mixin/register-styles.js';\nimport './version.js';\n\nconst style = css`\n  :host {\n    /* Border radius */\n    --lumo-border-radius-s: 0.25em; /* Checkbox, badge, date-picker year indicator, etc */\n    --lumo-border-radius-m: var(--lumo-border-radius, 0.25em); /* Button, text field, menu overlay, etc */\n    --lumo-border-radius-l: 0.5em; /* Dialog, notification, etc */\n    --lumo-border-radius: 0.25em; /* Deprecated */\n\n    /* Shadow */\n    --lumo-box-shadow-xs: 0 1px 4px -1px var(--lumo-shade-50pct);\n    --lumo-box-shadow-s: 0 2px 4px -1px var(--lumo-shade-20pct), 0 3px 12px -1px var(--lumo-shade-30pct);\n    --lumo-box-shadow-m: 0 2px 6px -1px var(--lumo-shade-20pct), 0 8px 24px -4px var(--lumo-shade-40pct);\n    --lumo-box-shadow-l: 0 3px 18px -2px var(--lumo-shade-20pct), 0 12px 48px -6px var(--lumo-shade-40pct);\n    --lumo-box-shadow-xl: 0 4px 24px -3px var(--lumo-shade-20pct), 0 18px 64px -8px var(--lumo-shade-40pct);\n\n    /* Clickable element cursor */\n    --lumo-clickable-cursor: default;\n  }\n`;\n\nconst $tpl = document.createElement('template');\n$tpl.innerHTML = `<style>${style.toString().replace(':host', 'html')}</style>`;\ndocument.head.appendChild($tpl.content);\n\nexport { style };\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { css, registerStyles } from '@vaadin/vaadin-themable-mixin/register-styles.js';\nimport './version.js';\n\nconst font = css`\n  :host {\n    /* prettier-ignore */\n    --lumo-font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';\n\n    /* Font sizes */\n    --lumo-font-size-xxs: 0.75rem;\n    --lumo-font-size-xs: 0.8125rem;\n    --lumo-font-size-s: 0.875rem;\n    --lumo-font-size-m: 1rem;\n    --lumo-font-size-l: 1.125rem;\n    --lumo-font-size-xl: 1.375rem;\n    --lumo-font-size-xxl: 1.75rem;\n    --lumo-font-size-xxxl: 2.5rem;\n\n    /* Line heights */\n    --lumo-line-height-xs: 1.25;\n    --lumo-line-height-s: 1.375;\n    --lumo-line-height-m: 1.625;\n  }\n`;\n\nconst $tpl = document.createElement('template');\n$tpl.innerHTML = `<style>${font.toString().replace(':host', 'html')}</style>`;\ndocument.head.appendChild($tpl.content);\n\nconst typography = css`\n  html {\n    font-family: var(--lumo-font-family);\n    font-size: var(--lumo-font-size, var(--lumo-font-size-m));\n    line-height: var(--lumo-line-height-m);\n    -webkit-text-size-adjust: 100%;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n  }\n\n  /* Cant combine with the above selector because that doesnt work in browsers without native shadow dom */\n  :host {\n    font-family: var(--lumo-font-family);\n    font-size: var(--lumo-font-size, var(--lumo-font-size-m));\n    line-height: var(--lumo-line-height-m);\n    -webkit-text-size-adjust: 100%;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n  }\n\n  small,\n  [theme~='font-size-s'] {\n    font-size: var(--lumo-font-size-s);\n    line-height: var(--lumo-line-height-s);\n  }\n\n  [theme~='font-size-xs'] {\n    font-size: var(--lumo-font-size-xs);\n    line-height: var(--lumo-line-height-xs);\n  }\n\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6 {\n    font-weight: 600;\n    line-height: var(--lumo-line-height-xs);\n    margin-top: 1.25em;\n  }\n\n  h1 {\n    font-size: var(--lumo-font-size-xxxl);\n    margin-bottom: 0.75em;\n  }\n\n  h2 {\n    font-size: var(--lumo-font-size-xxl);\n    margin-bottom: 0.5em;\n  }\n\n  h3 {\n    font-size: var(--lumo-font-size-xl);\n    margin-bottom: 0.5em;\n  }\n\n  h4 {\n    font-size: var(--lumo-font-size-l);\n    margin-bottom: 0.5em;\n  }\n\n  h5 {\n    font-size: var(--lumo-font-size-m);\n    margin-bottom: 0.25em;\n  }\n\n  h6 {\n    font-size: var(--lumo-font-size-xs);\n    margin-bottom: 0;\n    text-transform: uppercase;\n    letter-spacing: 0.03em;\n  }\n\n  p,\n  blockquote {\n    margin-top: 0.5em;\n    margin-bottom: 0.75em;\n  }\n\n  a {\n    text-decoration: none;\n  }\n\n  a:hover {\n    text-decoration: underline;\n  }\n\n  hr {\n    display: block;\n    align-self: stretch;\n    height: 1px;\n    border: 0;\n    padding: 0;\n    margin: var(--lumo-space-s) calc(var(--lumo-border-radius-m) / 2);\n    background-color: var(--lumo-contrast-10pct);\n  }\n\n  blockquote {\n    border-left: 2px solid var(--lumo-contrast-30pct);\n  }\n\n  b,\n  strong {\n    font-weight: 600;\n  }\n\n  /* RTL specific styles */\n\n  blockquote[dir='rtl'] {\n    border-left: none;\n    border-right: 2px solid var(--lumo-contrast-30pct);\n  }\n`;\n\nregisterStyles('', typography, { moduleId: 'lumo-typography' });\n\nexport { font, typography };\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { PolymerElement, html } from '@polymer/polymer/polymer-element.js';\nimport { templatize } from '@polymer/polymer/lib/utils/templatize.js';\nimport { afterNextRender } from '@polymer/polymer/lib/utils/render-status.js';\nimport { FlattenedNodesObserver } from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { DirMixin } from '@vaadin/vaadin-element-mixin/vaadin-dir-mixin.js';\nimport { FocusablesHelper } from './vaadin-focusables-helper.js';\n\n/**\n *\n * `<vaadin-overlay>` is a Web Component for creating overlays. The content of the overlay\n * can be populated in two ways: imperatively by using renderer callback function and\n * declaratively by using Polymer's Templates.\n *\n * ### Rendering\n *\n * By default, the overlay uses the content provided by using the renderer callback function.\n *\n * The renderer function provides `root`, `owner`, `model` arguments when applicable.\n * Generate DOM content by using `model` object properties if needed, append it to the `root`\n * element and control the state of the host element by accessing `owner`. Before generating new\n * content, users are able to check if there is already content in `root` for reusing it.\n *\n * ```html\n * <vaadin-overlay id=\"overlay\"></vaadin-overlay>\n * ```\n * ```js\n * const overlay = document.querySelector('#overlay');\n * overlay.renderer = function(root) {\n *  root.textContent = \"Overlay content\";\n * };\n * ```\n *\n * Renderer is called on the opening of the overlay and each time the related model is updated.\n * DOM generated during the renderer call can be reused\n * in the next renderer call and will be provided with the `root` argument.\n * On first call it will be empty.\n *\n * **NOTE:** when the renderer property is defined, the `<template>` content is not used.\n *\n * ### Templating\n *\n * Alternatively, the content can be provided with Polymer Template.\n * Overlay finds the first child template and uses that in case renderer callback function\n * is not provided. You can also set a custom template using the `template` property.\n *\n * After the content from the template is stamped, the `content` property\n * points to the content container.\n *\n * The overlay provides `forwardHostProp` when calling\n * `Polymer.Templatize.templatize` for the template, so that the bindings\n * from the parent scope propagate to the content.  You can also pass\n * custom `instanceProps` object using the `instanceProps` property.\n *\n * ```html\n * <vaadin-overlay>\n *   <template>Overlay content</template>\n * </vaadin-overlay>\n * ```\n *\n * **NOTE:** when using `instanceProps`: because of the Polymer limitation,\n * every template can only be templatized once, so it is important\n * to set `instanceProps` before the `template` is assigned to the overlay.\n *\n * ### Styling\n *\n * To style the overlay content, use styles in the parent scope:\n *\n * - If the overlay is used in a component, then the component styles\n *   apply the overlay content.\n * - If the overlay is used in the global DOM scope, then global styles\n *   apply to the overlay content.\n *\n * See examples for styling the overlay content in the live demos.\n *\n * The following Shadow DOM parts are available for styling the overlay component itself:\n *\n * Part name  | Description\n * -----------|---------------------------------------------------------|\n * `backdrop` | Backdrop of the overlay\n * `overlay`  | Container for position/sizing/alignment of the content\n * `content`  | Content of the overlay\n *\n * The following state attributes are available for styling:\n *\n * Attribute | Description | Part\n * ---|---|---\n * `opening` | Applied just after the overlay is attached to the DOM. You can apply a CSS @keyframe animation for this state. | `:host`\n * `closing` | Applied just before the overlay is detached from the DOM. You can apply a CSS @keyframe animation for this state. | `:host`\n *\n * The following custom CSS properties are available for styling:\n *\n * Custom CSS property | Description | Default value\n * ---|---|---\n * `--vaadin-overlay-viewport-bottom` | Bottom offset of the visible viewport area | `0` or detected offset\n *\n * See [Styling Components](https://vaadin.com/docs/latest/ds/customization/styling-components) documentation.\n *\n * @fires {CustomEvent} opened-changed - Fired when the `opened` property changes.\n *\n * @extends HTMLElement\n * @mixes ThemableMixin\n * @mixes DirMixin\n */\nclass OverlayElement extends ThemableMixin(DirMixin(PolymerElement)) {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          z-index: 200;\n          position: fixed;\n\n          /* Despite of what the names say, <vaadin-overlay> is just a container\n          for position/sizing/alignment. The actual overlay is the overlay part. */\n\n          /* Default position constraints: the entire viewport. Note: themes can\n          override this to introduce gaps between the overlay and the viewport. */\n          top: 0;\n          right: 0;\n          bottom: var(--vaadin-overlay-viewport-bottom);\n          left: 0;\n\n          /* Use flexbox alignment for the overlay part. */\n          display: flex;\n          flex-direction: column; /* makes dropdowns sizing easier */\n          /* Align to center by default. */\n          align-items: center;\n          justify-content: center;\n\n          /* Allow centering when max-width/max-height applies. */\n          margin: auto;\n\n          /* The host is not clickable, only the overlay part is. */\n          pointer-events: none;\n\n          /* Remove tap highlight on touch devices. */\n          -webkit-tap-highlight-color: transparent;\n\n          /* CSS API for host */\n          --vaadin-overlay-viewport-bottom: 0;\n        }\n\n        :host([hidden]),\n        :host(:not([opened]):not([closing])) {\n          display: none !important;\n        }\n\n        [part='overlay'] {\n          -webkit-overflow-scrolling: touch;\n          overflow: auto;\n          pointer-events: auto;\n\n          /* Prevent overflowing the host in MSIE 11 */\n          max-width: 100%;\n          box-sizing: border-box;\n\n          -webkit-tap-highlight-color: initial; /* reenable tap highlight inside */\n        }\n\n        [part='backdrop'] {\n          z-index: -1;\n          content: '';\n          background: rgba(0, 0, 0, 0.5);\n          position: fixed;\n          top: 0;\n          left: 0;\n          bottom: 0;\n          right: 0;\n          pointer-events: auto;\n        }\n      </style>\n\n      <div id=\"backdrop\" part=\"backdrop\" hidden$=\"[[!withBackdrop]]\"></div>\n      <div part=\"overlay\" id=\"overlay\" tabindex=\"0\">\n        <div part=\"content\" id=\"content\">\n          <slot></slot>\n        </div>\n      </div>\n    `;\n  }\n\n  static get is() {\n    return 'vaadin-overlay';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * When true, the overlay is visible and attached to body.\n       */\n      opened: {\n        type: Boolean,\n        notify: true,\n        observer: '_openedChanged',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Owner element passed with renderer function\n       * @type {HTMLElement}\n       */\n      owner: Element,\n\n      /**\n       * Custom function for rendering the content of the overlay.\n       * Receives three arguments:\n       *\n       * - `root` The root container DOM element. Append your content to it.\n       * - `owner` The host element of the renderer function.\n       * - `model` The object with the properties related with rendering.\n       * @type {OverlayRenderer | null | undefined}\n       */\n      renderer: Function,\n\n      /**\n       * The template of the overlay content.\n       * @type {HTMLTemplateElement | null | undefined}\n       */\n      template: {\n        type: Object,\n        notify: true\n      },\n\n      /**\n       * Optional argument for `Polymer.Templatize.templatize`.\n       */\n      instanceProps: {\n        type: Object\n      },\n\n      /**\n       * References the content container after the template is stamped.\n       * @type {!HTMLElement | undefined}\n       */\n      content: {\n        type: Object,\n        notify: true\n      },\n\n      /**\n       * When true the overlay has backdrop on top of content when opened.\n       * @type {boolean}\n       */\n      withBackdrop: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n\n      /**\n       * Object with properties that is passed to `renderer` function\n       */\n      model: Object,\n\n      /**\n       * When true the overlay won't disable the main content, showing\n       * it doesnt change the functionality of the user interface.\n       * @type {boolean}\n       */\n      modeless: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true,\n        observer: '_modelessChanged'\n      },\n\n      /**\n       * When set to true, the overlay is hidden. This also closes the overlay\n       * immediately in case there is a closing animation in progress.\n       * @type {boolean}\n       */\n      hidden: {\n        type: Boolean,\n        reflectToAttribute: true,\n        observer: '_hiddenChanged'\n      },\n\n      /**\n       * When true move focus to the first focusable element in the overlay,\n       * or to the overlay if there are no focusable elements.\n       * @type {boolean}\n       */\n      focusTrap: {\n        type: Boolean,\n        value: false\n      },\n\n      /**\n       * Set to true to enable restoring of focus when overlay is closed.\n       * @type {boolean}\n       */\n      restoreFocusOnClose: {\n        type: Boolean,\n        value: false\n      },\n\n      /** @private */\n      _mouseDownInside: {\n        type: Boolean\n      },\n\n      /** @private */\n      _mouseUpInside: {\n        type: Boolean\n      },\n\n      /** @private */\n      _instance: {\n        type: Object\n      },\n\n      /** @private */\n      _originalContentPart: Object,\n\n      /** @private */\n      _contentNodes: Array,\n\n      /** @private */\n      _oldOwner: Element,\n\n      /** @private */\n      _oldModel: Object,\n\n      /** @private */\n      _oldTemplate: Object,\n\n      /** @private */\n      _oldInstanceProps: Object,\n\n      /** @private */\n      _oldRenderer: Object,\n\n      /** @private */\n      _oldOpened: Boolean\n    };\n  }\n\n  static get observers() {\n    return ['_templateOrRendererChanged(template, renderer, owner, model, instanceProps, opened)'];\n  }\n\n  constructor() {\n    super();\n    this._boundMouseDownListener = this._mouseDownListener.bind(this);\n    this._boundMouseUpListener = this._mouseUpListener.bind(this);\n    this._boundOutsideClickListener = this._outsideClickListener.bind(this);\n    this._boundKeydownListener = this._keydownListener.bind(this);\n\n    this._observer = new FlattenedNodesObserver(this, (info) => {\n      this._setTemplateFromNodes(info.addedNodes);\n    });\n\n    // Listener for preventing closing of the paper-dialog and all components extending `iron-overlay-behavior`.\n    this._boundIronOverlayCanceledListener = this._ironOverlayCanceled.bind(this);\n\n    /* c8 ignore next 3 */\n    if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {\n      this._boundIosResizeListener = () => this._detectIosNavbar();\n    }\n  }\n\n  /** @protected */\n  ready() {\n    super.ready();\n\n    this._observer.flush();\n\n    // Need to add dummy click listeners to this and the backdrop or else\n    // the document click event listener (_outsideClickListener) may never\n    // get invoked on iOS Safari (reproducible in <vaadin-dialog>\n    // and <vaadin-context-menu>).\n    this.addEventListener('click', () => {});\n    this.$.backdrop.addEventListener('click', () => {});\n  }\n\n  /** @private */\n  _detectIosNavbar() {\n    /* c8 ignore next 15 */\n    if (!this.opened) {\n      return;\n    }\n\n    const innerHeight = window.innerHeight;\n    const innerWidth = window.innerWidth;\n\n    const landscape = innerWidth > innerHeight;\n\n    const clientHeight = document.documentElement.clientHeight;\n\n    if (landscape && clientHeight > innerHeight) {\n      this.style.setProperty('--vaadin-overlay-viewport-bottom', clientHeight - innerHeight + 'px');\n    } else {\n      this.style.setProperty('--vaadin-overlay-viewport-bottom', '0');\n    }\n  }\n\n  /**\n   * @param {!Array<!Element>} nodes\n   * @protected\n   */\n  _setTemplateFromNodes(nodes) {\n    this.template = nodes.filter((node) => node.localName && node.localName === 'template')[0] || this.template;\n  }\n\n  /**\n   * @param {Event=} sourceEvent\n   * @event vaadin-overlay-close\n   * fired before the `vaadin-overlay` will be closed. If canceled the closing of the overlay is canceled as well.\n   */\n  close(sourceEvent) {\n    var evt = new CustomEvent('vaadin-overlay-close', {\n      bubbles: true,\n      cancelable: true,\n      detail: { sourceEvent: sourceEvent }\n    });\n    this.dispatchEvent(evt);\n    if (!evt.defaultPrevented) {\n      this.opened = false;\n    }\n  }\n\n  /** @protected */\n  connectedCallback() {\n    super.connectedCallback();\n\n    /* c8 ignore next 3 */\n    if (this._boundIosResizeListener) {\n      this._detectIosNavbar();\n      window.addEventListener('resize', this._boundIosResizeListener);\n    }\n  }\n\n  /** @protected */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n\n    /* c8 ignore next 3 */\n    if (this._boundIosResizeListener) {\n      window.removeEventListener('resize', this._boundIosResizeListener);\n    }\n  }\n\n  /**\n   * Requests an update for the content of the overlay.\n   * While performing the update, it invokes the renderer passed in the `renderer` property.\n   *\n   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.\n   */\n  requestContentUpdate() {\n    if (this.renderer) {\n      this.renderer.call(this.owner, this.content, this.owner, this.model);\n    }\n  }\n\n  /**\n   * Manually invoke existing renderer.\n   *\n   * @deprecated Since Vaadin 21, `render()` is deprecated. Please use `requestContentUpdate()` instead.\n   */\n  render() {\n    console.warn('WARNING: Since Vaadin 21, render() is deprecated. Please use requestContentUpdate() instead.');\n\n    this.requestContentUpdate();\n  }\n\n  /** @private */\n  _ironOverlayCanceled(event) {\n    event.preventDefault();\n  }\n\n  /** @private */\n  _mouseDownListener(event) {\n    this._mouseDownInside = event.composedPath().indexOf(this.$.overlay) >= 0;\n  }\n\n  /** @private */\n  _mouseUpListener(event) {\n    this._mouseUpInside = event.composedPath().indexOf(this.$.overlay) >= 0;\n  }\n\n  /**\n   * We need to listen on 'click' / 'tap' event and capture it and close the overlay before\n   * propagating the event to the listener in the button. Otherwise, if the clicked button would call\n   * open(), this would happen: https://www.youtube.com/watch?v=Z86V_ICUCD4\n   *\n   * @event vaadin-overlay-outside-click\n   * fired before the `vaadin-overlay` will be closed on outside click. If canceled the closing of the overlay is canceled as well.\n   *\n   * @private\n   */\n  _outsideClickListener(event) {\n    if (event.composedPath().indexOf(this.$.overlay) !== -1 || this._mouseDownInside || this._mouseUpInside) {\n      this._mouseDownInside = false;\n      this._mouseUpInside = false;\n      return;\n    }\n    if (!this._last) {\n      return;\n    }\n\n    const evt = new CustomEvent('vaadin-overlay-outside-click', {\n      bubbles: true,\n      cancelable: true,\n      detail: { sourceEvent: event }\n    });\n    this.dispatchEvent(evt);\n\n    if (this.opened && !evt.defaultPrevented) {\n      this.close(event);\n    }\n  }\n\n  /**\n   * @event vaadin-overlay-escape-press\n   * fired before the `vaadin-overlay` will be closed on ESC button press. If canceled the closing of the overlay is canceled as well.\n   *\n   * @private\n   */\n  _keydownListener(event) {\n    if (!this._last) {\n      return;\n    }\n\n    // TAB\n    if (event.key === 'Tab' && this.focusTrap && !event.defaultPrevented) {\n      // if only tab key is pressed, cycle forward, else cycle backwards.\n      this._cycleTab(event.shiftKey ? -1 : 1);\n\n      event.preventDefault();\n\n      // ESC\n    } else if (event.key === 'Escape' || event.key === 'Esc') {\n      const evt = new CustomEvent('vaadin-overlay-escape-press', {\n        bubbles: true,\n        cancelable: true,\n        detail: { sourceEvent: event }\n      });\n      this.dispatchEvent(evt);\n\n      if (this.opened && !evt.defaultPrevented) {\n        this.close(event);\n      }\n    }\n  }\n\n  /** @protected */\n  _ensureTemplatized() {\n    this._setTemplateFromNodes(Array.from(this.children));\n  }\n\n  /**\n   * @event vaadin-overlay-open\n   * fired after the `vaadin-overlay` is opened.\n   *\n   * @private\n   */\n  _openedChanged(opened, wasOpened) {\n    if (!this._instance) {\n      this._ensureTemplatized();\n    }\n\n    if (opened) {\n      // Store focused node.\n      this.__restoreFocusNode = this._getActiveElement();\n      this._animatedOpening();\n\n      afterNextRender(this, () => {\n        if (this.focusTrap && !this.contains(document.activeElement)) {\n          this._cycleTab(0, 0);\n        }\n\n        const evt = new CustomEvent('vaadin-overlay-open', { bubbles: true });\n        this.dispatchEvent(evt);\n      });\n\n      if (!this.modeless) {\n        this._addGlobalListeners();\n      }\n    } else if (wasOpened) {\n      this._animatedClosing();\n\n      if (!this.modeless) {\n        this._removeGlobalListeners();\n      }\n    }\n  }\n\n  /** @private */\n  _hiddenChanged(hidden) {\n    if (hidden && this.hasAttribute('closing')) {\n      this._flushAnimation('closing');\n    }\n  }\n\n  /**\n   * @return {boolean}\n   * @protected\n   */\n  _shouldAnimate() {\n    const name = getComputedStyle(this).getPropertyValue('animation-name');\n    const hidden = getComputedStyle(this).getPropertyValue('display') === 'none';\n    return !hidden && name && name != 'none';\n  }\n\n  /**\n   * @param {string} type\n   * @param {Function} callback\n   * @protected\n   */\n  _enqueueAnimation(type, callback) {\n    const handler = `__${type}Handler`;\n    const listener = (event) => {\n      if (event && event.target !== this) {\n        return;\n      }\n      callback();\n      this.removeEventListener('animationend', listener);\n      delete this[handler];\n    };\n    this[handler] = listener;\n    this.addEventListener('animationend', listener);\n  }\n\n  /**\n   * @param {string} type\n   * @protected\n   */\n  _flushAnimation(type) {\n    const handler = `__${type}Handler`;\n    if (typeof this[handler] === 'function') {\n      this[handler]();\n    }\n  }\n\n  /** @protected */\n  _animatedOpening() {\n    if (this.parentNode === document.body && this.hasAttribute('closing')) {\n      this._flushAnimation('closing');\n    }\n    this._attachOverlay();\n    if (!this.modeless) {\n      this._enterModalState();\n    }\n    this.setAttribute('opening', '');\n\n    const finishOpening = () => {\n      document.addEventListener('iron-overlay-canceled', this._boundIronOverlayCanceledListener);\n\n      this.removeAttribute('opening');\n    };\n\n    if (this._shouldAnimate()) {\n      this._enqueueAnimation('opening', finishOpening);\n    } else {\n      finishOpening();\n    }\n  }\n\n  /** @protected */\n  _attachOverlay() {\n    this._placeholder = document.createComment('vaadin-overlay-placeholder');\n    this.parentNode.insertBefore(this._placeholder, this);\n    document.body.appendChild(this);\n    this.bringToFront();\n  }\n\n  /** @protected */\n  _animatedClosing() {\n    if (this.hasAttribute('opening')) {\n      this._flushAnimation('opening');\n    }\n    if (this._placeholder) {\n      this._exitModalState();\n\n      if (this.restoreFocusOnClose && this.__restoreFocusNode) {\n        // If the activeElement is `<body>` or inside the overlay,\n        // we are allowed to restore the focus. In all the other\n        // cases focus might have been moved elsewhere by another\n        // component or by the user interaction (e.g. click on a\n        // button outside the overlay).\n        const activeElement = this._getActiveElement();\n\n        if (activeElement === document.body || this._deepContains(activeElement)) {\n          this.__restoreFocusNode.focus();\n        }\n        this.__restoreFocusNode = null;\n      }\n\n      this.setAttribute('closing', '');\n\n      const finishClosing = () => {\n        document.removeEventListener('iron-overlay-canceled', this._boundIronOverlayCanceledListener);\n        this._detachOverlay();\n        this.shadowRoot.querySelector('[part=\"overlay\"]').style.removeProperty('pointer-events');\n        this.removeAttribute('closing');\n      };\n\n      if (this._shouldAnimate()) {\n        this._enqueueAnimation('closing', finishClosing);\n      } else {\n        finishClosing();\n      }\n    }\n  }\n\n  /** @protected */\n  _detachOverlay() {\n    this._placeholder.parentNode.insertBefore(this, this._placeholder);\n    this._placeholder.parentNode.removeChild(this._placeholder);\n  }\n\n  /**\n   * Returns all attached overlays in visual stacking order.\n   * @private\n   */\n  static get __attachedInstances() {\n    return Array.from(document.body.children)\n      .filter((el) => el instanceof OverlayElement && !el.hasAttribute('closing'))\n      .sort((a, b) => a.__zIndex - b.__zIndex || 0);\n  }\n\n  /**\n   * returns true if this is the last one in the opened overlays stack\n   * @return {boolean}\n   * @protected\n   */\n  get _last() {\n    return this === OverlayElement.__attachedInstances.pop();\n  }\n\n  /** @private */\n  _modelessChanged(modeless) {\n    if (!modeless) {\n      if (this.opened) {\n        this._addGlobalListeners();\n        this._enterModalState();\n      }\n    } else {\n      this._removeGlobalListeners();\n      this._exitModalState();\n    }\n  }\n\n  /** @protected */\n  _addGlobalListeners() {\n    document.addEventListener('mousedown', this._boundMouseDownListener);\n    document.addEventListener('mouseup', this._boundMouseUpListener);\n    // Firefox leaks click to document on contextmenu even if prevented\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=990614\n    document.documentElement.addEventListener('click', this._boundOutsideClickListener, true);\n    document.addEventListener('keydown', this._boundKeydownListener);\n  }\n\n  /** @protected */\n  _enterModalState() {\n    if (document.body.style.pointerEvents !== 'none') {\n      // Set body pointer-events to 'none' to disable mouse interactions with\n      // other document nodes.\n      this._previousDocumentPointerEvents = document.body.style.pointerEvents;\n      document.body.style.pointerEvents = 'none';\n    }\n\n    // Disable pointer events in other attached overlays\n    OverlayElement.__attachedInstances.forEach((el) => {\n      if (el !== this) {\n        el.shadowRoot.querySelector('[part=\"overlay\"]').style.pointerEvents = 'none';\n      }\n    });\n  }\n\n  /** @protected */\n  _removeGlobalListeners() {\n    document.removeEventListener('mousedown', this._boundMouseDownListener);\n    document.removeEventListener('mouseup', this._boundMouseUpListener);\n    document.documentElement.removeEventListener('click', this._boundOutsideClickListener, true);\n    document.removeEventListener('keydown', this._boundKeydownListener);\n  }\n\n  /** @protected */\n  _exitModalState() {\n    if (this._previousDocumentPointerEvents !== undefined) {\n      // Restore body pointer-events\n      document.body.style.pointerEvents = this._previousDocumentPointerEvents;\n      delete this._previousDocumentPointerEvents;\n    }\n\n    // Restore pointer events in the previous overlay(s)\n    const instances = OverlayElement.__attachedInstances;\n    let el;\n    // Use instances.pop() to ensure the reverse order\n    while ((el = instances.pop())) {\n      if (el === this) {\n        // Skip the current instance\n        continue;\n      }\n      el.shadowRoot.querySelector('[part=\"overlay\"]').style.removeProperty('pointer-events');\n      if (!el.modeless) {\n        // Stop after the last modal\n        break;\n      }\n    }\n  }\n\n  /** @protected */\n  _removeOldContent() {\n    if (!this.content || !this._contentNodes) {\n      return;\n    }\n\n    this._observer.disconnect();\n\n    this._contentNodes.forEach((node) => {\n      if (node.parentNode === this.content) {\n        this.content.removeChild(node);\n      }\n    });\n\n    if (this._originalContentPart) {\n      // Restore the original <div part=\"content\">\n      this.$.content.parentNode.replaceChild(this._originalContentPart, this.$.content);\n      this.$.content = this._originalContentPart;\n      this._originalContentPart = undefined;\n    }\n\n    this._observer.connect();\n\n    this._contentNodes = undefined;\n    this.content = undefined;\n  }\n\n  /**\n   * @param {!HTMLTemplateElement} template\n   * @param {object} instanceProps\n   * @protected\n   */\n  _stampOverlayTemplate(template, instanceProps) {\n    this._removeOldContent();\n\n    if (!template._Templatizer) {\n      template._Templatizer = templatize(template, this, {\n        instanceProps: instanceProps,\n        forwardHostProp: function (prop, value) {\n          if (this._instance) {\n            this._instance.forwardHostProp(prop, value);\n          }\n        }\n      });\n    }\n\n    this._instance = new template._Templatizer({});\n    this._contentNodes = Array.from(this._instance.root.childNodes);\n\n    const templateRoot = template._templateRoot || (template._templateRoot = template.getRootNode());\n\n    if (templateRoot !== document) {\n      if (!this.$.content.shadowRoot) {\n        this.$.content.attachShadow({ mode: 'open' });\n      }\n\n      let scopeCssText = Array.from(templateRoot.querySelectorAll('style')).reduce(\n        (result, style) => result + style.textContent,\n        ''\n      );\n\n      // The overlay roots :host styles should not apply inside the overlay\n      scopeCssText = scopeCssText.replace(/:host/g, ':host-nomatch');\n\n      if (scopeCssText) {\n        // Append a style to the content shadowRoot\n        const style = document.createElement('style');\n        style.textContent = scopeCssText;\n        this.$.content.shadowRoot.appendChild(style);\n        this._contentNodes.unshift(style);\n      }\n\n      this.$.content.shadowRoot.appendChild(this._instance.root);\n      this.content = this.$.content.shadowRoot;\n    } else {\n      this.appendChild(this._instance.root);\n      this.content = this;\n    }\n  }\n\n  /** @private */\n  _removeNewRendererOrTemplate(template, oldTemplate, renderer, oldRenderer) {\n    if (template !== oldTemplate) {\n      this.template = undefined;\n    } else if (renderer !== oldRenderer) {\n      this.renderer = undefined;\n    }\n  }\n\n  /** @private */\n  _templateOrRendererChanged(template, renderer, owner, model, instanceProps, opened) {\n    if (template && renderer) {\n      this._removeNewRendererOrTemplate(template, this._oldTemplate, renderer, this._oldRenderer);\n      throw new Error('You should only use either a renderer or a template for overlay content');\n    }\n\n    const ownerOrModelChanged = this._oldOwner !== owner || this._oldModel !== model;\n    this._oldModel = model;\n    this._oldOwner = owner;\n\n    const templateOrInstancePropsChanged = this._oldInstanceProps !== instanceProps || this._oldTemplate !== template;\n    this._oldInstanceProps = instanceProps;\n    this._oldTemplate = template;\n\n    const rendererChanged = this._oldRenderer !== renderer;\n    this._oldRenderer = renderer;\n\n    const openedChanged = this._oldOpened !== opened;\n    this._oldOpened = opened;\n\n    if (rendererChanged) {\n      this.content = this;\n      this.content.innerHTML = '';\n      // Whenever a Lit-based renderer is used, it assigns a Lit part to the node it was rendered into.\n      // When clearing the rendered content, this part needs to be manually disposed of.\n      // Otherwise, using a Lit-based renderer on the same node will throw an exception or render nothing afterward.\n      delete this.content._$litPart$;\n    }\n\n    if (template && templateOrInstancePropsChanged) {\n      this._stampOverlayTemplate(template, instanceProps);\n    } else if (renderer && (rendererChanged || openedChanged || ownerOrModelChanged)) {\n      if (opened) {\n        this.requestContentUpdate();\n      }\n    }\n  }\n\n  /**\n   * @param {Element} element\n   * @return {boolean}\n   * @protected\n   */\n  _isFocused(element) {\n    return element && element.getRootNode().activeElement === element;\n  }\n\n  /**\n   * @param {Element[]} elements\n   * @return {number}\n   * @protected\n   */\n  _focusedIndex(elements) {\n    elements = elements || this._getFocusableElements();\n    return elements.indexOf(elements.filter(this._isFocused).pop());\n  }\n\n  /**\n   * @param {number} increment\n   * @param {number | undefined} index\n   * @protected\n   */\n  _cycleTab(increment, index) {\n    const focusableElements = this._getFocusableElements();\n\n    if (index === undefined) {\n      index = this._focusedIndex(focusableElements);\n    }\n\n    index += increment;\n\n    // rollover to first item\n    if (index >= focusableElements.length) {\n      index = 0;\n      // go to last item\n    } else if (index < 0) {\n      index = focusableElements.length - 1;\n    }\n\n    focusableElements[index].focus();\n  }\n\n  /**\n   * @return {!Array<!HTMLElement>}\n   * @protected\n   */\n  _getFocusableElements() {\n    // collect all focusable elements\n    return FocusablesHelper.getTabbableNodes(this.$.overlay);\n  }\n\n  /**\n   * @return {!Element}\n   * @protected\n   */\n  _getActiveElement() {\n    // document.activeElement can be null\n    // https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement\n    let active = document.activeElement || document.body;\n    while (active.shadowRoot && active.shadowRoot.activeElement) {\n      active = active.shadowRoot.activeElement;\n    }\n    return active;\n  }\n\n  /**\n   * @param {!Node} node\n   * @return {boolean}\n   * @protected\n   */\n  _deepContains(node) {\n    if (this.contains(node)) {\n      return true;\n    }\n    let n = node;\n    const doc = node.ownerDocument;\n    // walk from node to `this` or `document`\n    while (n && n !== doc && n !== this) {\n      n = n.parentNode || n.host;\n    }\n    return n === this;\n  }\n\n  /**\n   * Brings the overlay as visually the frontmost one\n   */\n  bringToFront() {\n    let zIndex = '';\n    const frontmost = OverlayElement.__attachedInstances.filter((o) => o !== this).pop();\n    if (frontmost) {\n      const frontmostZIndex = frontmost.__zIndex;\n      zIndex = frontmostZIndex + 1;\n    }\n    this.style.zIndex = zIndex;\n    this.__zIndex = zIndex || parseFloat(getComputedStyle(this).zIndex);\n  }\n}\n\ncustomElements.define(OverlayElement.is, OverlayElement);\nexport { OverlayElement };\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut, animationFrame } from '@polymer/polymer/lib/utils/async.js';\nimport { registerStyles, css } from '@vaadin/vaadin-themable-mixin/register-styles.js';\n\nregisterStyles(\n  '',\n  css`\n    :host {\n      display: inline-flex;\n      outline: none;\n    }\n\n    :host::before {\n      content: '\\\\2003';\n      width: 0;\n      display: inline-block;\n      /* Size and position this element on the same vertical position as the input-field element\n          to make vertical align for the host element work as expected */\n    }\n\n    :host([hidden]) {\n      display: none !important;\n    }\n\n    .vaadin-text-field-container,\n    .vaadin-text-area-container {\n      display: flex;\n      flex-direction: column;\n      min-width: 100%;\n      max-width: 100%;\n      width: var(--vaadin-text-field-default-width, 12em);\n    }\n\n    [part='label']:empty {\n      display: none;\n    }\n\n    [part='input-field'] {\n      display: flex;\n      align-items: center;\n      flex: auto;\n    }\n\n    .vaadin-text-field-container [part='input-field'] {\n      flex-grow: 0;\n    }\n\n    /* Reset the native input styles */\n    [part='value'],\n    [part='input-field'] ::slotted(input),\n    [part='input-field'] ::slotted(textarea) {\n      -webkit-appearance: none;\n      -moz-appearance: none;\n      outline: none;\n      margin: 0;\n      padding: 0;\n      border: 0;\n      border-radius: 0;\n      min-width: 0;\n      font: inherit;\n      font-size: 1em;\n      line-height: normal;\n      color: inherit;\n      background-color: transparent;\n      /* Disable default invalid style in Firefox */\n      box-shadow: none;\n    }\n\n    [part='input-field'] ::slotted(*) {\n      flex: none;\n    }\n\n    [part='value'],\n    [part='input-field'] ::slotted(input),\n    [part='input-field'] ::slotted(textarea),\n    [part='input-field'] ::slotted([part='value']) {\n      flex: auto;\n      white-space: nowrap;\n      overflow: hidden;\n      width: 100%;\n      height: 100%;\n    }\n\n    [part='input-field'] ::slotted(textarea) {\n      resize: none;\n    }\n\n    [part='clear-button'] {\n      display: none;\n      cursor: default;\n    }\n\n    [part='clear-button']::before {\n      content: '';\n    }\n\n    :host([clear-button-visible][has-value]:not([disabled]):not([readonly])) [part='clear-button'] {\n      display: block;\n    }\n  `,\n  { moduleId: 'vaadin-text-field-shared-styles' }\n);\n\nconst HOST_PROPS = {\n  default: [\n    'autofocus',\n    'pattern',\n    'autocapitalize',\n    'autocorrect',\n    'maxlength',\n    'minlength',\n    'name',\n    'placeholder',\n    'autocomplete',\n    'title',\n    'disabled',\n    'readonly',\n    'required'\n  ],\n  accessible: ['invalid']\n};\n\nconst PROP_TYPE = {\n  DEFAULT: 'default',\n  ACCESSIBLE: 'accessible'\n};\n\n/**\n * @polymerMixin\n */\nexport const TextFieldMixin = (subclass) =>\n  class VaadinTextFieldMixin extends subclass {\n    static get properties() {\n      return {\n        /**\n         * Whether the value of the control can be automatically completed by the browser.\n         * List of available options at:\n         * https://developer.mozilla.org/en/docs/Web/HTML/Element/input#attr-autocomplete\n         */\n        autocomplete: {\n          type: String\n        },\n\n        /**\n         * This is a property supported by Safari that is used to control whether\n         * autocorrection should be enabled when the user is entering/editing the text.\n         * Possible values are:\n         * on: Enable autocorrection.\n         * off: Disable autocorrection.\n         * @type {!TextFieldAutoCorrect | undefined}\n         */\n        autocorrect: {\n          type: String\n        },\n\n        /**\n         * This is a property supported by Safari and Chrome that is used to control whether\n         * autocapitalization should be enabled when the user is entering/editing the text.\n         * Possible values are:\n         * characters: Characters capitalization.\n         * words: Words capitalization.\n         * sentences: Sentences capitalization.\n         * none: No capitalization.\n         * @type {!TextFieldAutoCapitalize | undefined}\n         */\n        autocapitalize: {\n          type: String\n        },\n\n        /**\n         * Specify that the value should be automatically selected when the field gains focus.\n         * @type {boolean}\n         */\n        autoselect: {\n          type: Boolean,\n          value: false\n        },\n\n        /**\n         * Set to true to display the clear icon which clears the input.\n         * @attr {boolean} clear-button-visible\n         * @type {boolean}\n         */\n        clearButtonVisible: {\n          type: Boolean,\n          value: false,\n          reflectToAttribute: true\n        },\n\n        /**\n         * Error to show when the input value is invalid.\n         * @attr {string} error-message\n         * @type {string}\n         */\n        errorMessage: {\n          type: String,\n          value: '',\n          observer: '_errorMessageChanged'\n        },\n\n        /**\n         * Object with translated strings used for localization. Has\n         * the following structure and default values:\n         *\n         * ```\n         * {\n         *   // Translation of the clear icon button accessible label\n         *   clear: 'Clear'\n         * }\n         * ```\n         * @type {{clear: string}}\n         */\n        i18n: {\n          type: Object,\n          value: () => {\n            return {\n              clear: 'Clear'\n            };\n          }\n        },\n\n        /**\n         * String used for the label element.\n         * @type {string}\n         */\n        label: {\n          type: String,\n          value: '',\n          observer: '_labelChanged'\n        },\n\n        /**\n         * String used for the helper text.\n         * @attr {string} helper-text\n         * @type {string | null}\n         */\n        helperText: {\n          type: String,\n          value: '',\n          observer: '_helperTextChanged'\n        },\n\n        /**\n         * Maximum number of characters (in Unicode code points) that the user can enter.\n         */\n        maxlength: {\n          type: Number\n        },\n\n        /**\n         * Minimum number of characters (in Unicode code points) that the user can enter.\n         */\n        minlength: {\n          type: Number\n        },\n\n        /**\n         * The name of the control, which is submitted with the form data.\n         */\n        name: {\n          type: String\n        },\n\n        /**\n         * A hint to the user of what can be entered in the control.\n         */\n        placeholder: {\n          type: String\n        },\n\n        /**\n         * This attribute indicates that the user cannot modify the value of the control.\n         */\n        readonly: {\n          type: Boolean,\n          reflectToAttribute: true\n        },\n\n        /**\n         * Specifies that the user must fill in a value.\n         */\n        required: {\n          type: Boolean,\n          reflectToAttribute: true\n        },\n\n        /**\n         * The initial value of the control.\n         * It can be used for two-way data binding.\n         * @type {string}\n         */\n        value: {\n          type: String,\n          value: '',\n          observer: '_valueChanged',\n          notify: true\n        },\n\n        /**\n         * This property is set to true when the control value is invalid.\n         * @type {boolean}\n         */\n        invalid: {\n          type: Boolean,\n          reflectToAttribute: true,\n          notify: true,\n          value: false\n        },\n\n        /**\n         * When set to true, user is prevented from typing a value that\n         * conflicts with the given `pattern`.\n         * @attr {boolean} prevent-invalid-input\n         */\n        preventInvalidInput: {\n          type: Boolean\n        },\n\n        /**\n         * A pattern matched against individual characters the user inputs.\n         * When set, the field will prevent:\n         * - `keyDown` events if the entered key doesn't match `/^_enabledCharPattern$/`\n         * - `paste` events if the pasted text doesn't match `/^_enabledCharPattern*$/`\n         * - `drop` events if the dropped text doesn't match `/^_enabledCharPattern*$/`\n         *\n         * For example, to enable entering only numbers and minus signs,\n         * `_enabledCharPattern = \"[\\\\d-]\"`\n         * @protected\n         */\n        _enabledCharPattern: String,\n\n        /** @private */\n        _labelId: String,\n\n        /** @private */\n        _helperTextId: String,\n\n        /** @private */\n        _errorId: String,\n\n        /** @private */\n        _inputId: String,\n\n        /** @private */\n        _hasSlottedHelper: Boolean\n      };\n    }\n\n    static get observers() {\n      return [\n        '_hostPropsChanged(' + HOST_PROPS.default.join(', ') + ')',\n        '_hostAccessiblePropsChanged(' + HOST_PROPS.accessible.join(', ') + ')',\n        '_getActiveErrorId(invalid, errorMessage, _errorId, helperText, _helperTextId, _hasSlottedHelper)',\n        '_getActiveLabelId(label, _labelId, _inputId)',\n        '__observeOffsetHeight(errorMessage, invalid, label, helperText)',\n        '__enabledCharPatternChanged(_enabledCharPattern)'\n      ];\n    }\n\n    /**\n     * @return {HTMLElement | undefined}\n     * @protected\n     */\n    get focusElement() {\n      if (!this.shadowRoot) {\n        return undefined;\n      }\n      const slotted = this.querySelector(`${this._slottedTagName}[slot=\"${this._slottedTagName}\"]`);\n      if (slotted) {\n        return slotted;\n      }\n      return this.shadowRoot.querySelector('[part=\"value\"]');\n    }\n\n    /**\n     * @return {HTMLElement | undefined}}\n     * @protected\n     */\n    get inputElement() {\n      return this.focusElement;\n    }\n\n    /**\n     * @return {string}\n     * @protected\n     */\n    get _slottedTagName() {\n      return 'input';\n    }\n\n    /** @protected */\n    _createConstraintsObserver() {\n      // This complex observer needs to be added dynamically here (instead of defining it above in the `get observers()`)\n      // so that it runs after complex observers of inheriting classes. Otherwise e.g. `_stepOrMinChanged()` observer of\n      // vaadin-number-field would run after this and the `min` and `step` properties would not yet be propagated to\n      // the `inputElement` when this runs.\n      this._createMethodObserver('_constraintsChanged(required, minlength, maxlength, pattern)');\n    }\n\n    /** @private */\n    _onInput(e) {\n      if (this.preventInvalidInput) {\n        const input = this.inputElement;\n        if (input.value.length > 0 && !this.checkValidity()) {\n          input.value = this.value || '';\n          // add input-prevented attribute for 200ms\n          this.setAttribute('input-prevented', '');\n          this._inputDebouncer = Debouncer.debounce(this._inputDebouncer, timeOut.after(200), () => {\n            this.removeAttribute('input-prevented');\n          });\n          return;\n        }\n      }\n\n      if (!e.__fromClearButton) {\n        this.__userInput = true;\n      }\n\n      this.value = e.target.value;\n      this.__userInput = false;\n    }\n\n    /**\n     * @param {!Event} e\n     * @protected\n     */\n    _onChange(e) {\n      if (this._valueClearing) {\n        return;\n      }\n\n      // In the Shadow DOM, the `change` event is not leaked into the\n      // ancestor tree, so we must do this manually.\n      const changeEvent = new CustomEvent('change', {\n        detail: {\n          sourceEvent: e\n        },\n        bubbles: e.bubbles,\n        cancelable: e.cancelable\n      });\n      this.dispatchEvent(changeEvent);\n    }\n\n    /**\n     * @param {unknown} newVal\n     * @param {unknown} oldVal\n     * @protected\n     */\n    _valueChanged(newVal, oldVal) {\n      // setting initial value to empty string, skip validation\n      if (newVal === '' && oldVal === undefined) {\n        return;\n      }\n\n      if (newVal !== '' && newVal != null) {\n        this.setAttribute('has-value', '');\n      } else {\n        this.removeAttribute('has-value');\n      }\n\n      if (this.__userInput) {\n        return;\n      } else if (newVal !== undefined) {\n        this.inputElement.value = newVal;\n      } else {\n        this.value = this.inputElement.value = '';\n      }\n\n      if (this.invalid) {\n        this.validate();\n      }\n    }\n\n    /** @private */\n    _labelChanged(label) {\n      this._setOrToggleAttribute('has-label', !!label, this);\n    }\n\n    /** @private */\n    _helperTextChanged(helperText) {\n      this._setOrToggleAttribute('has-helper', !!helperText, this);\n    }\n\n    /** @private */\n    _errorMessageChanged(errorMessage) {\n      this._setOrToggleAttribute('has-error-message', !!errorMessage, this);\n    }\n\n    /** @private */\n    _onHelperSlotChange() {\n      const slottedNodes = this.shadowRoot.querySelector(`[name=\"helper\"]`).assignedNodes({ flatten: true });\n      // Only has slotted helper if not a text node\n      // Text nodes are added by the helperText prop and not the helper slot\n      // The filter is added due to shady DOM triggering this callback on helperText prop change\n      this._hasSlottedHelper = slottedNodes.filter((node) => node.nodeType !== 3).length;\n\n      if (this._hasSlottedHelper) {\n        this.setAttribute('has-helper', 'slotted');\n      } else if (this.helperText === '' || this.helperText === null) {\n        this.removeAttribute('has-helper');\n      }\n    }\n\n    /** @private */\n    _onSlotChange() {\n      const slotted = this.querySelector(`${this._slottedTagName}[slot=\"${this._slottedTagName}\"]`);\n\n      if (this.value) {\n        this.inputElement.value = this.value;\n        this.validate();\n      }\n\n      if (slotted && !this._slottedInput) {\n        this._validateSlottedValue(slotted);\n        this._addInputListeners(slotted);\n        this._slottedInput = slotted;\n      } else if (!slotted && this._slottedInput) {\n        this._removeInputListeners(this._slottedInput);\n        this._slottedInput = undefined;\n      }\n\n      Object.keys(PROP_TYPE)\n        .map((key) => PROP_TYPE[key])\n        .forEach((type) =>\n          this._propagateHostAttributes(\n            HOST_PROPS[type].map((attr) => this[attr]),\n            type\n          )\n        );\n    }\n\n    /** @private */\n    _hostPropsChanged(...attributesValues) {\n      this._propagateHostAttributes(attributesValues, PROP_TYPE.DEFAULT);\n    }\n\n    /** @private */\n    _hostAccessiblePropsChanged(...attributesValues) {\n      this._propagateHostAttributes(attributesValues, PROP_TYPE.ACCESSIBLE);\n    }\n\n    /** @private */\n    _validateSlottedValue(slotted) {\n      if (slotted.value !== this.value) {\n        console.warn('Please define value on the vaadin-text-field component!');\n        slotted.value = '';\n      }\n    }\n\n    /** @private */\n    _propagateHostAttributes(attributesValues, type) {\n      const input = this.inputElement;\n      const attributeNames = HOST_PROPS[type];\n\n      if (type === PROP_TYPE.ACCESSIBLE) {\n        attributeNames.forEach((attr, index) => {\n          this._setOrToggleAttribute(attr, attributesValues[index], input);\n          this._setOrToggleAttribute(`aria-${attr}`, attributesValues[index] ? 'true' : false, input);\n        });\n      } else {\n        attributeNames.forEach((attr, index) => {\n          this._setOrToggleAttribute(attr, attributesValues[index], input);\n        });\n      }\n    }\n\n    /** @private */\n    _setOrToggleAttribute(name, value, node) {\n      if (!name || !node) {\n        return;\n      }\n\n      if (value) {\n        node.setAttribute(name, typeof value === 'boolean' ? '' : value);\n      } else {\n        node.removeAttribute(name);\n      }\n    }\n\n    /**\n     * @param {boolean | undefined} required\n     * @param {number | undefined} minlength\n     * @param {number | undefined} maxlength\n     * @param {string | undefined} maxlength\n     * @protected\n     */\n    _constraintsChanged(required, minlength, maxlength, pattern) {\n      if (!this.invalid) {\n        return;\n      }\n\n      if (!required && !minlength && !maxlength && !pattern) {\n        this.invalid = false;\n      } else {\n        this.validate();\n      }\n    }\n\n    /**\n     * Returns true if the current input value satisfies all constraints (if any)\n     * @return {boolean}\n     */\n    checkValidity() {\n      // Note (Yuriy): `__forceCheckValidity` is used in containing components (i.e. `vaadin-date-picker`) in order\n      // to force the checkValidity instead of returning the previous invalid state.\n      if (this.required || this.pattern || this.maxlength || this.minlength || this.__forceCheckValidity) {\n        return this.inputElement.checkValidity();\n      } else {\n        return !this.invalid;\n      }\n    }\n\n    /** @private */\n    _addInputListeners(node) {\n      node.addEventListener('input', this._boundOnInput);\n      node.addEventListener('change', this._boundOnChange);\n      node.addEventListener('blur', this._boundOnBlur);\n      node.addEventListener('focus', this._boundOnFocus);\n      node.addEventListener('paste', this._boundOnPaste);\n      node.addEventListener('drop', this._boundOnDrop);\n      node.addEventListener('beforeinput', this._boundOnBeforeInput);\n    }\n\n    /** @private */\n    _removeInputListeners(node) {\n      node.removeEventListener('input', this._boundOnInput);\n      node.removeEventListener('change', this._boundOnChange);\n      node.removeEventListener('blur', this._boundOnBlur);\n      node.removeEventListener('focus', this._boundOnFocus);\n      node.removeEventListener('paste', this._boundOnPaste);\n      node.removeEventListener('drop', this._boundOnDrop);\n      node.removeEventListener('beforeinput', this._boundOnBeforeInput);\n    }\n\n    /** @protected */\n    ready() {\n      super.ready();\n\n      this._createConstraintsObserver();\n\n      this._boundOnInput = this._onInput.bind(this);\n      this._boundOnChange = this._onChange.bind(this);\n      this._boundOnBlur = this._onBlur.bind(this);\n      this._boundOnFocus = this._onFocus.bind(this);\n      this._boundOnPaste = this._onPaste.bind(this);\n      this._boundOnDrop = this._onDrop.bind(this);\n      this._boundOnBeforeInput = this._onBeforeInput.bind(this);\n\n      const defaultInput = this.shadowRoot.querySelector('[part=\"value\"]');\n      this._slottedInput = this.querySelector(`${this._slottedTagName}[slot=\"${this._slottedTagName}\"]`);\n      this._addInputListeners(defaultInput);\n      if (this._slottedInput) {\n        this._addInputListeners(this._slottedInput);\n      }\n\n      this.shadowRoot\n        .querySelector('[name=\"input\"], [name=\"textarea\"]')\n        .addEventListener('slotchange', this._onSlotChange.bind(this));\n\n      this._onHelperSlotChange();\n      this.shadowRoot\n        .querySelector('[name=\"helper\"]')\n        .addEventListener('slotchange', this._onHelperSlotChange.bind(this));\n\n      this.$.clearButton.addEventListener('mousedown', () => (this._valueClearing = true));\n      this.$.clearButton.addEventListener('mouseleave', () => (this._valueClearing = false));\n      this.$.clearButton.addEventListener('click', this._onClearButtonClick.bind(this));\n      this.addEventListener('keydown', this._onKeyDown.bind(this));\n\n      var uniqueId = (TextFieldMixin._uniqueId = 1 + TextFieldMixin._uniqueId || 0);\n      this._errorId = `${this.constructor.is}-error-${uniqueId}`;\n      this._labelId = `${this.constructor.is}-label-${uniqueId}`;\n      this._helperTextId = `${this.constructor.is}-helper-${uniqueId}`;\n      this._inputId = `${this.constructor.is}-input-${uniqueId}`;\n\n      // Lumo theme defines a max-height transition for the \"error-message\"\n      // part on invalid state change.\n      this.shadowRoot.querySelector('[part=\"error-message\"]').addEventListener('transitionend', () => {\n        this.__observeOffsetHeight();\n      });\n    }\n\n    /**\n     * Returns true if `value` is valid.\n     *\n     * @return {boolean} True if the value is valid.\n     */\n    validate() {\n      return !(this.invalid = !this.checkValidity());\n    }\n\n    clear() {\n      this.value = '';\n    }\n\n    /** @private */\n    _onBlur() {\n      this.validate();\n    }\n\n    /** @private */\n    _onFocus() {\n      if (this.autoselect) {\n        this.inputElement.select();\n        // iOS 9 workaround: https://stackoverflow.com/a/7436574\n        setTimeout(() => {\n          try {\n            this.inputElement.setSelectionRange(0, 9999);\n          } catch (e) {\n            // The workaround may cause errors on different input types.\n            // Needs to be suppressed. See https://github.com/vaadin/flow/issues/6070\n          }\n        });\n      }\n    }\n\n    /** @private */\n    _onClearButtonClick(e) {\n      e.preventDefault();\n      // NOTE(yuriy): This line won't affect focus on the host. Cannot be properly tested.\n      this.inputElement.focus();\n      this.clear();\n      this._valueClearing = false;\n      const inputEvent = new Event('input', { bubbles: true, composed: true });\n      inputEvent.__fromClearButton = true;\n      const changeEvent = new Event('change', { bubbles: !this._slottedInput });\n      changeEvent.__fromClearButton = true;\n      this.inputElement.dispatchEvent(inputEvent);\n      this.inputElement.dispatchEvent(changeEvent);\n    }\n\n    /**\n     * @param {!KeyboardEvent} e\n     * @protected\n     */\n    _onKeyDown(e) {\n      if (e.keyCode === 27 && this.clearButtonVisible) {\n        const dispatchChange = !!this.value;\n        this.clear();\n        dispatchChange && this.inputElement.dispatchEvent(new Event('change', { bubbles: !this._slottedInput }));\n      }\n\n      if (this._enabledCharPattern && !this.__shouldAcceptKey(e)) {\n        e.preventDefault();\n      }\n    }\n\n    /** @private */\n    __shouldAcceptKey(event) {\n      return (\n        event.metaKey ||\n        event.ctrlKey ||\n        !event.key || // allow typing anything if event.key is not supported\n        event.key.length !== 1 || // allow \"Backspace\", \"ArrowLeft\" etc.\n        this.__enabledCharRegExp.test(event.key)\n      );\n    }\n\n    /** @private */\n    _onPaste(e) {\n      if (this._enabledCharPattern) {\n        const pastedText = (e.clipboardData || window.clipboardData).getData('text');\n        if (!this.__enabledTextRegExp.test(pastedText)) {\n          e.preventDefault();\n        }\n      }\n    }\n\n    /** @private */\n    _onDrop(e) {\n      if (this._enabledCharPattern) {\n        const draggedText = e.dataTransfer.getData('text');\n        if (!this.__enabledTextRegExp.test(draggedText)) {\n          e.preventDefault();\n        }\n      }\n    }\n\n    /** @private */\n    _onBeforeInput(e) {\n      // The `beforeinput` event covers all the cases for `_enabledCharPattern`: keyboard, pasting and dropping,\n      // but it is still experimental technology so we can't rely on it. It's used here just as an additional check,\n      // because it seems to be the only way to detect and prevent specific keys on mobile devices. See issue #429.\n      if (this._enabledCharPattern && e.data && !this.__enabledTextRegExp.test(e.data)) {\n        e.preventDefault();\n      }\n    }\n\n    /** @private */\n    __enabledCharPatternChanged(_enabledCharPattern) {\n      this.__enabledCharRegExp = _enabledCharPattern && new RegExp('^' + _enabledCharPattern + '$');\n      this.__enabledTextRegExp = _enabledCharPattern && new RegExp('^' + _enabledCharPattern + '*$');\n    }\n\n    /** @private */\n    _getActiveErrorId(invalid, errorMessage, errorId, helperText, helperTextId, hasSlottedHelper) {\n      const ids = [];\n      if (helperText || hasSlottedHelper) {\n        ids.push(helperTextId);\n      }\n      if (errorMessage && invalid) {\n        ids.push(errorId);\n      }\n      this._setOrToggleAttribute('aria-describedby', ids.join(' '), this.focusElement);\n    }\n\n    /** @private */\n    _getActiveLabelId(label, _labelId, _inputId) {\n      let ids = _inputId;\n      if (label) {\n        ids = `${_labelId} ${_inputId}`;\n      }\n      this.focusElement.setAttribute('aria-labelledby', ids);\n    }\n\n    /** @private */\n    _getErrorMessageAriaHidden(invalid, errorMessage, errorId) {\n      return (!(errorMessage && invalid ? errorId : undefined)).toString();\n    }\n\n    /** @private */\n    _dispatchIronResizeEventIfNeeded(sizePropertyName, value) {\n      const previousSizePropertyName = '__previous' + sizePropertyName;\n      if (this[previousSizePropertyName] !== undefined && this[previousSizePropertyName] !== value) {\n        this.dispatchEvent(new CustomEvent('iron-resize', { bubbles: true, composed: true }));\n      }\n\n      this[previousSizePropertyName] = value;\n    }\n\n    /** @private */\n    __observeOffsetHeight() {\n      this.__observeOffsetHeightDebouncer = Debouncer.debounce(\n        this.__observeOffsetHeightDebouncer,\n        animationFrame,\n        () => {\n          this._dispatchIronResizeEventIfNeeded('Height', this.offsetHeight);\n        }\n      );\n    }\n\n    // Workaround for https://github.com/Polymer/polymer/issues/5259\n    get __data() {\n      return this.__dataValue || {};\n    }\n\n    set __data(value) {\n      this.__dataValue = value;\n    }\n\n    /**\n     * Fired when the user commits a value change.\n     *\n     * @event change\n     */\n\n    /**\n     * Fired when the value is changed by the user: on every typing keystroke,\n     * and the value is cleared using the clear button.\n     *\n     * @event input\n     */\n\n    /**\n     * Fired when the size of the element changes.\n     *\n     * DEPRECATED: This event will be dropped in one of the future Vaadin versions. Use a ResizeObserver instead.\n     * @event iron-resize\n     */\n  };\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { PolymerElement, html } from '@polymer/polymer/polymer-element.js';\nimport { TextFieldMixin } from './vaadin-text-field-mixin.js';\nimport { ControlStateMixin } from '@vaadin/vaadin-control-state-mixin/vaadin-control-state-mixin.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\n\n/**\n * `<vaadin-text-field>` is a Web Component for text field control in forms.\n *\n * ```html\n * <vaadin-text-field label=\"First Name\">\n * </vaadin-text-field>\n * ```\n *\n * ### Prefixes and suffixes\n *\n * These are child elements of a `<vaadin-text-field>` that are displayed\n * inline with the input, before or after.\n * In order for an element to be considered as a prefix, it must have the slot\n * attribute set to `prefix` (and similarly for `suffix`).\n *\n * ```html\n * <vaadin-text-field label=\"Email address\">\n *   <div slot=\"prefix\">Sent to:</div>\n *   <div slot=\"suffix\">@vaadin.com</div>\n * </vaadin-text-area>\n * ```\n *\n * ### Styling\n *\n * The following custom properties are available for styling:\n *\n * Custom property | Description | Default\n * ----------------|-------------|-------------\n * `--vaadin-text-field-default-width` | Set the default width of the input field | `12em`\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name | Description\n * ----------------|----------------\n * `label` | The label element\n * `input-field` | The element that wraps prefix, value and suffix\n * `value` | The text value element inside the `input-field` element\n * `error-message` | The error message element\n *\n * The following state attributes are available for styling:\n *\n * Attribute    | Description | Part name\n * -------------|-------------|------------\n * `disabled` | Set to a disabled text field | :host\n * `has-value` | Set when the element has a value | :host\n * `has-label` | Set when the element has a label | :host\n * `has-helper` | Set when the element has helper text or slot | :host\n * `has-error-message` | Set when the element has an error message | :host\n * `invalid` | Set when the element is invalid | :host\n * `input-prevented` | Temporarily set when invalid input is prevented | :host\n * `focused` | Set when the element is focused | :host\n * `focus-ring` | Set when the element is keyboard focused | :host\n * `readonly` | Set to a readonly text field | :host\n *\n * See [Styling Components](https://vaadin.com/docs/latest/ds/customization/styling-components) documentation.\n *\n * @fires {Event} input - Fired when the value is changed by the user: on every typing keystroke, and the value is cleared using the clear button.\n * @fires {Event} change - Fired when the user commits a value change.\n * @fires {CustomEvent} invalid-changed - Fired when the `invalid` property changes.\n * @fires {CustomEvent} value-changed - Fired when the `value` property changes.\n *\n * @extends HTMLElement\n * @mixes TextFieldMixin\n * @mixes ControlStateMixin\n * @mixes ThemableMixin\n * @mixes ElementMixin\n */\nclass TextFieldElement extends ElementMixin(TextFieldMixin(ControlStateMixin(ThemableMixin(PolymerElement)))) {\n  static get template() {\n    return html`\n      <style include=\"vaadin-text-field-shared-styles\"></style>\n\n      <div class=\"vaadin-text-field-container\">\n        <label part=\"label\" on-click=\"focus\" id=\"[[_labelId]]\">[[label]]</label>\n\n        <div part=\"input-field\" id=\"[[_inputId]]\">\n          <slot name=\"prefix\"></slot>\n\n          <slot name=\"input\">\n            <input part=\"value\" />\n          </slot>\n\n          <div part=\"clear-button\" id=\"clearButton\" role=\"button\" aria-label$=\"[[i18n.clear]]\"></div>\n          <slot name=\"suffix\"></slot>\n        </div>\n\n        <div part=\"helper-text\" id=\"[[_helperTextId]]\">\n          <slot name=\"helper\">[[helperText]]</slot>\n        </div>\n\n        <div\n          part=\"error-message\"\n          id=\"[[_errorId]]\"\n          aria-live=\"assertive\"\n          aria-hidden$=\"[[_getErrorMessageAriaHidden(invalid, errorMessage, _errorId)]]\"\n          >[[errorMessage]]</div\n        >\n      </div>\n    `;\n  }\n\n  static get is() {\n    return 'vaadin-text-field';\n  }\n\n  static get version() {\n    return '21.0.5';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * A regular expression that the value is checked against.\n       * The pattern must match the entire value, not just some subset.\n       */\n      pattern: {\n        type: String\n      },\n\n      /**\n       * The text usually displayed in a tooltip popup when the mouse is over the field.\n       * @type {string}\n       */\n      title: {\n        type: String\n      }\n    };\n  }\n}\n\ncustomElements.define(TextFieldElement.is, TextFieldElement);\n\nexport { TextFieldElement };\n","/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { css, registerStyles } from '@vaadin/vaadin-themable-mixin/register-styles.js';\nimport '../color.js';\nimport '../spacing.js';\nimport '../style.js';\nimport '../typography.js';\n\nconst requiredField = css`\n  [part='label'] {\n    align-self: flex-start;\n    color: var(--lumo-secondary-text-color);\n    font-weight: 500;\n    font-size: var(--lumo-font-size-s);\n    margin-left: calc(var(--lumo-border-radius-m) / 4);\n    transition: color 0.2s;\n    line-height: 1;\n    padding-bottom: 0.5em;\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    position: relative;\n    max-width: 100%;\n    box-sizing: border-box;\n  }\n\n  :host([has-label])::before {\n    margin-top: calc(var(--lumo-font-size-s) * 1.5);\n  }\n\n  :host([has-label][theme~='small'])::before {\n    margin-top: calc(var(--lumo-font-size-xs) * 1.5);\n  }\n\n  :host([has-label]) {\n    padding-top: var(--lumo-space-m);\n  }\n\n  :host([required]) [part='label'] {\n    padding-right: 1em;\n  }\n\n  [part='label']::after {\n    content: var(--lumo-required-field-indicator, '');\n    transition: opacity 0.2s;\n    opacity: 0;\n    color: var(--lumo-primary-text-color);\n    position: absolute;\n    right: 0;\n    width: 1em;\n    text-align: center;\n  }\n\n  :host([required]:not([has-value])) [part='label']::after {\n    opacity: 1;\n  }\n\n  :host([invalid]) [part='label']::after {\n    color: var(--lumo-error-text-color);\n  }\n\n  [part='error-message'] {\n    margin-left: calc(var(--lumo-border-radius-m) / 4);\n    font-size: var(--lumo-font-size-xs);\n    line-height: var(--lumo-line-height-xs);\n    color: var(--lumo-error-text-color);\n    will-change: max-height;\n    transition: 0.4s max-height;\n    max-height: 5em;\n  }\n\n  /* Margin that doesnt reserve space when theres no error message */\n  [part='error-message']:not(:empty)::before,\n  [part='error-message']:not(:empty)::after {\n    content: '';\n    display: block;\n    height: 0.4em;\n  }\n\n  :host(:not([invalid])) [part='error-message'] {\n    max-height: 0;\n    overflow: hidden;\n  }\n\n  /* RTL specific styles */\n\n  :host([dir='rtl']) [part='label'] {\n    margin-left: 0;\n    margin-right: calc(var(--lumo-border-radius-m) / 4);\n  }\n\n  :host([required][dir='rtl']) [part='label'] {\n    padding-left: 1em;\n    padding-right: 0;\n  }\n\n  :host([dir='rtl']) [part='label']::after {\n    right: auto;\n    left: 0;\n  }\n\n  :host([dir='rtl']) [part='error-message'] {\n    margin-left: 0;\n    margin-right: calc(var(--lumo-border-radius-m) / 4);\n  }\n`;\n\nregisterStyles('', requiredField, { moduleId: 'lumo-required-field' });\n\nexport { requiredField };\n","import { registerStyles, css } from '@vaadin/vaadin-themable-mixin/register-styles.js';\nimport '@vaadin/vaadin-lumo-styles/color.js';\nimport '@vaadin/vaadin-lumo-styles/sizing.js';\nimport '@vaadin/vaadin-lumo-styles/spacing.js';\nimport '@vaadin/vaadin-lumo-styles/style.js';\nimport '@vaadin/vaadin-lumo-styles/typography.js';\nimport '@vaadin/vaadin-lumo-styles/mixins/required-field.js';\nimport '@vaadin/vaadin-lumo-styles/font-icons.js';\nimport '@vaadin/vaadin-lumo-styles/mixins/field-button.js';\n\nregisterStyles(\n  'vaadin-text-field',\n  css`\n    :host {\n      --lumo-text-field-size: var(--lumo-size-m);\n      color: var(--lumo-body-text-color);\n      font-size: var(--lumo-font-size-m);\n      font-family: var(--lumo-font-family);\n      -webkit-font-smoothing: antialiased;\n      -moz-osx-font-smoothing: grayscale;\n      -webkit-tap-highlight-color: transparent;\n      padding: var(--lumo-space-xs) 0;\n    }\n\n    :host::before {\n      height: var(--lumo-text-field-size);\n      box-sizing: border-box;\n      display: inline-flex;\n      align-items: center;\n    }\n\n    :host([focused]:not([readonly])) [part='label'] {\n      color: var(--lumo-primary-text-color);\n    }\n\n    :host([has-helper]) [part='helper-text']::before {\n      content: '';\n      display: block;\n      height: 0.4em;\n    }\n\n    [part='helper-text'],\n    [part='helper-text'] ::slotted(*) {\n      display: block;\n      color: var(--lumo-secondary-text-color);\n      font-size: var(--lumo-font-size-xs);\n      line-height: var(--lumo-line-height-xs);\n      margin-left: calc(var(--lumo-border-radius-m) / 4);\n      transition: color 0.2s;\n    }\n\n    [part='value'],\n    [part='input-field'] ::slotted(input),\n    [part='input-field'] ::slotted(textarea),\n    [part='input-field'] ::slotted([part='value']) {\n      cursor: inherit;\n      min-height: var(--lumo-text-field-size);\n      padding: 0 0.25em;\n      --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);\n      -webkit-mask-image: var(--_lumo-text-field-overflow-mask-image);\n      mask-image: var(--_lumo-text-field-overflow-mask-image);\n    }\n\n    [part='value']:focus,\n    :host([focused]) [part='input-field'] ::slotted(input),\n    :host([focused]) [part='input-field'] ::slotted(textarea) {\n      -webkit-mask-image: none;\n      mask-image: none;\n    }\n\n    [part='value']::placeholder {\n      color: inherit;\n      transition: opacity 0.175s 0.1s;\n      opacity: 0.5;\n    }\n\n    [part='input-field'] {\n      border-radius: var(--lumo-border-radius-m);\n      background-color: var(--lumo-contrast-10pct);\n      padding: 0 calc(0.375em + var(--lumo-border-radius-m) / 4 - 1px);\n      font-weight: 500;\n      line-height: 1;\n      position: relative;\n      cursor: text;\n      box-sizing: border-box;\n    }\n\n    /* Used for hover and activation effects */\n    [part='input-field']::after {\n      content: '';\n      position: absolute;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      left: 0;\n      border-radius: inherit;\n      pointer-events: none;\n      background-color: var(--lumo-contrast-50pct);\n      opacity: 0;\n      transition: transform 0.15s, opacity 0.2s;\n      transform-origin: 100% 0;\n    }\n\n    /* Hover */\n\n    :host(:hover:not([readonly]):not([focused])) [part='label'],\n    :host(:hover:not([readonly])) [part='helper-text'],\n    :host(:hover:not([readonly])) [part='helper-text'] ::slotted(*) {\n      color: var(--lumo-body-text-color);\n    }\n\n    :host(:hover:not([readonly]):not([focused])) [part='input-field']::after {\n      opacity: 0.1;\n    }\n\n    /* Touch device adjustment */\n    @media (pointer: coarse) {\n      :host(:hover:not([readonly]):not([focused])) [part='label'] {\n        color: var(--lumo-secondary-text-color);\n      }\n\n      :host(:hover:not([readonly]):not([focused])) [part='input-field']::after {\n        opacity: 0;\n      }\n\n      :host(:active:not([readonly]):not([focused])) [part='input-field']::after {\n        opacity: 0.2;\n      }\n    }\n\n    /* Trigger when not focusing using the keyboard */\n    :host([focused]:not([focus-ring]):not([readonly])) [part='input-field']::after {\n      transform: scaleX(0);\n      transition-duration: 0.15s, 1s;\n    }\n\n    /* Focus-ring */\n\n    :host([focus-ring]) [part='input-field'] {\n      box-shadow: 0 0 0 2px var(--lumo-primary-color-50pct);\n    }\n\n    /* Read-only and disabled */\n    :host([readonly]) [part='value']::placeholder,\n    :host([disabled]) [part='value']::placeholder {\n      opacity: 0;\n    }\n\n    /* Read-only */\n\n    :host([readonly]) [part='input-field'] {\n      color: var(--lumo-secondary-text-color);\n      background-color: transparent;\n      cursor: default;\n    }\n\n    :host([readonly]) [part='input-field']::after {\n      background-color: transparent;\n      opacity: 1;\n      border: 1px dashed var(--lumo-contrast-30pct);\n    }\n\n    /* Disabled style */\n\n    :host([disabled]) {\n      pointer-events: none;\n    }\n\n    :host([disabled]) [part='input-field'] {\n      background-color: var(--lumo-contrast-5pct);\n    }\n\n    :host([disabled]) [part='label'],\n    :host([disabled]) [part='helper-text'],\n    :host([disabled]) [part='value'],\n    :host([disabled]) [part='input-field'] ::slotted(*) {\n      color: var(--lumo-disabled-text-color);\n      -webkit-text-fill-color: var(--lumo-disabled-text-color);\n    }\n\n    /* Invalid style */\n\n    :host([invalid]) [part='input-field'] {\n      background-color: var(--lumo-error-color-10pct);\n    }\n\n    :host([invalid]) [part='input-field']::after {\n      background-color: var(--lumo-error-color-50pct);\n    }\n\n    :host([invalid][focus-ring]) [part='input-field'] {\n      box-shadow: 0 0 0 2px var(--lumo-error-color-50pct);\n    }\n\n    :host([input-prevented]) [part='input-field'] {\n      color: var(--lumo-error-text-color);\n    }\n\n    /* Small theme */\n\n    :host([theme~='small']) {\n      font-size: var(--lumo-font-size-s);\n      --lumo-text-field-size: var(--lumo-size-s);\n    }\n\n    :host([theme~='small'][has-label]) [part='label'] {\n      font-size: var(--lumo-font-size-xs);\n    }\n\n    :host([theme~='small'][has-label]) [part='error-message'] {\n      font-size: var(--lumo-font-size-xxs);\n    }\n\n    /* Text align */\n\n    :host([theme~='align-left']) [part='value'] {\n      text-align: left;\n      --_lumo-text-field-overflow-mask-image: none;\n    }\n\n    :host([theme~='align-center']) [part='value'] {\n      text-align: center;\n      --_lumo-text-field-overflow-mask-image: none;\n    }\n\n    :host([theme~='align-right']) [part='value'] {\n      text-align: right;\n      --_lumo-text-field-overflow-mask-image: none;\n    }\n\n    @-moz-document url-prefix() {\n      /* Firefox is smart enough to align overflowing text to right */\n      :host([theme~='align-right']) [part='value'] {\n        --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent 0.25em, #000 1.5em);\n      }\n    }\n\n    @-moz-document url-prefix() {\n      /* Firefox is smart enough to align overflowing text to right */\n      :host([theme~='align-left']) [part='value'] {\n        --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent 0.25em, #000 1.5em);\n      }\n    }\n    /* helper-text position */\n\n    :host([has-helper][theme~='helper-above-field']) [part='helper-text']::before {\n      display: none;\n    }\n\n    :host([has-helper][theme~='helper-above-field']) [part='helper-text']::after {\n      content: '';\n      display: block;\n      height: 0.4em;\n    }\n\n    :host([has-helper][theme~='helper-above-field']) [part='label'] {\n      order: 0;\n      padding-bottom: 0.4em;\n    }\n\n    :host([has-helper][theme~='helper-above-field']) [part='helper-text'] {\n      order: 1;\n    }\n\n    :host([has-helper][theme~='helper-above-field']) [part='input-field'] {\n      order: 2;\n    }\n\n    :host([has-helper][theme~='helper-above-field']) [part='error-message'] {\n      order: 3;\n    }\n\n    /* Slotted content */\n\n    [part='input-field'] ::slotted(:not([part]):not(iron-icon):not(vaadin-icon):not(input):not(textarea)) {\n      color: var(--lumo-secondary-text-color);\n      font-weight: 400;\n    }\n\n    /* Slotted icons */\n    [part='input-field'] ::slotted(vaadin-icon),\n    [part='input-field'] ::slotted(iron-icon) {\n      color: var(--lumo-contrast-60pct);\n      width: var(--lumo-icon-size-m);\n      height: var(--lumo-icon-size-m);\n    }\n\n    /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */\n    [part='input-field'] ::slotted(vaadin-icon[icon^='vaadin:']),\n    [part='input-field'] ::slotted(iron-icon[icon^='vaadin:']) {\n      padding: 0.25em;\n      box-sizing: border-box !important;\n    }\n\n    [part='clear-button']::before {\n      content: var(--lumo-icons-cross);\n    }\n\n    /* RTL specific styles */\n\n    :host([dir='rtl']) [part='input-field']::after {\n      transform-origin: 0% 0;\n    }\n\n    :host([dir='rtl']) [part='value'],\n    :host([dir='rtl']) [part='input-field'] ::slotted(input),\n    :host([dir='rtl']) [part='input-field'] ::slotted(textarea) {\n      --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent, #000 1.25em);\n    }\n\n    :host([dir='rtl']) [part='value']:focus,\n    :host([focused][dir='rtl']) [part='input-field'] ::slotted(input),\n    :host([focused][dir='rtl']) [part='input-field'] ::slotted(textarea) {\n      -webkit-mask-image: none;\n      mask-image: none;\n    }\n\n    @-moz-document url-prefix() {\n      :host([dir='rtl']) [part='value'],\n      :host([dir='rtl']) [part='input-field'] ::slotted(input),\n      :host([dir='rtl']) [part='input-field'] ::slotted(textarea),\n      :host([dir='rtl']) [part='input-field'] ::slotted([part='value']) {\n        mask-image: var(--_lumo-text-field-overflow-mask-image);\n      }\n    }\n\n    :host([theme~='align-left'][dir='rtl']) [part='value'] {\n      --_lumo-text-field-overflow-mask-image: none;\n    }\n\n    :host([theme~='align-center'][dir='rtl']) [part='value'] {\n      --_lumo-text-field-overflow-mask-image: none;\n    }\n\n    :host([theme~='align-right'][dir='rtl']) [part='value'] {\n      --_lumo-text-field-overflow-mask-image: none;\n    }\n\n    @-moz-document url-prefix() {\n      /* Firefox is smart enough to align overflowing text to right */\n      :host([theme~='align-right'][dir='rtl']) [part='value'] {\n        --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent 0.25em, #000 1.5em);\n      }\n    }\n\n    @-moz-document url-prefix() {\n      /* Firefox is smart enough to align overflowing text to right */\n      :host([theme~='align-left'][dir='rtl']) [part='value'] {\n        --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent 0.25em, #000 1.5em);\n      }\n    }\n  `,\n  { moduleId: 'lumo-text-field', include: ['lumo-required-field', 'lumo-field-button'] }\n);\n"],"names":[],"sourceRoot":""}